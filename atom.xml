<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Microwave. Five minutes.</title>
  
  <subtitle>他大概会说你想得太多</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pazyx.xyz/"/>
  <updated>2018-08-11T16:27:52.833Z</updated>
  <id>https://pazyx.xyz/</id>
  
  <author>
    <name>pazyx.xyz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法训练营解题总结（第二周）//ToDo</title>
    <link href="https://pazyx.xyz/2018/08/12/algor_club_code_2/"/>
    <id>https://pazyx.xyz/2018/08/12/algor_club_code_2/</id>
    <published>2018-08-11T16:30:49.000Z</published>
    <updated>2018-08-11T16:27:52.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意-amp-代码实现"><a href="#题目大意-amp-代码实现" class="headerlink" title="题目大意 &amp; 代码实现"></a>题目大意 &amp; 代码实现</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>给出n个整数，将它们从小到大排序后输出。</p><ul><li>对于前30%的数据，n ≤ 100，给出的n个整数的绝对值不超过10；</li><li>对于前60%的数据，n ≤ 5000，给出的n个整数的绝对值不超过10^9；</li><li>对于另20%的数据，n ≤ 500000，给出的n个整数的绝对值不超过10^5；</li><li>对于100%的数据，n ≤ 500000，给出的n个整数的绝对值不超过10^9。</li></ul><p>时间：2 sec<br>空间：256 MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        a.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    <span class="comment">//a = getAnswer(n, a);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, a[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>有n个正整数排成一排，你要将这些数分成m份（同一份中的数字都是连续的，不能隔开），同时数字之和最大的那一份的数字之和尽量小。</p><ul><li>对于50%的数据，n ≤ 100，给出的n个正整数不超过10；</li><li>对于100%的数据，m ≤ n ≤ 300000，给出的n个正整数不超过1000000。</li></ul><p>时间：4 sec<br>空间：512 MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> d, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>( a[i] &gt; d )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum += a[i];</span><br><span class="line">        <span class="keyword">if</span>( sum &gt; d ) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            i--;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; m)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所给数组分成连续的m份，使得数字之和最大的那一份的数字之和最小</span></span><br><span class="line"><span class="comment">// n：数组大小</span></span><br><span class="line"><span class="comment">// m：题中的m</span></span><br><span class="line"><span class="comment">// a：所给数组，大小为n</span></span><br><span class="line"><span class="comment">// 返回值：最优方案中，数字之和最大的那一份的数字之和</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        r += a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( l &lt;= r ) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid, n, m, a))</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getAnswer(n, m, a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大转盘"><a href="#大转盘" class="headerlink" title="大转盘"></a>大转盘</h2><p>邓老师有一个大转盘，被平分成了 2^n 份。<br>邓老师还有一个长度为 2^n 的数组 a（下标从 0 开始），其中的每个元素都是 0 或 1。于是邓老师就可以选择大转盘上的一个位置，将 a[0] 填入其中，然后按顺时针顺序依次将 a[1],a[2],…,a[2^n-1] 填入。<br>对于大转盘上的一个指定位置，邓老师可以从它开始，取出顺时针方向的 n 个位置，并将它们按原顺序拼接起来，得到一个长度为 n 的 01 串，也就是一个 n 位二进制数。我们把这个二进制数称作从这个位置开始的幸运数。<br>显然地，大转盘上共有 2^n 个位置可以获得幸运数，而巧合的是 n 位二进制数恰好也有 2^n 个，所以邓老师希望这些所有的幸运数包含了所有的 n 位二进制数。<br>请输出一个数组 a，使其满足邓老师的要求。（如果有多解，输出任一即可）</p><p>本题包含 16 个测试点。对于第 i 个测试点（1&lt;=i&lt;=16），满足 n=i。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> allOne;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">string</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twoPow</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i][u])&#123;</span><br><span class="line">            <span class="keyword">int</span> v = ((u &lt;&lt; <span class="number">1</span>) | i) &amp; allOne;</span><br><span class="line">            vis[i][u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            dfs(v);</span><br><span class="line">            ans.push_back(<span class="string">'0'</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本函数求解大转盘上的数，你需要把大转盘上的数按顺时针顺序返回</span></span><br><span class="line"><span class="comment">// n：对应转盘大小，意义与题目描述一致，具体见题目描述。</span></span><br><span class="line"><span class="comment">// 返回值：将大转盘上的数按顺时针顺序放到一个string中并返回</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    allOne = twoPow(n - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i )</span><br><span class="line">        vis[i].resize(twoPow(n - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; getAnswer(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="象棋"><a href="#象棋" class="headerlink" title="象棋"></a>象棋</h2><p>你有足够多的象棋“车”，在一个n×n的棋盘上你能放多少个“车”呢？注意，所给棋盘上有些位置不能放任何东西。同时，某一行（列）最多只能存在一个“车”。</p><ul><li>对于30%的数据，n ≤ 5；</li><li>对于60%的数据，n ≤ 20；</li><li>对于100%的数据，n ≤ 500。</li></ul><p>时间：2 sec<br>空间：256 MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span> * <span class="number">2</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">&#125; e[M];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, ihead[N], mc[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    e[cnt].next = ihead[x];</span><br><span class="line">    e[cnt].to = y;</span><br><span class="line">    ihead[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = ihead[x]; i; i = e[i].next )&#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">            vis[y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(mc[y] == <span class="number">0</span> || dfs(mc[y]))&#123;</span><br><span class="line">                <span class="comment">//3</span></span><br><span class="line">                mc[x] = y;</span><br><span class="line">                mc[y] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解棋盘上最多能放多少个“车”</span></span><br><span class="line"><span class="comment">// n：棋盘的大小为n×n的</span></span><br><span class="line"><span class="comment">// board：所给棋盘，对于某个位置上的数：若值为1表示可以放“车”；若值为0表示不能放“车”</span></span><br><span class="line"><span class="comment">// 返回值：能放“车”的最大个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)&#123;</span><br><span class="line">        ihead[i] = <span class="number">0</span>;</span><br><span class="line">        mc[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="comment">//1</span></span><br><span class="line">            <span class="keyword">if</span>(board[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">                add(i,j+n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mc[i])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (n * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(dfs(i))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            t.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        e.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getAnswer(n, e));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列计数"><a href="#序列计数" class="headerlink" title="序列计数"></a>序列计数</h2><p>给定一个n个整数的序列以及一个非负整数d，请你输出这个序列中有多少个连续子序列（长度大于1），满足该子序列的最大值最小值之差不大于d。</p><ul><li>对于60%的数据，n ≤ 5000；</li><li>对于100%的数据，n ≤ 300000。</li><li>保证所有整数的绝对值不超过10^9，d不超过2×10^9。</li></ul><p>时间：10 sec<br>空间：512 MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cmath&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300005</span>;</span><br><span class="line"><span class="keyword">int</span> n,d,max_value[N],min_value[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;<span class="comment">//中点</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = solve(l,mid)+solve(mid+<span class="number">1</span>,r);<span class="comment">//分治求出左右两半的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">        min_value[i] = (i == mid + <span class="number">1</span>) ? a[i] : min(min_value[i - <span class="number">1</span>], a[i]);</span><br><span class="line">        max_value[i] = (i == mid + <span class="number">1</span>) ? a[i] : max(max_value[i - <span class="number">1</span>], a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mn = <span class="number">0</span>, mx = <span class="number">0</span>, pos = r;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = mid; i &gt;= l &amp;&amp; pos &gt; mid; i--)&#123;</span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line">        mn = (i==mid)?a[i]:min(mn,a[i]);</span><br><span class="line">        mx = (i==mid)?a[i]:max(mx,a[i]);</span><br><span class="line">        <span class="keyword">for</span>(; pos &gt; mid &amp;&amp; max(mx,max_value[pos]) - min(mn,min_value[pos]) &gt; d; pos--);</span><br><span class="line">        ans += pos - mid;<span class="comment">//更新答案</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出有多少个a数组中的连续子序列（长度大于1），满足该子序列的最大值最小值之差不大于d</span></span><br><span class="line"><span class="comment">// n：a数组的长度</span></span><br><span class="line"><span class="comment">// d：所给d</span></span><br><span class="line"><span class="comment">// a：数组a，长度为n</span></span><br><span class="line"><span class="comment">// 返回值：满足条件的连续子序列的个数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    ::n = n;</span><br><span class="line">    ::d = d;</span><br><span class="line">    ::a = a;</span><br><span class="line">    <span class="keyword">return</span> solve(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;d);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getAnswer(n, d, a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小交换"><a href="#最小交换" class="headerlink" title="最小交换"></a>最小交换</h2><p>给定一个 1 到 n 的排列（即一个序列，其中 [1,n] 之间的正整数每个都出现了恰好 1 次）。<br>你可以花 1 元钱交换两个相邻的数。<br>现在，你希望把它们升序排序。求你完成这个目标最少需要花费多少元钱。</p><ul><li>对于 20% 的数据，保证 n&lt;=7。</li><li>对于 60% 的数据，保证 n&lt;=1,000。</li><li>对于 100% 的数据，保证 n&lt;=200,000。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq, seqTemp;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(l, mid);</span><br><span class="line">    mergeSort(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> p = l, q = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q &gt; r || p &lt;= mid &amp;&amp; seq[p] &lt;= seq[q])</span><br><span class="line">            seqTemp[i] = seq[p++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            seqTemp[i] = seq[q++];</span><br><span class="line">            cnt += (mid - p + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        seq[i] = seqTemp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的功能是计算答案（即最少花费的金钱）</span></span><br><span class="line"><span class="comment">// n：表示序列长度</span></span><br><span class="line"><span class="comment">// a：存储整个序列 a</span></span><br><span class="line"><span class="comment">// 返回值：最少花费的金钱（需要注意，返回值的类型为 64 位有符号整数）</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    seq = a;</span><br><span class="line">    seqTemp.resize(n);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    mergeSort(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.clear();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        a.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = getAnswer(n, a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="楼尔邦德"><a href="#楼尔邦德" class="headerlink" title="楼尔邦德"></a>楼尔邦德</h2><p>给定包含 n 个数的序列 A。<br>再给出 Q 个询问，每个询问包含一个数 x，询问的是序列 A 中不小于 x 的最小整数是多少（无解输出-1）。</p><ul><li>对于 50% 的数据，保证 n&lt;=2000。</li><li>对于 100% 的数据，保证 n&lt;=300,000。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本函数传入数组 a 及所有询问，你需要求解所有询问并一并返回</span></span><br><span class="line"><span class="comment">// n：序列 a 的长度</span></span><br><span class="line"><span class="comment">// a：存储了序列 a</span></span><br><span class="line"><span class="comment">// Q：询问个数</span></span><br><span class="line"><span class="comment">// query：依次存储了所有询问的参数 x</span></span><br><span class="line"><span class="comment">// 返回值：一个 vector&lt;int&gt;，依次存放各询问的答案</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAnswer(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> Q, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; query) &#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    ans.clear();</span><br><span class="line">    sort(a.begin(), a.end());</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> key = query[i];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">-1</span>,r = n,mid;</span><br><span class="line">        <span class="keyword">while</span>(l+<span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid] &lt; key)</span><br><span class="line">                l = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = r;</span><br><span class="line">        <span class="keyword">if</span>(pos &gt;= n)</span><br><span class="line">            ans.push_back(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans.push_back(a[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, Q, tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, query;</span><br><span class="line">    a.clear();</span><br><span class="line">    query.clear();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        a.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        query.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = getAnswer(n, a, Q, query);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>给定一张 n 个点的无向带权图，节点的编号从 1 至 n，求从 S 到 T 的最短路径长度。</p><p>本题共设置 12 个测试点。</p><ul><li>对于前 10 个测试点，保证 n&lt;=2500，m&lt;=6200，对于每条边有 w&lt;=1000。这部分数据有梯度。</li><li>对于所有的 12 个测试点，保证 n&lt;=100,000，m&lt;=250,000。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;set&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100050</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, weight;</span><br><span class="line">    edge(<span class="keyword">int</span> ne,<span class="keyword">int</span> we):next(ne),weight(we)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt;G[MAX_N];   <span class="comment">//邻接表表示的图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];</span><br><span class="line"><span class="comment">//int path[MAX_N];</span></span><br><span class="line"><span class="keyword">bool</span> collected[MAX_N];  <span class="comment">//标记每个顶点是否被收录</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(collected,<span class="number">0</span>,<span class="keyword">sizeof</span>(collected));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;P, less&lt;P&gt; &gt; min_heap;  </span><br><span class="line">    <span class="comment">//用 set 来伪实现一个小根堆，并具有映射二叉堆的功能。</span></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    min_heap.insert(make_pair(<span class="number">0</span>, start));</span><br><span class="line">    collected[start] = <span class="literal">true</span>;   </span><br><span class="line">    <span class="keyword">while</span>(min_heap.size())&#123;    </span><br><span class="line">    <span class="comment">//如果堆为空，说明所有点都已被收录，结束该算法</span></span><br><span class="line">        <span class="keyword">auto</span> iter = min_heap.begin();</span><br><span class="line">        <span class="keyword">int</span> v = iter-&gt;second;</span><br><span class="line">        min_heap.erase(*iter);</span><br><span class="line">        collected[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class="line">            edge e = G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(!collected[e.next] </span><br><span class="line">            &amp;&amp; dist[e.next] &gt; dist[v] + e.weight)</span><br><span class="line">            &#123;</span><br><span class="line">                min_heap.erase(make_pair(dist[e.next], e.next));    </span><br><span class="line">                dist[e.next] = dist[v] + e.weight;</span><br><span class="line">                <span class="comment">//path[e.next] = v;</span></span><br><span class="line">                min_heap.insert(make_pair(dist[e.next], e.next));   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数用于计算答案（最短路）</span></span><br><span class="line"><span class="comment">// n：节点数目</span></span><br><span class="line"><span class="comment">// m：双向边数目</span></span><br><span class="line"><span class="comment">// U,V,W：分别存放各边的两端点、边权</span></span><br><span class="line"><span class="comment">// s,t：分别表示起点、重点</span></span><br><span class="line"><span class="comment">// 返回值：答案（即从 s 到 t 的最短路径长度）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; U, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; W, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        G[U[i]].push_back(edge(V[i],W[i]));</span><br><span class="line">        G[V[i]].push_back(edge(U[i],W[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(s);</span><br><span class="line">    <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; U, V, W;</span><br><span class="line">    U.clear();</span><br><span class="line">    V.clear();</span><br><span class="line">    W.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        U.push_back(u);</span><br><span class="line">        V.push_back(v);</span><br><span class="line">        W.push_back(w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, shortestPath(n, m, U, V, W, s, t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><h2 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h2><p>涉及题目：</p><ul><li>分组</li><li>序列计数</li><li>楼尔邦德</li></ul><h2 id="Dijkstra-的局限"><a href="#Dijkstra-的局限" class="headerlink" title="Dijkstra 的局限"></a>Dijkstra 的局限</h2><p>之前只认为，Dijkstra 算法不可以处理带有负值圈的图。实际上 Dijkstra 在处理有复值边权的图时很可能不正确。</p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 w = 1</span><br><span class="line">1 -&gt; 3 w = 2</span><br><span class="line">2 -&gt; 4 w = 1</span><br><span class="line">3 -&gt; 2 w = -2</span><br></pre></td></tr></table></figure></p><p>正确答案为 0，Dijkstra 给出的答案为 1 。</p><h2 id="一些算法"><a href="#一些算法" class="headerlink" title="一些算法"></a>一些算法</h2><ul><li>二分图最大匹配</li><li>求欧拉回路</li><li>归并排序求逆序对</li></ul><h1 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h1><h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><p>手动实现</p><ul><li>冒泡排序</li><li>插入排序</li><li>选择排序</li><li>快速排序</li></ul><h2 id="最小交换-1"><a href="#最小交换-1" class="headerlink" title="最小交换"></a>最小交换</h2><p>使用树状数组优化求逆序对的暴力算法，达到与归并排序相同的复杂度。</p><h2 id="总结欧拉回路算法"><a href="#总结欧拉回路算法" class="headerlink" title="总结欧拉回路算法"></a>总结欧拉回路算法</h2><ul><li><a href="https://www.jisuanke.com/minicourse/740/37823" target="_blank" rel="noopener">欧拉回路 计蒜客</a></li></ul><h2 id="总结匈牙利算法"><a href="#总结匈牙利算法" class="headerlink" title="总结匈牙利算法"></a>总结匈牙利算法</h2><ul><li><a href="https://www.jisuanke.com/minicourse/741/37831" target="_blank" rel="noopener">匈牙利算法 计蒜客</a></li></ul><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>学习使用 <code>std::lower_bound</code> ，注意边界。</p><h2 id="实现-Bellman-Ford-算法"><a href="#实现-Bellman-Ford-算法" class="headerlink" title="实现 Bellman-Ford 算法"></a>实现 Bellman-Ford 算法</h2><p>伪代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始化 mind 数组</span><br><span class="line">mind[0] : 0</span><br><span class="line">for round 1 to n</span><br><span class="line">枚举所有边 (u,v,len)</span><br><span class="line">mind[v] : min(min[v],mind[u]+len)</span><br><span class="line">if 本轮中没有点被更新</span><br><span class="line">break;</span><br><span class="line">if round == n+1</span><br><span class="line">无解</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目大意-amp-代码实现&quot;&gt;&lt;a href=&quot;#题目大意-amp-代码实现&quot; class=&quot;headerlink&quot; title=&quot;题目大意 &amp;amp; 代码实现&quot;&gt;&lt;/a&gt;题目大意 &amp;amp; 代码实现&lt;/h1&gt;&lt;h2 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot;
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Dijkstra" scheme="https://pazyx.xyz/tags/Dijkstra/"/>
    
      <category term="ToDo" scheme="https://pazyx.xyz/tags/ToDo/"/>
    
      <category term="二分" scheme="https://pazyx.xyz/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="匈牙利算法" scheme="https://pazyx.xyz/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://pazyx.xyz/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://pazyx.xyz/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="欧拉回路" scheme="https://pazyx.xyz/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
    
      <category term="Bellman-Ford" scheme="https://pazyx.xyz/tags/Bellman-Ford/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营解题总结（第一周）//ToDo</title>
    <link href="https://pazyx.xyz/2018/08/04/algor_club_code_1/"/>
    <id>https://pazyx.xyz/2018/08/04/algor_club_code_1/</id>
    <published>2018-08-03T18:30:49.000Z</published>
    <updated>2018-08-03T18:31:58.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意-amp-代码实现"><a href="#题目大意-amp-代码实现" class="headerlink" title="题目大意 &amp; 代码实现"></a>题目大意 &amp; 代码实现</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>简单的栈实现，我使用数组实现，可以使用 <code>vector</code> 代替数组。日常可以直接使用 STL 库中的 <code>stack</code> 类，但其无法进行 “call by rank” 的访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">int</span> mtop = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">string</span> mstack[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压入栈顶</span></span><br><span class="line"><span class="comment">// name：被压入的人的姓名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">    mtop++;</span><br><span class="line">    mstack[mtop] = name;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出栈顶</span></span><br><span class="line"><span class="comment">// 返回值：被弹出人的姓名</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mtop &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">        mtop--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mstack[mtop+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 询问栈中某个位置上的人的姓名（栈底位置为1，向栈顶方向的位置依次递增）</span></span><br><span class="line"><span class="comment">// pos：询问的位置</span></span><br><span class="line"><span class="comment">// 返回值：pos位置上人的姓名</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="keyword">return</span> mstack[pos<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (; n--; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line">            push(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, pop().c_str());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pos);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, query(pos).c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>简单的队列实现，这个队列问题很大，就是元素出队后的空间无法回收，造成无法持续使用，占用空间大的问题。题目要求较低。应该使用链表或循环数组实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> mque[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾入队</span></span><br><span class="line"><span class="comment">// name：入队人的姓名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">    mque[h] = name;</span><br><span class="line">    h++;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队首出队</span></span><br><span class="line"><span class="comment">// 返回值：队首的姓名</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q++;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="keyword">return</span> mque[q<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 询问队列中某个位置上的人的姓名（队首位置为1，往后位置依次递增）</span></span><br><span class="line"><span class="comment">// pos：询问的位置</span></span><br><span class="line"><span class="comment">// 返回值：pos位置上人的姓名</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mque[q+pos<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (; n--; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line">            enqueue(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dequeue().c_str());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pos);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, query(pos).c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>实现并维护二叉搜索树，并输出其前序和后序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    node* l;</span><br><span class="line">    node* r;</span><br><span class="line">    node():val(<span class="number">0</span>),l(<span class="literal">nullptr</span>),r(<span class="literal">nullptr</span>)&#123;&#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node* root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v, node*&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="keyword">new</span> node();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">        x-&gt;l = <span class="literal">nullptr</span>;</span><br><span class="line">        x-&gt;r = <span class="literal">nullptr</span>;</span><br><span class="line">        x-&gt;val = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= x-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(v,x-&gt;l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; x-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(v,x-&gt;r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlr</span><span class="params">( node* x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)&#123;</span><br><span class="line">        ans.push_back(x-&gt;val);</span><br><span class="line">        dlr(x-&gt;l,ans);</span><br><span class="line">        dlr(x-&gt;r,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrd</span><span class="params">( node* x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)&#123;</span><br><span class="line">        lrd(x-&gt;l,ans);</span><br><span class="line">        lrd(x-&gt;r,ans);</span><br><span class="line">        ans.push_back(x-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAnswer(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(sequence.size()); ++i)</span><br><span class="line">        insert(sequence[i],root);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    dlr(root,ans);</span><br><span class="line">    lrd(root,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        sequence.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = getAnswer(n, sequence);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans.size() &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[n + i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字盒子"><a href="#数字盒子" class="headerlink" title="数字盒子"></a>数字盒子</h2><p>Hash Map 实现，由于我的问题，没有去实现，使用了STL库中的 <code>map</code> 类，周末会补充 Hash Map 的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行操作时会调用这个函数</span></span><br><span class="line"><span class="comment">// op：对应该次操作的 op（具体请见题目描述）</span></span><br><span class="line"><span class="comment">// x：对应该次操作的 x（具体请见题目描述）</span></span><br><span class="line"><span class="comment">// 返回值：如果输出为"Succeeded"，则这个函数返回 1，否则返回 0</span></span><br><span class="line"><span class="built_in">map</span>&lt;ll,<span class="keyword">bool</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> op, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[x])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[x])&#123;</span><br><span class="line">            Map[x] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Map[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Q, op;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="built_in">puts</span>(check(op, x) ? <span class="string">"Succeeded"</span> : <span class="string">"Failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重编码"><a href="#重编码" class="headerlink" title="重编码"></a>重编码</h2><p>哈夫曼编码问题，合并森林。<br>与 <a href="/2018/01/24/poj-3253-fence-repair/">POJ 3253 Fence Repair</a> 相似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;queue&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是求解整个问题的函数</span></span><br><span class="line"><span class="comment">// w：题目描述中的 w（所有）</span></span><br><span class="line"><span class="comment">// n：题目描述中的 n</span></span><br><span class="line"><span class="comment">// 返回值：答案</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;ll, <span class="built_in">vector</span>&lt;ll&gt;, greater&lt;ll&gt; &gt; q; </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;ll&gt; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;    <span class="comment">//把n块木板的长度入队</span></span><br><span class="line">        q.push(w[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.size() &gt; <span class="number">1</span>)&#123;            <span class="comment">//如果还没有合成一块木板就继续合并</span></span><br><span class="line">        ll minOne,minTwo;</span><br><span class="line">        minOne = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        minTwo = q.top();</span><br><span class="line">        q.pop();                        <span class="comment">//从队头拿出两个最短的木板</span></span><br><span class="line">        sum += (minOne + minTwo);       <span class="comment">//加上这次合并的开销</span></span><br><span class="line">        q.push(minOne+minTwo);   <span class="comment">//将合并后的木板入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line">        w.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getAnswer(n, w));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成绩排序"><a href="#成绩排序" class="headerlink" title="成绩排序"></a>成绩排序</h2><p>排序并输出逆序对数目，使用冒泡排序在每次交换记数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是进行排序的函数</span></span><br><span class="line"><span class="comment">// n：题目描述中的 n</span></span><br><span class="line"><span class="comment">// A：各同学的算法训练营成绩</span></span><br><span class="line"><span class="comment">// DS：各同学的数据结构训练营成绩</span></span><br><span class="line"><span class="comment">// 返回值：将要输出的数字依次加入到返回值的数组中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> algorithm,dataStruct;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    student()&#123;&#125;</span><br><span class="line">    student(<span class="keyword">int</span> i,<span class="keyword">int</span> a,<span class="keyword">int</span> d):id(i),algorithm(a),dataStruct(d),score(a+d)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (student a,student b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score &lt; b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.score == b.score)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.algorithm &lt; b.algorithm)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;student&gt; &amp;a,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = size<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;          <span class="comment">//记录在一趟排序中是否有交换</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                student temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">                <span class="comment">//swap(a[j],a[j+1]);</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAnswer(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DS) &#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; temp;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        temp.push_back(student(i+<span class="number">1</span>,A[i],DS[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = BubbleSort(temp,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        ans.push_back(temp[i].id);</span><br><span class="line">        ans.push_back(temp[i].score);</span><br><span class="line">        ans.push_back(temp[i].algorithm);</span><br><span class="line">        ans.push_back(temp[i].dataStruct);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(cnt);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, DS;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, ds;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;ds);</span><br><span class="line">        A.push_back(a);</span><br><span class="line">        DS.push_back(ds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = getAnswer(n, A, DS);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>, ans[cnt], ans[cnt + <span class="number">1</span>], ans[cnt + <span class="number">2</span>], ans[cnt + <span class="number">3</span>]);</span><br><span class="line">        cnt += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[cnt]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="等式"><a href="#等式" class="headerlink" title="等式"></a>等式</h2><p>来源：<em>NOI 2015 day1 T1 程序自动分析</em><br>简单并查集题目，主意一下检查应该留到最后检查即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定n个变量以及m个约束，判定是否能找出一种赋值方案满足这m个约束条件</span></span><br><span class="line"><span class="comment">// n：如题意</span></span><br><span class="line"><span class="comment">// m：如题意</span></span><br><span class="line"><span class="comment">// A：大小为m的数组，表示m条约束中的a</span></span><br><span class="line"><span class="comment">// B：大小为m的数组，表示m条约束中的b</span></span><br><span class="line"><span class="comment">// E：大小为m的数组，表示m条约束中的e</span></span><br><span class="line"><span class="comment">// 返回值：若能找出一种方案，返回"Yes"；否则返回"No"（不包括引号）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">500005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">500004</span>; i++)&#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[x] == x)&#123;</span><br><span class="line">    <span class="comment">//x 节点就是根节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[x] = get(pre[x]);</span><br><span class="line">    <span class="comment">//返回父节点的根节点，并另当前节点父节点直接为根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = get(x);</span><br><span class="line">    y = get(y);</span><br><span class="line">    <span class="keyword">if</span>(x != y)&#123;<span class="comment">// 不住同一个集合</span></span><br><span class="line">        pre[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; E)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zero;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(E[i])&#123;</span><br><span class="line">            merge(A[i],B[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            zero.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zero.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(get(A[zero[i]]) == get(B[zero[i]]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"No"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Yes"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); T--; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B, E;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, e;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;e);</span><br><span class="line">            A.push_back(a);</span><br><span class="line">            B.push_back(b);</span><br><span class="line">            E.push_back(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, getAnswer(n, m, A, B, E).c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="道路升级"><a href="#道路升级" class="headerlink" title="道路升级"></a>道路升级</h2><p>最大生成树问题，与最小生成树一样。<br>使用 Kruskal 算法解决，需要简单实现一下并查集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">200050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">400050</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;a)</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> w &gt; a.w; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[MAX_M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAX_N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = get(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAnswer(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; U, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        e[i].u = U[i];</span><br><span class="line">        e[i].v = V[i];</span><br><span class="line">        e[i].w = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e,e+m);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = get(e[i].u), y = get(e[i].v);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">            re.push_back(e[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(re.begin(), re.end());</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; U, V;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        U.push_back(u);</span><br><span class="line">        V.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = getAnswer(n, m, U, V);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">int</span>(ans.size()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(ans.size()); ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><h2 id="输入输出挂"><a href="#输入输出挂" class="headerlink" title="输入输出挂"></a>输入输出挂</h2><p>输入输出挂是真的快！</p><p>简单的数字输入输出挂，完整的见 -&gt; <a href="https://blog.csdn.net/f_zyj/article/details/51473493" target="_blank" rel="noopener">这里</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Scan</span><span class="params">()</span> </span>&#123;    <span class="comment">//输入外挂</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">if</span>((ch = getchar()) == <span class="string">'-'</span>) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) res = ch - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar()) &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        res = res * <span class="number">10</span> + (ch - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> flag ? -res : res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Out</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;    <span class="comment">//输出外挂</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">'-'</span>); a = -a; &#125;</span><br><span class="line">    <span class="keyword">if</span>(a &gt;= <span class="number">10</span>) Out(a / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(a % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="输入输出分离"><a href="#输入输出分离" class="headerlink" title="输入输出分离"></a>输入输出分离</h2><p>助教给的解题模板真舒服，可以不用考虑输出问题，专心实现算法～～～<br>代码可读性也提高不少，但竞赛中打的时间也许会增加一些，复杂度也会增加一些。</p><h2 id="哈夫曼编码-amp-POJ-3253"><a href="#哈夫曼编码-amp-POJ-3253" class="headerlink" title="哈夫曼编码 &amp; POJ 3253"></a>哈夫曼编码 &amp; POJ 3253</h2><p>哈夫曼编码就是贪心～<br>在《挑战程序设计竞赛(第2版) 》中讲解的 POJ 3253 现在一看真是醍醐灌顶～～～</p><h2 id="学到一些算法实现"><a href="#学到一些算法实现" class="headerlink" title="学到一些算法实现"></a>学到一些算法实现</h2><ul><li>二叉树</li><li>Kruskal 算法</li><li>哈夫曼编码的 \(O(n)\) 实现</li></ul><h2 id="题目中数据范围分析技巧"><a href="#题目中数据范围分析技巧" class="headerlink" title="题目中数据范围分析技巧"></a>题目中数据范围分析技巧</h2><p>计算机每秒运算 \(10^8\)</p><ul><li>\(n = 10^6\) -&gt; \(O(n)\)</li><li>\(n = 5  \times 10^5\) -&gt; \(O(n log n)\)</li><li>\(n = 10^4\) -&gt; \(O(n^2)\)</li></ul><hr><h1 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h1><h2 id="Hash-Map-的实现"><a href="#Hash-Map-的实现" class="headerlink" title="Hash Map 的实现"></a>Hash Map 的实现</h2><p>…</p><h2 id="哈夫曼编码的-O-n-实现"><a href="#哈夫曼编码的-O-n-实现" class="headerlink" title="哈夫曼编码的 \(O(n)\) 实现"></a>哈夫曼编码的 \(O(n)\) 实现</h2><p>使用栈和队列优化</p><h2 id="成绩排序-优化"><a href="#成绩排序-优化" class="headerlink" title="成绩排序 优化"></a>成绩排序 优化</h2><p>\(O(n^2)\) -&gt; \(O(n log n)\)</p><p>排序 -&gt; 快排排序、归并排序<br>求逆序对 -&gt; 归并排序、树状数组辅助统计</p><h2 id="重编码-gt-【NOI2015】荷马史诗"><a href="#重编码-gt-【NOI2015】荷马史诗" class="headerlink" title="重编码 -&gt;【NOI2015】荷马史诗"></a>重编码 -&gt;【NOI2015】荷马史诗</h2><p>不同进制下的哈夫曼编码。<br><a href="http://uoj.ac/problem/130" target="_blank" rel="noopener">【NOI2015】荷马史诗</a></p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/sdfgdbvc/article/details/51490791" target="_blank" rel="noopener">输入输出外挂</a></li><li><a href="https://blog.csdn.net/f_zyj/article/details/51473493" target="_blank" rel="noopener">输入输出外挂总结</a></li><li><a href="https://blog.csdn.net/yang_teng_/article/details/53493125" target="_blank" rel="noopener">二叉树的C++简单实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目大意-amp-代码实现&quot;&gt;&lt;a href=&quot;#题目大意-amp-代码实现&quot; class=&quot;headerlink&quot; title=&quot;题目大意 &amp;amp; 代码实现&quot;&gt;&lt;/a&gt;题目大意 &amp;amp; 代码实现&lt;/h1&gt;&lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; c
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="栈" scheme="https://pazyx.xyz/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://pazyx.xyz/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="并查集" scheme="https://pazyx.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="二叉树" scheme="https://pazyx.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="哈夫曼编码" scheme="https://pazyx.xyz/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    
      <category term="Kruskal" scheme="https://pazyx.xyz/tags/Kruskal/"/>
    
      <category term="Hash Map" scheme="https://pazyx.xyz/tags/Hash-Map/"/>
    
      <category term="输入输出挂" scheme="https://pazyx.xyz/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8C%82/"/>
    
      <category term="ToDo" scheme="https://pazyx.xyz/tags/ToDo/"/>
    
  </entry>
  
  <entry>
    <title>求质数表3——高级筛法</title>
    <link href="https://pazyx.xyz/2018/07/26/isprimes-3/"/>
    <id>https://pazyx.xyz/2018/07/26/isprimes-3/</id>
    <published>2018-07-26T11:36:26.000Z</published>
    <updated>2018-07-26T11:37:44.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="增量式筛法"><a href="#增量式筛法" class="headerlink" title="增量式筛法"></a>增量式筛法</h1><p>之前的筛法都需要事先指定一个N，然后求N以内的质数，但没办法求N以上的质数。我们想要一种算法不用事先指定N一直求下去，如试除法就是增量式运行的。 增量式算法可以在简易欧拉筛进行改进的。<br><img src="/2018/07/26/isprimes-3/1.jpg" alt=""><br>简易欧拉筛限制它不能增量式运行的问题是在于它的空间。比如增量式运行筛选到 11 时你需要划掉 121 ，这样你就需要维持 N^2 的空间，这样就很成问题，想象如果 N 到1亿时，那空间将是不可接受的。<br><img src="/2018/07/26/isprimes-3/2.jpg" alt=""><br>我们将不再枚举p和f，而是依次检查每个数，检查到一个数时划去下一个数，并再下一个数处做标记。比如我们检查到 10 ，我们通过某种方式计算出它的下一个要被划掉的数为 15 ，我们划掉 15 并在 15 处做标记，保证检查到 15 时我们可以轻松的算出 25 。由 <a href="https://en.wikipedia.org/wiki/Bertrand%27s_postulate" target="_blank" rel="noopener">Bertrand’s postulate</a> 这个数学结论得出相邻两个质数相差不会超过两倍，所以我们只需将数组维持在当前检查的数的两倍即可。这样空间复杂度就将为了 O(N) 。 这个标记需要干什么，它需要帮助我们在拿到一个数时迅速找出它的p和f。我们用一个数组保存当前被检查的数的最小质因子在质数表的位置即可。这样比如我们在拿到 15 时，我们找到它的最小质因子p为 3 ，15/3 算出 f 为 5，我们就可以用 f 乘下一个质数去找到 25 划掉它并继续传递标记了。标记从每个偶数处（因为第一个素数为 2 ）产生的，到列末尾消失（p 最大增长到 f 的最小质因子）。 </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/DtN2WPpppf/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/DtN2WPpppf/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bengalloun</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nPrimes = <span class="number">0</span>;</span><br><span class="line">    flag[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        flag[i * <span class="number">2</span> - <span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//假设它为质数</span></span><br><span class="line">        flag[i * <span class="number">2</span>] = <span class="literal">false</span>;    <span class="comment">//偶数一定为合数</span></span><br><span class="line">        lpfindex[i * <span class="number">2</span>] = <span class="number">0</span>;    <span class="comment">//建立列首标记</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">            primes[nPrimes++] = i;  <span class="comment">//如果还没被筛掉加入质数表</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;      <span class="comment">//如果是合数</span></span><br><span class="line">            <span class="keyword">int</span> u = lpfindex[i];</span><br><span class="line">            <span class="keyword">int</span> p = primes[u];  </span><br><span class="line">            <span class="keyword">int</span> f = i / p;      <span class="comment">//计算p和f</span></span><br><span class="line">            <span class="keyword">if</span>(f % p != <span class="number">0</span>)&#123;     <span class="comment">//如果没有到列尾就传递标记</span></span><br><span class="line">                <span class="keyword">int</span> j = primes[u + <span class="number">1</span>] * f;</span><br><span class="line">                flag[j] = <span class="literal">false</span>;</span><br><span class="line">                lpfindex[j] = u + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>与思想与简易欧拉筛相同，依然为O(N)。因为要为增量式运行做准备实际要比简易欧拉筛多花一倍的时间。 </p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>flag和lpfindex数组都为O(N)的复杂度。总体空间复杂度为O(N)。</p><hr><h1 id="分段式筛法"><a href="#分段式筛法" class="headerlink" title="分段式筛法"></a>分段式筛法</h1><p>对于现代计算机运算速度越来越快，时间复杂度可能问题不大，但空间复杂度是个问题。分段式筛法就是要解决这个问题。<br>分段式筛法是在埃式筛法的基础上改进的，</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/HzTG6HrbV2/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/HzTG6HrbV2/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">segmented_eratosthenes</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sqrtN = (<span class="keyword">int</span>) <span class="built_in">sqrt</span>(N);</span><br><span class="line">    <span class="keyword">int</span> n = eratosthenes(sqrtN);</span><br><span class="line">    <span class="keyword">int</span> nPrimes = n;</span><br><span class="line"><span class="comment">// 使用埃式筛法求出前 √N 内的质数。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> L = sqrtN;<span class="comment">// 分段求，L 为每段长度，取 √N</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> start = sqrtN + <span class="number">1</span>; start &lt;= N; start += L)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start + L &gt; N) L = N - start + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="literal">true</span>, L * <span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = primes[u];</span><br><span class="line">            <span class="keyword">if</span>(p * p &gt;= start + L) <span class="keyword">break</span>; <span class="comment">// 枚举本段上限以内的质数</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = (p - start % p) % p; i &lt; L; i += p)&#123;</span><br><span class="line">                flag[i] = <span class="literal">false</span>;<span class="comment">// 划掉本段中能被 p 整除的数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]) primes[nPrimes++] = start + i; </span><br><span class="line">            <span class="comment">// 找到本段中没有被划掉的数并将其收集到质数表中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="L-的取法"><a href="#L-的取法" class="headerlink" title="L 的取法"></a>L 的取法</h2><h3 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h3><p>\(\sqrt{N}\) 以内质数表占用了 \(O(\sqrt{N})\) 的空间。<br>flag 数组占用 \(O(L)\) 的空间。<br>若 \(L &gt; \sqrt{N}\) 空间复杂度将提高。</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>若 \(L &lt; \sqrt{N}\)，当 p 接近 \(\sqrt{N}\) 时，删除 p 的倍数就容易“扑空”。</p><p>所以 \(L = \sqrt{N}\) 时刚好。</p><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>本质上是埃式筛法，所以时间复杂度为 \(O(NloglogN)\)。<br>内存占用小，避免了缓存不命中，实际上比埃式筛法要快。</p><h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>\(O(\sqrt{N})\)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;增量式筛法&quot;&gt;&lt;a href=&quot;#增量式筛法&quot; class=&quot;headerlink&quot; title=&quot;增量式筛法&quot;&gt;&lt;/a&gt;增量式筛法&lt;/h1&gt;&lt;p&gt;之前的筛法都需要事先指定一个N，然后求N以内的质数，但没办法求N以上的质数。我们想要一种算法不用事先指定N一直求下去
      
    
    </summary>
    
      <category term="算法" scheme="https://pazyx.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="质数" scheme="https://pazyx.xyz/tags/%E8%B4%A8%E6%95%B0/"/>
    
      <category term="求质数表" scheme="https://pazyx.xyz/tags/%E6%B1%82%E8%B4%A8%E6%95%B0%E8%A1%A8/"/>
    
      <category term="优化" scheme="https://pazyx.xyz/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="增量式筛法" scheme="https://pazyx.xyz/tags/%E5%A2%9E%E9%87%8F%E5%BC%8F%E7%AD%9B%E6%B3%95/"/>
    
      <category term="分段式筛法" scheme="https://pazyx.xyz/tags/%E5%88%86%E6%AE%B5%E5%BC%8F%E7%AD%9B%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>「周记」0x02 幻觉</title>
    <link href="https://pazyx.xyz/2018/07/24/weekly_2/"/>
    <id>https://pazyx.xyz/2018/07/24/weekly_2/</id>
    <published>2018-07-24T08:39:47.000Z</published>
    <updated>2018-07-24T09:03:29.847Z</updated>
    
    <content type="html"><![CDATA[<p>最近有些小凉～电脑系统出了问题，博客数据没做好备份差点丢失，早上刚刚得到消息我的大学英语二挂了～55分很是难过～好在其他都还不错，奖学金再去与我无缘～</p><p>其实我刚上大学时觉得挂科也没什么，因为我从来不是好学生，偏科也十几年了。但我不能容忍的是让一堆只会考试的人拿了钱，我觉得这对我是一种侮辱，我下学期必将拿一次一等奖学金，之后随意～</p><p>我要学英语了，我觉得这对我很重要，如果英语搞定那后面的事情真是无法想象～ 事实上我高三就这么想了，结果高考英语考了 44 分，很醉。。。</p><p>高中啊，我不学英语是有原因的，因为我觉得其他的还能提高，而且更为高效～我干掉了最难的物理，之后一路还算顺风顺水，没吃什么苦也上了学。遗憾的是现在世道不一样了，我急需英语，我需要看英文的技术书籍，我需要看ACM题，但这些不是最重要的，最重要的是我现在学英语如果成了，我将无所不能～没有什么比这个重要的了，如果成了我相信大学后面几年一定顺风顺水。。。</p><p>我现在有很大的幻觉，我感觉我只需要半年，我看了一些知乎上的经验通常时间跨度都挺长的，那些都是笨蛋我只需要半年！</p><p>后面的事情还多啊，时间太少。数学建模的好东西都没搞定，特别是写论文用的排版语言，暑假还要学。ACM还要刷很多题，暑假还要看邓老师的算法课。我还计划总结一下C++的基础问题，开学当助教不能误人子弟啊。开学还有数学建模竞赛和ACM的网络赛～再参加一下蓝桥杯。大二的课程还是有些难度的，Java虽然我之前学过但还是需要写很多代码去熟练，学Java就伴随着还要看设计模式，汇编语言虽然自己也写过，但还是好难啊。。。还有那个阴差阳错选上的单片机，真是无力吐槽，还是虽然，虽然我是写过单片机的程序，但还是好难啊。。。</p><p>最后扯个淡，最近我想拍个大电影，真的～哪天我闲了就去拍，上传到YouTube上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有些小凉～电脑系统出了问题，博客数据没做好备份差点丢失，早上刚刚得到消息我的大学英语二挂了～55分很是难过～好在其他都还不错，奖学金再去与我无缘～&lt;/p&gt;
&lt;p&gt;其实我刚上大学时觉得挂科也没什么，因为我从来不是好学生，偏科也十几年了。但我不能容忍的是让一堆只会考试的人拿
      
    
    </summary>
    
      <category term="泛 - 周记" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E5%91%A8%E8%AE%B0/"/>
    
    
      <category term="周记" scheme="https://pazyx.xyz/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="英语" scheme="https://pazyx.xyz/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="大电影" scheme="https://pazyx.xyz/tags/%E5%A4%A7%E7%94%B5%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>「书摘」深度探索 C++ 对象模型（二）</title>
    <link href="https://pazyx.xyz/2018/07/23/inside_cpp_obj_model_2/"/>
    <id>https://pazyx.xyz/2018/07/23/inside_cpp_obj_model_2/</id>
    <published>2018-07-23T05:08:42.000Z</published>
    <updated>2018-07-23T05:42:53.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数语义学"><a href="#构造函数语义学" class="headerlink" title="构造函数语义学"></a>构造函数语义学</h1><p><strong>英文术语表</strong></p><table><thead><tr><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>implicit</td><td>暗中的、隐式的（通常意指并非在程序源代码中出现的）</td></tr><tr><td>explicit</td><td>显式的（通常意指程序源代码中所出现的）</td></tr><tr><td>trivial</td><td>没用的</td></tr><tr><td>nontrivial</td><td>有用的</td></tr><tr><td>memberwise</td><td>对每个 member 施以……</td></tr><tr><td>bitwise</td><td>对每个 bit 施以……</td></tr><tr><td>semantics</td><td>语意</td></tr></tbody></table><p>关于 C++ ，最常听到的一个抱怨就是，编译器背着程序员做了太多事情。</p><p>关键词 <strong>explicit</strong> 之所以被导入这个语言，就是为了给程序员提供一种方法，使他们能够制止 “单一参数的 constructor“ 被当作一个 conversion 运算符。</p><p>“Schwarz Error” -&gt; <a href="/2018/06/29/cin-return/">basic_ios 如何穿上它的 bool</a></p><p>Conversion 运算符的引入应该是明智的，而其测试应该是严酷的，并且中程序一出现不寻常活动的第一个症候时，就发出疑问。</p><h2 id="Default-Constructor-的构造操作"><a href="#Default-Constructor-的构造操作" class="headerlink" title="Default Constructor 的构造操作"></a>Default Constructor 的构造操作</h2><p>程序的需要、编译器的需要。程序如果有需要，那是程序员的责任。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> val; Foo *pnext; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo bar;</span><br><span class="line">    <span class="keyword">if</span> ( bar.val || bar.pnext )</span><br><span class="line">    <span class="comment">// ... do something</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C++ Standard [ISO-C++95] Section 12.1 :<br>对于 class X，如果没用任何 user-declared constructor，那么会有一个 default constructor 被隐式的（ implicitly ）声明出来……一个被隐式声明出来的 default constructor 将是一个 trivial constructor……</p></blockquote><h3 id="“带有-Default-Constructor”-的-Member-Class-Object"><a href="#“带有-Default-Constructor”-的-Member-Class-Object" class="headerlink" title="“带有 Default Constructor” 的 Member Class Object"></a>“带有 Default Constructor” 的 Member Class Object</h3><p>如果一个 class 没有任何 constructor，但它内含一个 member object，而后者有 default constructor，那么这个 class 的 implicit default constructor 就是 “nontrivial” ，编译器需要为改 class 合成出一个 default constructor。<strong>不过这个合成操作只有中 constructor 真正需要被调用时才会发生。</strong></p><p>编译器如何避免合成出多个 default constructor ？<strong>把合成的 default constructor、copy constructor、destructor、assignment copy operator 都以 inline 的方式完成。</strong>如果函数太复杂，不适合做成 inline，就会合成出一个 explicit non-inline static 实例（4.5节有详细说明）</p><p>编译器会扩张已存在的 constructors，在其中安插一些代码，使得 user code 被执行之前，先调用必要的 default constructors。</p><p>C++ 语言要求以 “member objects 在 class 中的声明顺序” 来调用各个 constructors。</p><h3 id="“带有-Default-Constructor”-的-Base-Class"><a href="#“带有-Default-Constructor”-的-Base-Class" class="headerlink" title="“带有 Default Constructor” 的 Base Class"></a>“带有 Default Constructor” 的 Base Class</h3><p>如果一个没有任何 constructor 的 class 派生自一个 “带有 Default Constructor” 的 base class，那么这个 derived class 的 default constructor 会被视为 nontrivial，并因此需要被合成出来。<strong>它将调用上一层 base classes 的 default constructor（根据它们的声明顺序）。对一个后继派生的 class 而言，这个合成的 constructor 和一个 “被显式提供的 default constructor” 没有什么差异。</strong></p><h3 id="“带有-Virtual-Function”-的-Class"><a href="#“带有-Virtual-Function”-的-Class" class="headerlink" title="“带有 Virtual Function” 的 Class"></a>“带有 Virtual Function” 的 Class</h3><p>当 class 声明（或继承）一个 virtual function ，需要合成 nontrivial 的 default constructor。</p><p>“带有 Virtual Function” 的 class 的 default constructor 会有两个扩张行动在编译期间发生：</p><ul><li>一个 virtual function table（在 cfront 中被称为 vtbl ）会被编译器产生出来，内放 class 的  virtual functions 地址。</li><li>在每一个 class object 中，一个额外的 pointer member（也就是 vptr ）会被编译器合成出来，内含相关之 class vtbl 的地址。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// widget.flip() 的转变</span></span><br><span class="line">( *widget.vptr[<span class="number">1</span>] )( &amp;widget )</span><br><span class="line"><span class="comment">// *1 表示 filp() 在 virtual table 中的固定索引</span></span><br><span class="line"><span class="comment">// * &amp;widget 代表要交给“被调用的某个 flip() 函数实例”的this指针</span></span><br></pre></td></tr></table></figure><p>编译器必须为每一个 “带有 Virtual Function” 的 class 的 object 的 vptr 设定初值，放纵适当的 virual table 地址。对于这个 class 所定义的每一个 constructor，编译器会安插一些代码来做这样的事情。 </p><h3 id="“带有-Virtual-Base-Class”-的-Class"><a href="#“带有-Virtual-Base-Class”-的-Class" class="headerlink" title="“带有 Virtual Base Class” 的 Class"></a>“带有 Virtual Base Class” 的 Class</h3><p>class 派生自一个继承串链，其中有一个或更多的 virtual base classes，需要合成 nontrivial 的 default constructor。</p><p>Virtual base class 的实现法在不同的编译器之间有极大的差异。然而，每一种实现法的共同点在于必须使 virtual base class 在其每一个 derived class object 中的位置，能够于执行期准备妥当。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> i; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> pubilc virual X &#123; <span class="keyword">public</span>: <span class="keyword">int</span> j; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> pubilc virual X &#123; <span class="keyword">public</span>: <span class="keyword">double</span> d; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123; <span class="keyword">public</span>: <span class="keyword">int</span> k &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译时期决定（resolve）出 pa-&gt;X::i 的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( <span class="keyword">const</span> A* pa)</span> </span>&#123; pa-&gt;i = <span class="number">1024</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo( <span class="keyword">new</span> A );</span><br><span class="line">    foo( <span class="keyword">new</span> C );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于下面的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( <span class="keyword">const</span> A* pa)</span> </span>&#123; pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>; &#125;</span><br><span class="line"><span class="comment">// __vbcX 表示编译器产生的指针，指向 virtual base class X。</span></span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有 4 种情况，会造成“编译器必须为未声明 constructor 的 classes 合成一个 default constructor”。</p><ul><li>没有任何 constructor 的 class 内含一个有 default constructor 的 member object</li><li>没有任何 constructor 的 class 派生自一个 “带有 Default Constructor” 的 base class</li><li>当 class 声明（或继承）一个 virtual function</li><li>class 派生自一个继承串链，其中有一个或更多的 virtual base classes</li></ul><p><strong>C++ Standard 把那些合成物称为 implicit nontrivial default constructors。</strong></p><p>C++ 新手两个常见误解：</p><ol><li>任何 class 如果没有定义 default constructor，就会被合成出一个来。</li><li>编译器合成出来的 default constructor 会显式设定 “class 内每一个 data member 的默认值”。</li></ol><h2 id="Copy-Constructor-的构造操作"><a href="#Copy-Constructor-的构造操作" class="headerlink" title="Copy Constructor 的构造操作"></a>Copy Constructor 的构造操作</h2><p>有三种情况，会以一个 object 的内容作为另一个 class object 的初值。<br><code>class X { ... };</code></p><ul><li><code>X xx = x</code></li><li>作为参数交给某个函数 <code>foo( xx );</code></li><li>作为函数返回值 <code>return xx;</code></li></ul><h3 id="Default-Memberwise-Initialization"><a href="#Default-Memberwise-Initialization" class="headerlink" title="Default Memberwise Initialization"></a>Default Memberwise Initialization</h3><p>Default constructors 和 copy constructors 在<strong>必要</strong>的时候<strong>才</strong>由编译器产生出来。<br>对于 copy constructors 必要的时候是指该 class 不展现 bitwise copy semantics 时。</p><p>C++ Standard 把 copy constructors 区分为 trivial 和 nontrivial 两种。只有 nontrivial 的实例被合成于程序之中。</p><h3 id="Bitwise-Copy-Semantics（位逐次拷贝）"><a href="#Bitwise-Copy-Semantics（位逐次拷贝）" class="headerlink" title="Bitwise Copy Semantics（位逐次拷贝）"></a>Bitwise Copy Semantics（位逐次拷贝）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下声明展现了 bitwise copy semantics</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitwise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Bitwise(<span class="keyword">int</span> a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下声明未展现出 bitwise copy semantics</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBitwise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">string</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NonBitwise(v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于后者，编译器必须合成出一个 copy constructor，<strong>以便调用 member class string object 的 copy constructor</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">NonBitwise</span><span class="params">(<span class="keyword">const</span> NonBitwise&amp; nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b.<span class="built_in">string</span>::<span class="built_in">string</span>(nb.b);</span><br><span class="line">    a = nb.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="不要-Bitwise-Copy-Semantics-！"><a href="#不要-Bitwise-Copy-Semantics-！" class="headerlink" title="不要 Bitwise Copy Semantics ！"></a>不要 Bitwise Copy Semantics ！</h3><p>class 不展现出 ”bitwise copy semantics“ 的 4 种情况：</p><ul><li>当 class 内含一个 member object 而后者的 class 声明有一个 copy constructos 时（不论时被显式声明或是被合成而得）。</li><li>当 class 继承自一个 base class 而后者存在一个 copy constructor 时（不论时被显式声明或是被合成而得）。</li><li>当 class 声明了一个或多个 virtual functions 时。</li><li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时。</li></ul><h3 id="重新设定-Virtual-Table-的指针"><a href="#重新设定-Virtual-Table-的指针" class="headerlink" title="重新设定 Virtual Table 的指针"></a>重新设定 Virtual Table 的指针</h3><p>当 class 声明了一个或多个 virtual functions 时，编译期间会有两个程序扩张操作：</p><ul><li>增加一个 virtual function table( vtbl )，内含每一个有作用的 virtual function 的地址。</li><li>一个指向 virtual function table 的指针（ vptr ），安插在每一个 class object 内。</li></ul><h3 id="处理-Virtual-Base-Class-Subobject"><a href="#处理-Virtual-Base-Class-Subobject" class="headerlink" title="处理 Virtual Base Class Subobject"></a>处理 Virtual Base Class Subobject</h3><p>如果一个 class 以另一个 object 作为初值，而后者有一个 virtual base class subobject，那么也会使 “bitwise copy semantics” 失效。</p><p>每一个编译器对于虚拟继承的支持承诺，都代表必须让“derived class object 中 virtual base class subobject 位置” 在执行期就准备妥当。维护“位置的完整性”是编译器的责任。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B ba;</span><br><span class="line">B bb = ba;</span><br><span class="line"><span class="comment">// 这种情况使用 bitwise 就够了</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C ca;</span><br><span class="line">B bb = ca;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译器需要合成一个 copy constructor，安插一些代码以设定 virtual base class pointer/offser 的初值（或只是简单地确定它没有被抹消），对每一个 memberwise 执行必要的初始化操作，以及执行其他的内存相关工作。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="程序转化语意学（Program-Transformation-Semantics）"><a href="#程序转化语意学（Program-Transformation-Semantics）" class="headerlink" title="程序转化语意学（Program Transformation Semantics）"></a>程序转化语意学（Program Transformation Semantics）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"X.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个假设：</p><ul><li>每次 <code>foo()</code> 被调用，就传回 <code>xx</code> 的值。</li><li>如果 <code>class X</code> 定义了一个 copy constructor，那么当 <code>foo()</code> 被调用时，保证该 copy constructor 也会被调用。</li></ul><ul><li>第一个假设的真实性，必须视 <code>class X</code> 如何定义而定。</li><li>第二个假设的真实性，虽然也部分地必须视 <code>class X</code> 如何定义而定，但最主要的还是视你的 C++ 编译器所提供的进取性优化层级（degree of aggressive optimization）而定。</li></ul><h3 id="显式的初始化操作（Explicit-Initialization）"><a href="#显式的初始化操作（Explicit-Initialization）" class="headerlink" title="显式的初始化操作（Explicit Initialization）"></a>显式的初始化操作（Explicit Initialization）</h3><p>在严谨的 C++ 用词中，“定义” 是指 “占用内存” 的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">x1</span><span class="params">( x0 )</span></span>;</span><br><span class="line">X x2 = x0;</span><br><span class="line">X x3 = X( x0 );</span><br></pre></td></tr></table></figure><p>转化为 -&gt; </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X x1;</span><br><span class="line">X x2;</span><br><span class="line">X x3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器安插 X copy construction 的调用操作</span></span><br><span class="line">X1.X::X( x0 );</span><br><span class="line">X2.X::X( x0 );</span><br><span class="line">X3.X::X( x0 );</span><br></pre></td></tr></table></figure><h3 id="参数的初始化（Argument-Initialization）"><a href="#参数的初始化（Argument-Initialization）" class="headerlink" title="参数的初始化（Argument Initialization）"></a>参数的初始化（Argument Initialization）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( X x0 )</span></span>;</span><br><span class="line"></span><br><span class="line">X xx;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">foo( xx );</span><br></pre></td></tr></table></figure><p><strong>第一种编译器实现的转化代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X __temp0;</span><br><span class="line"></span><br><span class="line">__temp0.X::X( xx );</span><br><span class="line">foo( __temp0 );</span><br></pre></td></tr></table></figure></p><p>要求局部实例（local instance）x0 以 memberwise 的方式将 xx 当做初值。导入临时性 object，并调用 copy constructor 将它初始化，然后将此临时性 object 交给函数。但这里 <code>foo()</code> 函数声明将改变为 <code>void foo( X&amp; x0 )</code>。在函数执行完成后 <code>class X</code> 的 destrucor 将会被调用，对付那个临时性的 object 。</p><p><strong>第二种编译器实现</strong><br>以 “拷贝建构”（copy construct）的方式把实际参数直接建构在其应该的位置上。</p><h3 id="返回值的初始化（Return-Value-Initialization）"><a href="#返回值的初始化（Return-Value-Initialization）" class="headerlink" title="返回值的初始化（Return Value Initialization）"></a>返回值的初始化（Return Value Initialization）</h3><h4 id="cfront-中的双阶段转化"><a href="#cfront-中的双阶段转化" class="headerlink" title="cfront 中的双阶段转化"></a>cfront 中的双阶段转化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X xx;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">( X&amp; __result )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    </span><br><span class="line">    xx.X::X();</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    __result.X::X(xx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>X xx = bar();</code> 的操作将被转化为 <code>X xx; bar( xx );</code>。</p><p><code>bar().memfunc();</code> 可能被转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X __temp0;</span><br><span class="line">( bar( __temp0 ), __temp0 ).memfunc();</span><br></pre></td></tr></table></figure></p><h3 id="在使用者层面做优化（Optimization-at-the-User-Level）"><a href="#在使用者层面做优化（Optimization-at-the-User-Level）" class="headerlink" title="在使用者层面做优化（Optimization at the User Level）"></a>在使用者层面做优化（Optimization at the User Level）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">( <span class="keyword">const</span> T &amp;y, <span class="keyword">const</span> T &amp;z )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bar()</code> 函数会要求 <code>xx</code> 被 “memberwise” 地拷贝到编译器所产生的 <code>__result</code> 之中。<br><em>Jonathan Shopiro</em> 提出定义另一个 constructor，可以直接计算 <code>xx</code> 的值。<br>上面的代码转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">( <span class="keyword">const</span> T &amp;y, <span class="keyword">const</span> T &amp;z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> X( y,z );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器会将其转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">( X &amp;__result, <span class="keyword">const</span> T &amp;y, <span class="keyword">const</span> T &amp;z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__result.X::X( y,z );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>__result</code> 被直接计算出来，而不是经由 copy constructor 拷贝而得！</p><h3 id="在编译器层面做优化（Optimization-at-the-Compiler-Level）"><a href="#在编译器层面做优化（Optimization-at-the-Compiler-Level）" class="headerlink" title="在编译器层面做优化（Optimization at the Compiler Level）"></a>在编译器层面做优化（Optimization at the Compiler Level）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X xx;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">( X&amp; __result )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __result.X::X();</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种优化，有时候被称为 Named Return Value ( NRV ) 优化。NRV 优化如今被视为标准 C++ 编译器的一个义不容辞的优化操作。</p><p>// 本书对 NRV 的优化性能测试有一些错误，这部分不做摘录。</p><p>NRV 优化的争议：</p><ul><li>优化由编译器完成，而它是否真的被完成，并不是十分清楚。</li><li>一旦函数变得比较复杂，优化也会变得比较难以实施。</li><li>程序员不能够安全地规划自己的 copy constructor 的副作用。</li></ul><p>一般而言，面对 “以一个 class object 作为另一个 class object 的初值” 的情形，语言允许编译器有大量的自由发挥空间。</p><h3 id="Copy-Constructor：要还是不要？"><a href="#Copy-Constructor：要还是不要？" class="headerlink" title="Copy Constructor：要还是不要？"></a>Copy Constructor：要还是不要？</h3><p>class 的 default copy constructor 被视为 trivial 的情况下不声明 explicit copy constructor 既快速又安全。在需要 NRV 优化时，可以考虑实现 copy constructor，可以使用 <code>memcpy()</code> 来拷贝提高效率。</p><p>不管使用 <code>memcpy()</code> 还是 <code>memset()</code>，都只有在“classes 不含任何由编译器产生的那部 members ” 时才能有效运行。</p><h2 id="成员们的初始化队伍（Member-Initialization-List）"><a href="#成员们的初始化队伍（Member-Initialization-List）" class="headerlink" title="成员们的初始化队伍（Member Initialization List）"></a>成员们的初始化队伍（Member Initialization List）</h2><p>必须使用 member initialization list 的情况</p><ul><li>当初始化一个 reference member 时；</li><li>当初始化一个 const member 时；</li><li>当调用一个 base class 的 constructor，而它拥有一组参数时；</li><li>当调用一个 member class 的 constructor，而它拥有一组参数时。</li></ul><p>编译器会一一操作 initialization list，以适当顺序中 constructor 之内安插初始化操作，并且<strong>在任何 explicit user code 之前</strong>。</p><p>在 initialization list 中使用 member function 使用是合法的，这是因为和此 object 相关的 this 指针已经被建构妥当。</p><p>如果在 initialization list 中调用 derived class member function ，其返回值被当做 base class constructor 的一个参数。那不一定是个好主意，因为 derived class member function 可能要用到的 derived class member 在 base class 的 constructor 之后才被初始化。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/autosar/archive/2011/10/09/2204181.html" target="_blank" rel="noopener">关于NRV优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造函数语义学&quot;&gt;&lt;a href=&quot;#构造函数语义学&quot; class=&quot;headerlink&quot; title=&quot;构造函数语义学&quot;&gt;&lt;/a&gt;构造函数语义学&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;英文术语表&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;t
      
    
    </summary>
    
      <category term="泛 - 书摘" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E4%B9%A6%E6%91%98/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="构造函数" scheme="https://pazyx.xyz/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="编译器优化" scheme="https://pazyx.xyz/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/"/>
    
      <category term="拷贝构造函数" scheme="https://pazyx.xyz/tags/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="缺省构造函数" scheme="https://pazyx.xyz/tags/%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="Virtual Class" scheme="https://pazyx.xyz/tags/Virtual-Class/"/>
    
      <category term="Virtual Base Class" scheme="https://pazyx.xyz/tags/Virtual-Base-Class/"/>
    
      <category term="NRV优化" scheme="https://pazyx.xyz/tags/NRV%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>macOS 灾难</title>
    <link href="https://pazyx.xyz/2018/07/21/mac_os_disaster/"/>
    <id>https://pazyx.xyz/2018/07/21/mac_os_disaster/</id>
    <published>2018-07-21T10:52:18.000Z</published>
    <updated>2018-07-21T14:19:51.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="macOS-10-14-beta3"><a href="#macOS-10-14-beta3" class="headerlink" title=" macOS 10.14 beta3 "></a><center> macOS 10.14 beta3 </center></h1><h4 id="灾难性的数据丢失事故，博客数据险些全部丢失！"><a href="#灾难性的数据丢失事故，博客数据险些全部丢失！" class="headerlink" title=" 灾难性的数据丢失事故，博客数据险些全部丢失！ "></a><center> 灾难性的数据丢失事故，博客数据险些全部丢失！ </center></h4><h4 id="2018-7-21-凌晨"><a href="#2018-7-21-凌晨" class="headerlink" title=" 2018.7.21 凌晨 "></a><center> 2018.7.21 凌晨 </center></h4><p><img src="/2018/07/21/mac_os_disaster/disaster.png" alt=""></p><p>博客数据在废纸篓里找到了，历劫度人。。。<br>调整一下<strong>继续～</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;macOS-10-14-beta3&quot;&gt;&lt;a href=&quot;#macOS-10-14-beta3&quot; class=&quot;headerlink&quot; title=&quot; macOS 10.14 beta3 &quot;&gt;&lt;/a&gt;&lt;center&gt; macOS 10.14 beta3 &lt;/cent
      
    
    </summary>
    
      <category term="泛 - 纪念" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E7%BA%AA%E5%BF%B5/"/>
    
    
      <category term="灾难" scheme="https://pazyx.xyz/tags/%E7%81%BE%E9%9A%BE/"/>
    
      <category term="MacOS" scheme="https://pazyx.xyz/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 指南</title>
    <link href="https://pazyx.xyz/2018/07/15/markdown_guide/"/>
    <id>https://pazyx.xyz/2018/07/15/markdown_guide/</id>
    <published>2018-07-14T16:53:18.000Z</published>
    <updated>2018-07-21T12:03:16.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-是什么？"><a href="#Markdown-是什么？" class="headerlink" title="Markdown 是什么？"></a>Markdown 是什么？</h1><blockquote><p><strong>Markdown</strong> 是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML ）文档”。</p></blockquote><p><strong>注意！</strong>Markdown是标记语言，而不是样式表。<strong>它只是在标注说明文本中每一块是什么。</strong>比如标题、引用、代码。最终它显示的是什么样子的取决于你浏览它的工具，如果转成 HTML 那就由浏览器决定，你想改变它的样式就需要添加 CSS（层叠样式表）。</p><h1 id="我为什么学-Markdown？"><a href="#我为什么学-Markdown？" class="headerlink" title="我为什么学 Markdown？"></a>我为什么学 Markdown？</h1><p>主要是博客写作需要用到，用 Markdown 写作最大的好处是自由，你的文本是独立的。如果你使用WordPress 自带的编辑器写作，它的可移植性是很低的，导出 XML 文件后转换成其他格式后很多地方都需要手动调整。还有就是项目中 Readme 文件一般用 Markdown 写，你写作时不需要任何鼠标操作。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h2 id="文本基础样式"><a href="#文本基础样式" class="headerlink" title="文本基础样式"></a>文本基础样式</h2><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**加粗**</span></span><br></pre></td></tr></table></figure><p><strong>效果：**</strong>加粗**</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**斜体**</span></span><br></pre></td></tr></table></figure><p><strong>效果：*</strong>斜体*</p><h3 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">***斜体加粗**</span>*</span><br></pre></td></tr></table></figure><p><strong>效果：***</strong>斜体加粗***</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除~~</span><br></pre></td></tr></table></figure><p><strong>效果：</strong><del>删除</del></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 引用的内容</span></span><br><span class="line">&gt;&gt; 引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 引用的内容</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><blockquote><p>引用的内容</p><blockquote><p>引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>可以多级嵌套引用</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="strong">*****</span></span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><hr><hr><hr><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">超链接名</span>](<span class="link">超链接地址 "超链接title"</span>)</span><br><span class="line">title可缺省</span><br><span class="line"><span class="strong">**效果：**</span></span><br><span class="line">[<span class="string">Home</span>](<span class="link">https//pazyx.xyz "pazyx"</span>)</span><br></pre></td></tr></table></figure><p><strong>效果：</strong><br><a href="https//pazyx.xyz" title="pazyx">Home</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片alt</span>](<span class="link">图片地址 ''图片title''</span>)</span><br><span class="line">title可缺省</span><br><span class="line"><span class="strong">**效果：**</span></span><br><span class="line">![<span class="string">logo</span>](<span class="link">/markdown_basic/logo.png ''blogLogo''</span>)</span><br></pre></td></tr></table></figure><p><strong>效果：</strong><br><img src="/2018/07/15/markdown_guide/markdown_basic/logo.png" alt="logo" title="&#39;blogLogo&#39;"><br>图片地址可以是相对地址也可以是超链接</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>列表内容</span><br><span class="line"><span class="bullet">+ </span>列表内容</span><br><span class="line"><span class="bullet">* </span>列表内容</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p>1.列表内容<br>2.列表内容<br>3.列表内容</p><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>一级列表内容</span><br><span class="line">  - 二级列表内容</span><br><span class="line"><span class="code">    - 三级列表内容</span></span><br><span class="line"><span class="code">      - 四级列表内容</span></span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><ul><li>一级列表内容<ul><li>二级列表内容<ul><li>三级列表内容<ul><li>四级列表内容</li></ul></li></ul></li></ul></li></ul><p>两级之间差两个空格即可</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|表头|表头|表头|</span><br><span class="line">| - | :-: | :- |</span><br><span class="line">|内容|内容|内容|</span><br><span class="line">|内容|内容|内容|</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><table><thead><tr><th>表头</th><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>内容</td><td>内容</td><td>内容</td></tr><tr><td>内容</td><td>内容</td><td>内容</td></tr></tbody></table><p>默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行内 `code` 行内</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p>行内 <code>code</code> 行内</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`cpp</span><br><span class="line"><span class="section">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    std::cout &lt;&lt; "Hello World." &lt;&lt; endl;</span></span><br><span class="line"><span class="code">    return 0;</span></span><br><span class="line">&#125;</span><br><span class="line">\<span class="code">`\`</span>\`</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">markdown基本语法</a></li><li><a href="https://www.jianshu.com/p/2df05f279331" target="_blank" rel="noopener">Markdown插入表格语法</a></li><li><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown维基百科</a></li><li><a href="http://www.markdown.cn" target="_blank" rel="noopener">Markdown中文官网</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown-是什么？&quot;&gt;&lt;a href=&quot;#Markdown-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Markdown 是什么？&quot;&gt;&lt;/a&gt;Markdown 是什么？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Markd
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Markdown" scheme="https://pazyx.xyz/tags/Markdown/"/>
    
      <category term="标记语言" scheme="https://pazyx.xyz/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"/>
    
      <category term="写作工具" scheme="https://pazyx.xyz/tags/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>数学建模——动态规划</title>
    <link href="https://pazyx.xyz/2018/07/14/mathematical_modeling_dp/"/>
    <id>https://pazyx.xyz/2018/07/14/mathematical_modeling_dp/</id>
    <published>2018-07-14T10:13:18.000Z</published>
    <updated>2018-07-26T11:16:41.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前在学算法时接触过不少动态规划的题目，但最近实践周在上数学建模的课，发现自己在动态规划算法上欠缺很多。步骤不规范、思路不清晰、数学推导欠缺，大多数时候我都是靠直觉推状态转移方程的。这篇我希望从数学建模的角度重新总结一下动态规划（算法中的动态规划也会继续更新，最近将更新状压DP）。<br>算法竞赛和数学建模竞赛中动态规划，在数据和方程的表示上有很大不同。<br>算法竞赛中一般以数组单元的形式表示一个状态并用其推导状态转移方程，并且不对指标函数与最优值函数的单独推导。其形式更接近伪代码，方便将模型快速转换为代码。<br>数学建模竞赛中步骤相当严谨很多，各个方程相互独立，各个方程也更注重数学的严谨性。</p><hr><h1 id="标准步骤"><a href="#标准步骤" class="headerlink" title="标准步骤"></a>标准步骤</h1><ul><li>阶段</li><li>状态变量（无后效性） \(s_k\)</li><li>决策变量  \(x_k\)</li><li>状态转移方程  \(s_{k+1} = T_k(s_k,x_k)\)</li><li>指标函数  \(V_{k,n} = V_{k,n}(s_k,x_k,s_{k+1},…,s_{n+1},k = 1,2,…,n\)</li><li>最优值函数  \[f_k(s_k) = \max_{\{x_k,…,x_n\}} V_{k,n}\]</li><li>边界条件</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>一个简单的完全背包问题，其算法我在<a href="/2018/03/01/cp-bp/">动态规划B2——完全背包</a>给出。</p><p>有一个容量为 V 的背包和 N 种物品。每种物品的价值为 \(W_k\) 体积为 \(C_k\) ，每种物品有无限件，问最大背包价值。</p><h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><p>N 种物品按编号排序，视为 N 个阶段。</p><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>\(s_k\) 第 k 阶段初可装载的质量</p><h3 id="决策变量"><a href="#决策变量" class="headerlink" title="决策变量"></a>决策变量</h3><p>装入第k种物品的数量：\(x_i\)</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>\[s_{k+1} = s_k - C_kx_k\] </p><h3 id="指标函数"><a href="#指标函数" class="headerlink" title="指标函数"></a>指标函数</h3><p>装入的第 k 种物品到第 N 种物品总价值：\(v_k\) </p><h3 id="最优值函数"><a href="#最优值函数" class="headerlink" title="最优值函数"></a>最优值函数</h3><p>\[f_k(s_k) = \max_{0≤x_k≤[s_k/a_k]} \{C_kx_k + f_k(s_{k+1})\ \ (k = 1…n)\]</p><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul><li>\(s_1 = V\)</li><li>\(f_{n+1}(s_{n+1}) = 0\)</li></ul><h3 id="与算法竞赛中的动态规划对比"><a href="#与算法竞赛中的动态规划对比" class="headerlink" title="与算法竞赛中的动态规划对比"></a>与算法竞赛中的动态规划对比</h3><ul><li>算法竞赛<br>\[F[i, v] = max \{ F[i − 1, v − kC_i] + kW_i \ \  0 ≤ kC_i ≤ v \} \]</li><li>数学建模竞赛<br>$$<br>\begin{cases}<br>f_k(s_k) = \max_{0≤x_k≤[s_k/a_k]} \{C_kx_k + f_k(s_{k+1})\} &amp;\text{(k = 1…n)} \\<br>f_{n+1}(s_{n+1}) = 0<br>\end{cases}<br>$$</li></ul><hr><h1 id="连续型动态规划"><a href="#连续型动态规划" class="headerlink" title="连续型动态规划"></a>连续型动态规划</h1><p>在大多数算法竞赛的题目中，决策点都是离散的。而在数学建模竞赛中可能出现连续型的动态规划问题，这种题目写出具体算法相当困难，多大需要笔算。</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>100 台某种机器可在高低两种不同的负荷下进行生产，设机器在高负荷下生产的产量函数为 g = 9x ，其中 x 为投入生产的机器数量，季度完好率为 a = 0.65 。在低负荷下生产的产量函数为 h = 4y ，其中 y 为投入生产的机器数量,季度完好率为 b = 0.95 。</p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><ul><li>把4个季度看成是4个阶段，用k表示。</li><li>状态变量\(s_k\)：表示第k季度初拥有的完好机器数量。(\(s_1\) = 100)</li><li>决策变量\(x_k\)：表示第k季度分配高负荷下生产的机器数量，于是\(s_k-x_k\)为该季度分配在低负荷下生产的机器数量。\(s_k\),\(x_k\)为连续变量，其小数部分表示一台机器正常工作时间所占的比例。允许决策集合:\(D_k(s_k) = \{ x_k \ \ |\ \ 0≤x_k≤s_k \}\)</li><li>状态转移方程：\[s_{k+1} = ax_k + b( s_k - x_k ) = 0.65x_k + (s_k - x_k ) \ \ (k = 1,2,3,4) \]</li><li>指标函数：\(v_k\) 表示第 k 季度的产量 \(v_k = 9x_k + 4(s_k+x_k)\)</li><li>最优值函数：<br>$$<br>\begin{cases}<br>f_k(s_k) = \max_{0≤x_k≤s_k} \{ v_k + f_{k+1}(s_{k+1}) \} = \max_{0≤x_k≤s_k} \{ 9x_k + 4(s_k-x_k) + f_{k+1}(s_{k+1}) \}\\<br>f_5(s_5) = 0<br>\end{cases}<br>$$</li></ul><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><p><strong>当 k = 4 时</strong></p><p>$$<br>\begin{align}<br>f_4(s_4)&amp; = \max_{0≤x_4≤s_4} \{ 9x_4 + 4(s_4-x_4) + f_5(s_5) \} \\<br>&amp; = \max_{0≤x_4≤s_4} \{ 9x_4 + 4(s_4-x_4) \} \\<br>&amp; = \max_{0≤x_4≤s_4} \{ 5x_4 + 4s_4 \}<br>\end{align}<br>$$<br>\[x^*_4 = s_4 ,f_4(s_4) = 9s_4\]</p><p><strong>当 k = 3 时</strong></p><p>$$<br>\begin{align}<br>f_3(s_3)&amp; = \max_{0≤x_3≤s_3} \{ 9x_3 + 4(s_3-x_3) + f_4(s_4) \} \\<br>&amp; = \max_{0≤x_3≤s_3} \{ 9x_3 + 4(s_3-x_3)+9[0.65x_3+0.95(s_3-x_3)] \} \\<br>&amp; = \max_{0≤x_3≤s_3} \{ 2.3x_3 + 12.55s_3 \}<br>\end{align}<br>$$<br>\[x^*_3 = s_3 ,f_3(s_3) = 14.85s_3\]</p><p><strong>当 k = 2 时</strong></p><p>$$<br>\begin{align}<br>f_2(s_2)&amp; = \max_{0≤x_2≤s_2} \{ 9x_2 + 4(s_2-x_2) + f_3(s_3) \} \\<br>&amp; = \max_{0≤x_2≤s_2} \{ 9x_2 + 4(s_2-x_2)+14.85[0.65x_2+0.95(s_2-x_2)] \} \\<br>&amp; = \max_{0≤x_2≤s_2} \{ 0.545x_2 + 18.1075s_3 \}<br>\end{align}<br>$$<br>\[x^*_2 = s_2 ,f_2(s_2) = 18.6525s_2\]</p><p><strong>当 k = 1 时</strong></p><p>$$<br>\begin{align}<br>f_1(s_1)&amp; = \max_{0≤x_1≤s_1} \{ 9x_1 + 4(s_1-x_1) + f_2(s_2) \} \\<br>&amp; = \max_{0≤x_1≤s_1} \{ 9x_1 + 4(s_1-x_1)+18.6525[0.65x_1+0.95(s_1-x_1)] \} \\<br>&amp; = \max_{0≤x_1≤s_1} \{ -0.596x_1 + 21.72s_1 \}<br>\end{align}<br>$$</p><p>\[ x^*_1 = 0 , s_1 = 100 , y^*_1 = s_1 - x^*_1 = 100 , f_1(s_1) = 21.72s_1 = 2172 \]</p><p><strong>反推</strong></p><p>$$<br>\begin{cases}<br>s_2 &amp; = 0.65x_1 + 0.95(s_1 - x_1) = 95; x_2^* = s_2 = 95,y_2^* = 0 \\<br>s_3 &amp; = 0.65x_2 + 0.95(s_2 - x_2) = 61.75,取整得61,x_3^* = s_3 = 61,y_3^* = 0 \\<br>s_4 &amp; = 0.65x_3 + 0.95(s_3 - x_3) = 39.65,取整得39,x_4^* = s_4 = 39,y_4^* = 0<br>\end{cases}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;之前在学算法时接触过不少动态规划的题目，但最近实践周在上数学建模的课，发现自己在动态规划算法上欠缺很多。步骤不规范、思路不清晰、数学推导欠缺
      
    
    </summary>
    
      <category term="数学" scheme="https://pazyx.xyz/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="动态规划" scheme="https://pazyx.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="完全背包" scheme="https://pazyx.xyz/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    
      <category term="数学建模" scheme="https://pazyx.xyz/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="连续型动态规划" scheme="https://pazyx.xyz/tags/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3254 Corn Fields（状压DP）</title>
    <link href="https://pazyx.xyz/2018/07/07/poj-3254-corn-fields/"/>
    <id>https://pazyx.xyz/2018/07/07/poj-3254-corn-fields/</id>
    <published>2018-07-06T19:22:10.000Z</published>
    <updated>2018-07-13T13:55:29.480Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：<a href="http://poj.org/problem?id=3254" target="_blank" rel="noopener">http://poj.org/problem?id=3254</a> </strong></p><h1 id="Corn-Fields"><a href="#Corn-Fields" class="headerlink" title="Corn Fields"></a>Corn Fields</h1><p><strong>Time Limit:</strong> 2000MS     <strong>Memory Limit:</strong> 65536K</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Farmer John has purchased a lush new rectangular pasture composed of <em>M</em> by <em>N</em> (1 ≤ <em>M</em> ≤ 12; 1 ≤ <em>N</em> ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant.</p><p>Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Line 1: Two space-separated integers: <em>M</em> and <em>N</em><br>Lines 2..<em>M</em>+1: Line <em>i</em>+1 describes row <em>i</em> of the pasture with <em>N</em> space-separated integers indicating whether a square is fertile (1 for fertile, 0 for infertile)</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Line 1: One integer: the number of ways that FJ can choose the squares modulo 100,000,000.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 1 1</span><br><span class="line">0 1 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>Number the squares as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">  4</span><br></pre></td></tr></table></figure><p>There are four ways to plant only on one squares (1, 2, 3, or 4), three ways to plant on two squares (13, 14, or 34), 1 way to plant on three squares (134), and one way to plant on no squares. 4+3+1+1=9.</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 M×N 的玉米地，但其中有些是不肥沃的，不能种植。用 1 来代表肥沃，0 代表不肥沃。另外奶牛不喜欢挨着吃玉米，也就是说要间隔着种植，求有几种种植方式，并将计算结果对 100000000 取模。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>状压DP入门题目。题目中要求不能挨着种，也就是行内不允许有相邻的地，行内比较好控制，而行间思考一下其实只需要考虑相邻两行的玉米地是否有冲突。<br>使用一个二进制数表示一行的玉米种植情况<br>状态：某行的玉米地分布情况</p><p>转移方程：<code>dp[i][j] = (dp[i][j] + dp[i - 1][k])%mod</code><br>第 i 行种植方案为 j 的种植方式数为等于其本身加上第 i-1 行种植方案为 k 的种植方式数，j 和 k 方案不冲突，且 j 和 k 方案本身行内不冲突，且种植土地都为肥沃的土地。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> state[MAX_N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">1</span>][<span class="number">1</span> &lt;&lt; MAX_M];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fit</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (now | flag) == flag;</span><br><span class="line">&#125;<span class="comment">//是否都是肥沃的土地</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; (x / <span class="number">2</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断行内是否冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_intersect</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (now &amp; prev) == <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断两行间是否冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> flag;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; flag;</span><br><span class="line">            state[i] |= (<span class="number">1</span> &lt;&lt; j) * flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ok(i))</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; m); ++j)&#123;<span class="comment">//枚举当前行</span></span><br><span class="line">            <span class="keyword">if</span>(!ok(j) || !fit(j,state[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; m); ++k)&#123;<span class="comment">//枚举下一行</span></span><br><span class="line">                <span class="keyword">if</span>(ok(k) &amp;&amp; fit(k,state[i<span class="number">-1</span>]) &amp;&amp; not_intersect(j,k))&#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][k]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); ++i)&#123;</span><br><span class="line">        ans = (ans + dp[n][i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目链接：&lt;a href=&quot;http://poj.org/problem?id=3254&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://poj.org/problem?id=3254&lt;/a&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
      <category term="题解" scheme="https://pazyx.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="https://pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://pazyx.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="题解" scheme="https://pazyx.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="POJ" scheme="https://pazyx.xyz/tags/POJ/"/>
    
      <category term="状压DP" scheme="https://pazyx.xyz/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>「周记」0x01 可乐</title>
    <link href="https://pazyx.xyz/2018/07/04/weekly_1/"/>
    <id>https://pazyx.xyz/2018/07/04/weekly_1/</id>
    <published>2018-07-04T13:39:47.000Z</published>
    <updated>2018-07-24T09:03:36.503Z</updated>
    
    <content type="html"><![CDATA[<p>考试周终于过去 我想写点什么 想写点自由的东西 因为考试周实在太过压抑 我已经一个月没去厦门放纵了 身体和心理都受到了折磨<br>在为数不多的几门需要大量写字的考试中 我多次提到自由和可乐 因为我渴望自由 我想在一堆答案里写点心里话自由一下<br>事实上我今天想写一写 <strong>可乐</strong> 我本想写的正经一点 因为我要发到我的博客上 一直以来我希望我的博客能够严谨认真 写完一篇检查多次 有什么错误马上打开电脑修改提交<br>今天我觉得既然要谈自由 我就自由一点吧 我也不想写什么标点符号 随便写写 反正这是我的博客 我来决定它的风格 我也不分段落和什么乱七八糟的 markdown 语法了 就按我想的来吧 其中可能有错别字（我已经看到了）我也不想改了 一切都波普</p><p>说到可乐 我已经在很多地方写过很多篇了 我想在这里总结一下 别回来都没了</p><ul><li><p>2017年8月28日 23:23</p><blockquote><p>去楼下超市买罐装可乐 发现罐装的雪碧和芬达都在唯独少了我的可乐 我很难过 之后我在罐装的雪碧芬达面前犹豫了一会儿 又看了看瓶装的可乐 我感觉那些都不是我想要的 你们知道我是个贵族非常讲究 瓶装和罐装的可乐完全是两个味儿 我走出那个超市决定去远方那个超市闯荡一次 之后我探访了两家超市结果它们只有瓶装的 最后我鼓足勇气走进了一家火锅店 问老板有罐装的可乐吗 他犹豫了一下说只有…… 说到这儿我心凉了 心想肯定是只有瓶装的 交谈间老板带着我走到了冰柜前 老板愣了一下说只有绿茶 他估计是在想怎么瓶装的可乐也没了 突然 我看到了冰柜上层的北冰洋 我想去他妈的罐装可乐 真够麻烦的 给我来瓶北冰洋 我喝着我的北冰洋走上了回家的路 感觉味道还可以 只是我感觉今天我有点儿不讲究了 所以说今天我这个贵族落魄了 我们等待明天 明天我带你们看看我的罐装可乐 带你们体验那种自由的味道     </p></blockquote></li><li><p>2017年10月24日 11:25</p><blockquote><p>自由的阳光 自由的可乐 军训让我体验了自由 唯一的遗憾就是为什么中区食堂的党员示范岗窗口的菜最好吃 我想如果我再多吃几天 也许我也能发现它不如人意的一面</p></blockquote></li><li><p>2018年3月16日 知乎问题：为什么有人愿意买 2.5 元 330ml 的易拉罐汽水，而不买 3 元 500ml 的瓶装？回答</p><blockquote><p>太巧了？我就是你说的那种买罐装可乐的人，而且我只买罐装的，更夸张的是我们学校罐装和瓶装都是3块。每次我买瓶装可乐都会剩一半以上后扔掉。<br>我想说啊，罐装的和瓶装的可乐它完全是两个味道。罐装的一般你需要一次喝完，汽很足。而瓶装的，打开放半个小时那口感是完全不能被接受的，只能扔掉。<br>对于我每天在食堂吃饭的情况来说，一罐罐装的可乐刚刚好，而瓶装的500ml显得略多，我还需要把它带回宿舍并且不能马上扔掉，因为那显得我很浪费。那样我就需要把它放上一段时间（一般是几个小时）得到一个足以安慰我内心的理由（它真的没汽了）再把它扔掉。我这个人很懒，不想那么麻烦。<br>还有就是在我喝完罐装可乐并扔掉罐的时候，我会有一种奇妙的感觉，就是我感觉到了自由。因为它不像瓶装可乐每次剩下的那些给我一种束缚感，我不需要为它找一个理由再扔掉。要知道自由在我们这个社会是很稀缺的，我很享受这种感觉，我很需要罐装可乐。<br>注意！我之前说的瓶装都是指塑料瓶装的，玻璃瓶装的那真是好味道，我可以保证它比塑料瓶装的和罐装的都更好喝并且更能让你感觉到那种自由的状态。</p></blockquote></li><li><p>2018年6月27日</p><blockquote><p>我想这可乐可能也没多自由 我一想象到可口可乐中国公司里的党支部开会的场面就浑身难受 这可乐代表不了自由 考完试我一定去买一瓶进口可乐感受一下自由 此刻请让我在外面溜达一会儿 让我吹一吹太平洋的风 今晚就是我的波普时间</p></blockquote></li></ul><p>要说我最喜欢这其中的哪篇 我觉得是第一篇 那篇写的很自由 很有现场感 也很有Andy Warhol的风格 而且它象征着我会写故事了<br>好了 言归正传 可乐为什么能代表自由？ 我也纳闷 我仔细回忆了一下应该是<strong>我瞎编的吧</strong> 高中我看了一些Andy Warhol的书<br>他说啊</p><blockquote><p>What’s great about this country is America started the tradition where the richest consumers buy essentially the same things as the poorest. You can be watching TV and see Coca-Cola, and you can know that the President drinks Coke, Liz Taylor drinks Coke, and just think, you can drink Coke, too. A Coke is a Coke and no amount of money can get you a better Coke than the one the bum on the corner is drinking. All the Cokes are the same and all the Cokes are good.<br>翻译：这个国家的伟大之处在于，美国开始了这样的传统:最富有的消费者买的东西基本上和最穷的人买的一样。你可以看电视，看可口可乐，你可以知道总统喝可乐，莉兹·泰勒喝可乐，想想，你也可以喝可乐。可口可乐就是可乐，再多的钱也买不到比街角的流浪汉喝的更好的可乐。所有的可乐都是一样的，所有的可乐都一样好。</p></blockquote><p><strong>现实 表面 瞬间 感性 快乐 平等 简单 机械 重复 大众</strong> 这是波普精神 可乐全占了 但就是没有自由 我也不知道 这个精神是谁想的 要是我就给它加上自由<br>写到这儿我大概明白了 可乐代表自由也许是因为快乐 我在自由的时刻最快乐 而且喝可乐也许这世上最简单的自由方式了 电影 肖申克的救赎 里他们在监狱房顶喝着啤酒 感受到了难得的自由<br>我想我喝可乐的时候跟他们一样 我感觉这个社会管得实在是太多了 各种网络社交媒体不能评论 不能发不能发的 各种好的网站都需要翻墙 媒体都在宣传正能量 说点其他都不行 我讨厌政治 但现在哪都是政治 可能我写了这一段我的网站就被封禁了 而且它们是合法的 因为我没备案 反正啊 我是托管在国外服务器上的 域名也是在国外买的也没备案 我也有了自己的梯子 封了我也可以自己写自己看<br>我还是希望人民们意识到自己的自由在一点一点被剥夺 实际上我们也无力反抗 如果不能像安迪一样逃出肖申克的话 还是与我一起共饮可乐吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考试周终于过去 我想写点什么 想写点自由的东西 因为考试周实在太过压抑 我已经一个月没去厦门放纵了 身体和心理都受到了折磨&lt;br&gt;在为数不多的几门需要大量写字的考试中 我多次提到自由和可乐 因为我渴望自由 我想在一堆答案里写点心里话自由一下&lt;br&gt;事实上我今天想写一写 &lt;s
      
    
    </summary>
    
      <category term="泛 - 周记" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E5%91%A8%E8%AE%B0/"/>
    
    
      <category term="周记" scheme="https://pazyx.xyz/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="可乐" scheme="https://pazyx.xyz/tags/%E5%8F%AF%E4%B9%90/"/>
    
      <category term="自由" scheme="https://pazyx.xyz/tags/%E8%87%AA%E7%94%B1/"/>
    
      <category term="波普" scheme="https://pazyx.xyz/tags/%E6%B3%A2%E6%99%AE/"/>
    
      <category term="Andy Warhol" scheme="https://pazyx.xyz/tags/Andy-Warhol/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」Effective C++ 读书笔记（二）</title>
    <link href="https://pazyx.xyz/2018/07/03/effective-cpp02/"/>
    <id>https://pazyx.xyz/2018/07/03/effective-cpp02/</id>
    <published>2018-07-03T09:42:25.000Z</published>
    <updated>2018-07-20T12:30:47.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h1><p>这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）。</p><h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造 / 析构 / 赋值运算"></a>构造 / 析构 / 赋值运算</h1><h2 id="条款05：了解-C-默默编写并调用哪些函数"><a href="#条款05：了解-C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解 C++ 默默编写并调用哪些函数"></a>条款05：了解 C++ 默默编写并调用哪些函数</h2><p>一个 class 如果没有声明任何构造函数和析构函数，编译器会帮你声明以下的函数</p><ul><li>default 构造函数</li><li>copy 构造函数</li><li>copy assignment 操作符</li><li>析构函数<br>所有这些编译器为你生成的函数都是 public 的、<strong>大多数</strong>都是 inline 的（ Effective C++ 写的是都是 inline ），且只在需要时生成。</li></ul><p>当你声明了任何一个构造函数，编译器将不再为你声明 default 构造函数。</p><p>对于两个要做拷贝的函数，它们可能是 bitwise 或者 memberwise。具体的 Effective C++ 只做了简略的解释。想深入了解的可以看《深度探索C++对象模型》，之后我也会写读书笔记或书摘。</p><p>如果类中存在不可重新赋值的成员将报错。</p><p>比如下面的类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">NamedObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NamedObject(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> T&amp; value):nameValue(name),objectValue(value)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; nameValue;</span><br><span class="line"><span class="keyword">const</span> T objectValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>引用类型和 const 修饰的成员不可被重新赋值，如果存在两个 <code>NamedObject&lt;int&gt;</code> 类的对象 a 和 b ，做 <code>a = b</code> 将直接报错。编译器无法为它声明拷贝函数。<br>如果基类的 copy assignment 操作符被声明为 private 也是会导致编译失败。</p><h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>可以将构造函数声明为 private 禁止调用。比如有些类不希望被拷贝，可以将 copy 构造函数和 copy assignment 操作符声明为 private 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Uncopyable()&#123;&#125;</span><br><span class="line">~Uncopyable()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>也可以让不希望被拷贝的类直接继承 Uncopyable 类。Boost 库中也提供了名为 noncopyable 的class 保证被继承的类不被拷贝。</p><h2 id="条款07：为多态基类声明-virtual-析构函数"><a href="#条款07：为多态基类声明-virtual-析构函数" class="headerlink" title="条款07：为多态基类声明 virtual 析构函数"></a>条款07：为多态基类声明 virtual 析构函数</h2><p>基类无虚析构函数，会导致向上造型后被部分销毁导致内存泄露。</p><p>谨慎继承不带虚析构函数的类，如：string、STL 库中的所有容器…</p><p>不是所有的类都需要虚析构函数，vptr 和 vtbl 会占有大量空间，且降低了可移植性（不可传给其他语言）。</p><blockquote><p>许多人的心得时：只有当 class 内含至少一个 virtual 函数 才为它声明 virtual 析构函数。</p></blockquote><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p>C++ 不能同时处理多个异常，主要原因是被抛出的元素的内存空间是分配在栈区的，抛出异常后会跳出那一层括号，栈区应该被清理。如果你在存在一个异常的情况下去处理另一个异常很可能会覆盖掉之前异常抛出的元素，<strong>导致程序过早结束或出现不明确行为</strong>。<br>如果你的类中析构会抛出异常，那这个类的容器或数组在析构时很可能遇到多个异常，造成严重的后果。</p><p>有时我们类的析构函数必须执行一个可能抛出异常的行为时怎么办？比如关闭各种连接。<br>书中提供了三种方案<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; A.close(); &#125;</span><br><span class="line"><span class="keyword">catch</span>(...)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">&#125; <span class="comment">//调用 abort 结束程序</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; A.close(); &#125;</span><br><span class="line"><span class="keyword">catch</span>(...)&#123;</span><br><span class="line"><span class="comment">//记下运转记录，记下对 close 的调用失败</span></span><br><span class="line">&#125; <span class="comment">//吞下异常</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">db.close();</span><br><span class="line">closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line"><span class="keyword">if</span>(!closed)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123; db.close(); &#125;</span><br><span class="line"><span class="keyword">catch</span>(...)&#123;</span><br><span class="line"><span class="comment">//记下运转记录，记下对 close 的调用失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种就是直接将 close 函数开放给使用者，让使用者在析构前调用。</p><h2 id="条款09：绝不在构造和析构过程中调用-virtual-函数"><a href="#条款09：绝不在构造和析构过程中调用-virtual-函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用 virtual 函数"></a>条款09：绝不在构造和析构过程中调用 virtual 函数</h2><p>在构造函数和析构函数中调用虚成员函数，可能得不到你想要的结果，它实际上会调用基类的那个函数。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><h4 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h4><p>构造过程进入基类的构造函数时，派生类的成员还没被初始化，如果调用派生类的虚函数可能会用到派生类部分的成员，所以编译器将构造过程中的对象当做 当前进入的构造函数所属的类的一个对象，当然只能调用与当前构造函数同属一个类的函数了。</p><h4 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h4><p>进入析构函数，先销毁掉派生类的成员，在刚进入析构函数时这个对象已经不是完整的一个派生类的对象了，编译器只能把它当做它的基类的一个对象来看待。</p><blockquote><p>在构造和析构期间不要调用 virtual 函数，因为这个类调用从不下降至 drived class (比起当前执行构造函数和析构函数的那层)。</p></blockquote><h2 id="条款10：令-operator-返回一个-reference-to-this"><a href="#条款10：令-operator-返回一个-reference-to-this" class="headerlink" title="条款10：令 operator= 返回一个 reference to *this"></a>条款10：令 operator= 返回一个 <code>reference to *this</code></h2><p>返回 <code>*this</code> 的引用，可以让你的类的对象实现连锁赋值。<br>如：<code>x = y = z = 15;</code></p><h2 id="条款11：在-operator-中处理“自我赋值”"><a href="#条款11：在-operator-中处理“自我赋值”" class="headerlink" title="条款11：在 operator= 中处理“自我赋值”"></a>条款11：在 operator= 中处理“自我赋值”</h2><p>如果类中存在一个指向堆中元素的成员，那就要注意赋值时的自我赋值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">string</span> *s;</span><br><span class="line">A():s(<span class="keyword">new</span> <span class="built_in">string</span>())&#123;&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">s = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果 <code>this</code> 和 <code>&amp;rhs</code> 相等就尴尬了，它会先 delete 自己的 s ，实际上 <code>*this</code> 和 <code>rhs</code> 里的 s 指向的 string 对象都被销毁了。数据丢失而去之后也没办法使用成员 s 了。</p><p>相对安全的版本是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">string</span> *s;</span><br><span class="line">A():s(<span class="keyword">new</span> <span class="built_in">string</span>())&#123;&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">s = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>加入认同测试，保证了 “自我赋值” 的安全性，但还不具备 “异常安全性”。<br>如果在 <code>s = new string(*rhs.s);</code> 这一步导致异常，那 s 将指向一块已被删除的 string 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span>* pOrig = pb;</span><br><span class="line">s = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.s);</span><br><span class="line"><span class="keyword">delete</span> pOrig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样即使抛出异常，赋值失败也不会造成其他副作用，可以将 s 保持原状。</p><p><strong>copy and swap</strong> 技术<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span></span>; <span class="comment">//交换*this 和 rhs 的数据 见条款29</span></span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">A temp(rhs);</span><br><span class="line">swap(temp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>by value</strong> 传值方式的 <strong>copy and swap</strong> 技术<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span></span>; <span class="comment">//交换*this 和 rhs 的数据 见条款29</span></span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A rhs)</span><br><span class="line">&#123;</span><br><span class="line">swap(rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="条款12：复制对象时勿忘其每个成分"><a href="#条款12：复制对象时勿忘其每个成分" class="headerlink" title="条款12：复制对象时勿忘其每个成分"></a>条款12：复制对象时勿忘其每个成分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">A()&#123;&#125;</span><br><span class="line">A(A &amp;rhs):a(rhs.a)&#123;&#125;</span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>= (A &amp;rhs)&#123;</span><br><span class="line">a = rhs.a;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B()&#123;&#125;</span><br><span class="line">B(B &amp;rhs):b(rhs.b)&#123;&#125;</span><br><span class="line"></span><br><span class="line">B&amp; <span class="keyword">operator</span>= (B &amp;rhs)&#123;</span><br><span class="line">b = rhs.b;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>小心这样的代码，B 的两个 <strong>Copying</strong> 函数，都没有拷贝基类的数据( <code>int a</code> )。</p><blockquote><p><strong>Copying</strong> 函数应该确保赋值“对象内的所有成员变量” 及 “所有 base class 成分”。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B()&#123;&#125;</span><br><span class="line">B(B &amp;rhs):b(rhs.b),A(rhs)&#123;&#125; <span class="comment">// + ! </span></span><br><span class="line"></span><br><span class="line">B&amp; <span class="keyword">operator</span>= (B &amp;rhs)&#123;</span><br><span class="line">A::<span class="keyword">operator</span>=(rhs);<span class="comment">// + !</span></span><br><span class="line">b = rhs.b;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>两个 <strong>Copying</strong> 函数一般有相近的代码，但不要在一个 <strong>Copying</strong> 函数内调用另一个 <strong>Copying</strong> 函数。</p><blockquote><p>应该将共同机能放进第三个函数中，并由两个 <strong>Copying</strong> 函数共同调用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注意！&quot;&gt;&lt;a href=&quot;#注意！&quot; class=&quot;headerlink&quot; title=&quot;注意！&quot;&gt;&lt;/a&gt;注意！&lt;/h1&gt;&lt;p&gt;这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）
      
    
    </summary>
    
      <category term="泛 - 笔记" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="读书" scheme="https://pazyx.xyz/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="笔记" scheme="https://pazyx.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective C++" scheme="https://pazyx.xyz/tags/Effective-C/"/>
    
      <category term="构造函数" scheme="https://pazyx.xyz/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="运算符重载" scheme="https://pazyx.xyz/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="拷贝构造函数" scheme="https://pazyx.xyz/tags/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="缺省构造函数" scheme="https://pazyx.xyz/tags/%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="virtual 函数" scheme="https://pazyx.xyz/tags/virtual-%E5%87%BD%E6%95%B0/"/>
    
      <category term="自我赋值" scheme="https://pazyx.xyz/tags/%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC/"/>
    
      <category term="异常" scheme="https://pazyx.xyz/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Java 与 C++ 细节差异 （一）</title>
    <link href="https://pazyx.xyz/2018/07/01/cpptojava/"/>
    <id>https://pazyx.xyz/2018/07/01/cpptojava/</id>
    <published>2018-07-01T15:08:37.000Z</published>
    <updated>2018-07-04T17:34:10.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>相比 C++，Java提供了三种注释方式分别为</p><ul><li><code>//</code> 单行注释</li><li><code>/* ... */</code> 多行注释 </li><li><code>/** ... */</code> 文档注释<br>前两种与 C++ 相同，最后一种可以自动将注释内容生成文档。供使用者直接查看。</li></ul><hr><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><table><thead><tr><th>Java</th><th>存储空间</th><th>C++</th><th>存储空间</th></tr></thead><tbody><tr><td>int</td><td>4 字节</td><td>int</td><td>至少 4 字节，且大于等于 short</td></tr><tr><td>short</td><td>2 字节</td><td>short</td><td>至少 2 字节</td></tr><tr><td>long</td><td>8 字节</td><td>long</td><td>至少 4 字节，且大于等于 int</td></tr><tr><td>byte</td><td>1 字节</td><td></td><td></td></tr><tr><td></td><td></td><td>long long</td><td>至少 8 字节，且大于等于 long</td></tr></tbody></table><p>Java 提供了 4 种整数类型，与 C++ 相比 Java 的规范更为严格。可以看出 C++ 更在乎效率，而 Java 更在乎可移植性。</p><p>十六进制数和八进制数两种语言均可以使用  0x 和 0 为前缀来表示，而 Java 还提供了前缀 0b 来表示二进制数。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><table><thead><tr><th>Java</th><th>存储空间</th><th>C++</th><th>存储空间</th></tr></thead><tbody><tr><td>float</td><td>4 字节</td><td>float</td><td>4 字节</td></tr><tr><td>double</td><td>8 字节</td><td>double</td><td>8 字节</td></tr><tr><td></td><td></td><td>long double ( Intel )</td><td>16 字节</td></tr></tbody></table><p>两者都遵循  IEEE-754 标准</p><p>C++ 直接提供了 80 位的扩展精度浮点数，而 Java 没有提供。<br>Java 没有提供的原因还是对可移植性的考虑，值得注意的是如果 JVM 运行在 Intel 的处理器上时，浮点数的中间运算结果默认是采用扩展精度存储的。这是因为截断会使效率大幅降低，但 Java 也提供了截断的可能性，使用 <code>strictfp</code> 关键字标记的方法（函数）必须严格的对中间结果截断，保证在任何处理器环境的结果的一致性。<br>例：<code>public static strictfp void main(String[] args)</code></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Java 禁止使用未初始化的<strong>本地变量</strong>，C++ 可以。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>修饰符不同，Java 使用 final 修饰常量，但 const 也是 Java 的保留字。</p><table><thead><tr><th>Java</th><th>C++</th></tr></thead><tbody><tr><td><code>final type</code></td><td><code>const type</code></td></tr></tbody></table><p>常量可以不在定义出初始化，但必须保证在第一次使用前被初始化，且只初始化一次。</p><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Java 没有 C++ 中在栈区分配到数组，你不可以写出这样的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p><p>所有的数组，都需要使用 <code>new</code> 在堆上分配空间。</p><p>Java 提供了两种定义数组的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br></pre></td></tr></table></figure></p><p>如果你没有初始化数组，Java 会帮你做数组的初始化。数字数组将所有元素初始化为 0 ，boolean 数组初始化为 false，对象数组初始化为 null 。</p><p>Java 中 <code>[]</code>运算符被定义为检查数组边界，而且 Java 没有指针运算，不可以通过 <code>a + 1</code> 得到下一个元素。</p><hr><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><table><thead><tr><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>一个以字母开头的由字母或数字组成的序列，字母包括{‘A’ ~ ‘Z’、’a’ ~ ‘z’、’_’、’$’ 或在某种语言中代表字母的任何 Unicode 字符 }。</td><td>一个由数字，下划线，小写和大写拉丁字母，和大多数 Unicode 字符组成的任意长度的序列。有效的标识符必须以一个非数字字符（拉丁语字母，下划线或 Unicode 非数字字符）开头。</td></tr></tbody></table><p>注：<br>Java 中在某种语言中代表字母的任何 Unicode 字符，比如德国用户可以用 ä 。可以使用 Character 类的 isJavaIdentifierStart 和 isJavaIdentifierPart 方法检测。</p><p>C++ 中大多数 Unicode 字符是指除下表中的字符以外的 Unicode 字符。</p><table><thead><tr><th>代码点</th><th>说明</th></tr></thead><tbody><tr><td>U+0300 - U+036F</td><td>组合用抑音符 - 组合用拉丁文小写字母 X</td></tr><tr><td>U+1DC0 - U+1DFF</td><td>组合用带点抑音符 - 组合用下右箭头尖和向下箭头尖</td></tr><tr><td>U+20D0 - U+20FF</td><td>组合用上左鱼叉 - 组合用上星号</td></tr><tr><td>U+FE20 - U+FE2F</td><td>组合用连字左半 - 组合用西里尔文 Titlo 右半</td></tr></tbody></table><hr><h1 id="重名问题"><a href="#重名问题" class="headerlink" title="重名问题"></a>重名问题</h1><p>在 C++ 中你可以写出这样的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样进入大括号后，外层的整数 a 就被隐藏了，看不到了无法访问了，出大括号就可以继续访问外层的整数 a 了。</p><p>而在 Java 中编译器是不允许你写出这样的代码的。<br>Java 和 C++ 大体上相同，本地变量的生存期是由其所在的大括号决定的。它们两者的不同之处在于 Java 是完全不允许在一个变量的生存期内出现另一个重名的变量，而 C++ 允许在内层定义新的重名变量隐藏外层变量。</p><p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure></p><p>这样的代码在两种语言中都是错误的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure><p>这样的代码在两种语言中都是正确的。</p><p>二者唯一的差别就是我在最开始的那个例子，Java 在外层 a 的生存期还没结束前不可以定义新的重名变量，而 C++ 可以。</p><hr><h1 id="String-与-string"><a href="#String-与-string" class="headerlink" title="String 与 string"></a>String 与 string</h1><p>String 和 string 分别为 Java 和 C++ 库里的字符串，虽然只是差一个字母大小写，实际上它们有着巨大的差异。<br>string 更像是 char 的数组，它的每个单位都是可以直接这样 <code>s[index]</code> 访问的，而且可以进行修改。<br>String 就没有那么方便了，Java 没有运算符重载只能通过 <code>s.charAt( index )</code> 来转换成 <code>char</code> 再读。<strong>注意！String 没有提供写操作的方法。String 在 Java 中是一种不可修改的字符串。</strong></p><p>这实际上是效率优化上的不同想法，C++ 中每个 string 的对象都独占一块内存空间，Java 的 String 不可修改就可以将多个相同的字符串变量共享一块内存空间，复制操作效率也变得很高。但这样就要在字符串比较时特别注意，Java 的对象变量都是对象的管理者，且 Java 没有运算符重载，如果你有两个 String 的对象 a 和 b ，<code>a == b</code> 只是在判断它们管理的是不是一块内存空间。Java 相同字符串的共享内存空间的分配方案也不是 100% 的，它只是在合适的情况下共享空间，所以两个内容相同的字符串也不一定指向同一个内存空间。它的比较有时相等有时不相等都是很有可能的，所以不要那么做！<br>比较操作 <code>a.equals(b)</code> 使用 String 的 equals 方法即可。</p><p>那到底怎么修改字符串呢？你可以使用 <code>+</code> 运算符和 <code>substring</code> 方法进行拼接和切割字符串最后再赋值给原字符串。但这会有很大的开销，因为中间结果要生成很多不可改变的 String 对象。可以使用 StringBuilder 或者 StringBuffer。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.cppreference.com/w/cpp/language/types" target="_blank" rel="noopener">C++ 基础类型标准</a><br><a href="https://zh.cppreference.com/w/cpp/language/identifiers" target="_blank" rel="noopener">C++ 标识符标准</a><br><a href="https://docs.oracle.com/javase/specs/" target="_blank" rel="noopener">The Java® Language Specification</a><br>Java 核心技术 卷I —— Cay S. Horstmann、Gary Cornell<br>深入理解 Java 虚拟机 —— 周志明</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h1&gt;&lt;p&gt;相比 C++，Java提供了三种注释方式分别为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;//&lt;/code&gt; 单行注释&lt;/li&gt;
&lt;li&gt;&lt;co
      
    
    </summary>
    
      <category term="编程语言 - Java" scheme="https://pazyx.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Java/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="浮点数" scheme="https://pazyx.xyz/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
      <category term="Java" scheme="https://pazyx.xyz/tags/Java/"/>
    
      <category term="整数" scheme="https://pazyx.xyz/tags/%E6%95%B4%E6%95%B0/"/>
    
      <category term="命名规则" scheme="https://pazyx.xyz/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
    
      <category term="String" scheme="https://pazyx.xyz/tags/String/"/>
    
      <category term="string" scheme="https://pazyx.xyz/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>basic_ios 如何穿上它的 bool</title>
    <link href="https://pazyx.xyz/2018/06/29/cin-return/"/>
    <id>https://pazyx.xyz/2018/06/29/cin-return/</id>
    <published>2018-06-28T17:19:17.000Z</published>
    <updated>2018-07-04T17:33:36.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么可以-while-cin-gt-gt-n-？"><a href="#为什么可以-while-cin-gt-gt-n-？" class="headerlink" title="为什么可以 while( cin &gt;&gt; n ) ？"></a>为什么可以 while( cin &gt;&gt; n ) ？</h1><p>这个问题困扰了我很久。每次写出那行代码都在为什么没有输入时它会停，为什么可以这样写，每次写时都有些虚。<br>为了保持我的自信，我想象了很多情况来安抚自己。<br>起初我类比 C 语言，想着应该是 <code>cin</code> 这个鬼东西返回了一个 <code>bool</code> 类型的值。之后在学习了类与对象后，发现 <code>cin</code> 不过是个对象不可能返回什么值。我又给出了新的解释：也许 <code>cin &gt;&gt; n</code> 这个表达式是个 <code>bool</code> 类型的值吧。再之后我看运算符重载时，刚刚的解释也凉了。表达式 <code>cin &gt;&gt; n</code> 的值是 <code>&lt;&lt;</code> 的运算符重载函数返回的一个 basic_istream 类的对象而已。</p><p><strong>我的想象力有一些枯竭了 … …</strong></p><p>直到这几天我在看《深度探索C++对象模型》书时，书中的例子中提到了 basic_ios 的类型转换函数，又让我想起了之前的问题。我查阅了大量资料，大致搞清楚了 究竟为什么可以？和 解决方案的演变过程。</p><h2 id="while-的括号里能放什么？"><a href="#while-的括号里能放什么？" class="headerlink" title="while 的括号里能放什么？"></a>while 的括号里能放什么？</h2><blockquote><p>任何能按语境转换为 bool 的表达式，或带花括号或等号初始化器的单个变量声明。<br>每次迭代前求值此表达式，而若它产出 <code>false</code> ，则退出循环。若此为声明，则每次迭代前求值初始化器，且若被声明变量的值转换为 <code>false</code> ，则退出循环。</p></blockquote><h2 id="什么可以转换为-bool？"><a href="#什么可以转换为-bool？" class="headerlink" title="什么可以转换为 bool？"></a>什么可以转换为 bool？</h2><p>对于原始数据类型，适用于C++ 标准中的<strong>布尔转换</strong>规则<br>规则如下：</p><blockquote><p><strong>整数</strong>、浮点、无作用域枚举、<strong>指针和指向成员指针类型的纯右值</strong>能转换成 <code>bool</code> 类型纯右值。<br>值零（对于整数、浮点和无作用域枚举）、<strong>空指针值和空成员指针值</strong>变为 <code>false</code> 。所有其他值变为 <code>true</code> 。<br><code>std::nullptr_t</code> 类型纯右值，包括 <code>nullptr</code> ，能在直接初始化的语境中转换成 <code>bool</code> 类型纯右值。结果值为 <code>false</code> 。(C++11 起)</p></blockquote><p>对于用户定义类型，则需要给出 类型转换函数 或 以目标类型为参数的构造函数。</p><h2 id="究竟为什么可以？"><a href="#究竟为什么可以？" class="headerlink" title="究竟为什么可以？"></a>究竟为什么可以？</h2><p>我直接给出答案：basic_istream 的基类 basic_ios 类有一个 bool( ) 的运算符重载函数，也就是类型转换函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// C++11 </span></span><br><span class="line"><span class="comment">//若流无错误则为 true ，否则为 false 。</span></span><br></pre></td></tr></table></figure></p><p>这样就解决了上述问题，表达式 <code>cin &gt;&gt; n</code> 的值被转换为 <code>bool</code> 类型当然可以放在 while 的括号内没有任何问题。</p><hr><h1 id="演变过程"><a href="#演变过程" class="headerlink" title="演变过程"></a>演变过程</h1><p>上面的只是 C++11 标准库的解决方案。其实更有意思的是 basic_istream 的对象转换到 bool 类型在实现上的一些历史演变过程。</p><h2 id="operator-int-const"><a href="#operator-int-const" class="headerlink" title="operator int() const;"></a>operator int() const;</h2><p>由于 C++ 早期是没有 <code>bool</code> 类型的，iostream 库的构建者 Jerry Schwarz 希望通过为 basic_ios 类编写一个类型转换函数，提供将 basic_ios 类转换为 <code>int</code> 类型的方式，实现 <code>while( cin &gt;&gt; n )</code>。<br>可这样写后他发现一个问题，就是有人可能写出下面这种代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &lt;&lt; intValue; <span class="comment">// 正确的应该为 cin &gt;&gt; Value;</span></span><br></pre></td></tr></table></figure></p><p>由于 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符很容易让程序员用乱，有的人可能会写出上面的错误代码，但当时的编译器没有报错。<br>因为编译器发现 <code>cin</code> 是没有重载 <code>&lt;&lt;</code> ，但 <code>int</code> 是可以做左移 ( <code>&lt;&lt;</code> ) 的，程序将 basic_ios 的对象转换为 <code>int</code> 又进行了左移操作。这算不上错误，但至少将大部分程序员的错误隐藏了，让人难以定位错误。<br>这个错误之后被戏称为“Schwarz Error”，在这之后 Jerry Schwarz 用下面的函数取代了 <code>operator int () const;</code></p><h2 id="operator-void-const"><a href="#operator-void-const" class="headerlink" title="operator void*() const;"></a>operator void*() const;</h2><p>C++ 的标准中 <code>void*</code> 能隐式转换为 <code>bool</code> 类型，Jerry Schwarz 想到了这种方式，<br>并且还为 basic_ios 类重载了 <code>!</code> 运算符，以支持 <code>while( ! ( cin &gt;&gt; n ) )</code>。<br>这个函数一直维持到 C++11 的出现。</p><h2 id="explicit-operator-bool-const"><a href="#explicit-operator-bool-const" class="headerlink" title="explicit operator bool() const;"></a>explicit operator bool() const;</h2><p>之前的 <code>operato void*() const;</code> 其实是有安全风险的。<br>你可以直接给一个 <code>void*</code> 类型的变量赋一个 basic_ios 类的对象，并且没有任何的错误或警告。这是不安全的，这种类型转换应该是显性的才安全。<br>C++11 改变了隐式转换的一些规则，解决了安全 bool 问题。<br>C++11 之前在类型转换运算符重载函数前加上 <code>explicit</code> 关键字，声明它必须显式使用，以强制类型转换的形式去操作。比如：<code>bool b = (bool)cin</code> 才可以使用类型转换函数，而不能做 <code>bool b = cin</code> 这样的操作。<br>而 C++11 标准对目标为 <code>bool</code> 类型的转换，改变了标准。</p><p><strong>具体标准如下：</strong></p><blockquote><p>下列语境中，期待类型 <code>bool</code> ，而若声明 <code>bool t(e)</code>; 为良式则进行隐式转换（即考虑如 <code>explicit T::operator bool() const;</code> 的隐式转换函数）。我们说这种表达式 <code>e</code> 可按语境转换为 <code>bool</code>。</p><ul><li><code>if</code> 、 <code>while</code> 、 <code>for</code> 的控制表达式；</li><li>内建逻辑运算符 <code>!</code> 、 <code>&amp;&amp;</code> 和 <code>||</code> 的运算数；</li><li>条件运算符 <code>?:</code> 的首个运算数；</li><li><code>static_assert</code>  声明中的谓词；(C++11起)</li><li><code>noexcept</code>  指定符中的表达式；</li><li><code>explicit</code>  指定符中的表达式；(C++20 起)</li><li>契约属性 的谓词。(C++20 起)</li></ul></blockquote><p>这样在非上述语境下转换为 <code>bool</code> 类型就需要显式转换，而在控制表达式中可以自动的隐式转换。增强安全性的同时也保证向前兼容。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">隐式转换</a></li><li><a href="https://zh.cppreference.com/w/cpp/io/basic_ios" target="_blank" rel="noopener">std::basic_ios</a></li><li><a href="https://zh.cppreference.com/w/cpp/io/basic_ios/operator_bool" target="_blank" rel="noopener">std::basic_ios::operator bool</a></li><li><a href="https://zh.cppreference.com/w/cpp/language/explicit" target="_blank" rel="noopener">explicit 指定符</a></li><li><a href="https://zh.cppreference.com/w/cpp/language/while" target="_blank" rel="noopener">while 循环</a></li><li><a href="https://zh.cppreference.com/w/cpp/language/if" target="_blank" rel="noopener">if 语句</a></li><li>《深度探索C++对象模型》—— Stanley B. Lippman</li><li>《C++语言的设计与演化》—— Bjarne Stroustrup</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么可以-while-cin-gt-gt-n-？&quot;&gt;&lt;a href=&quot;#为什么可以-while-cin-gt-gt-n-？&quot; class=&quot;headerlink&quot; title=&quot;为什么可以 while( cin &amp;gt;&amp;gt; n ) ？&quot;&gt;&lt;/a&gt;为什么可以
      
    
    </summary>
    
      <category term="编程语言 - Cpp" scheme="https://pazyx.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Cpp/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="bool" scheme="https://pazyx.xyz/tags/bool/"/>
    
      <category term="basic_ios" scheme="https://pazyx.xyz/tags/basic-ios/"/>
    
      <category term="运算符重载" scheme="https://pazyx.xyz/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="类型转换" scheme="https://pazyx.xyz/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="Cpp演化" scheme="https://pazyx.xyz/tags/Cpp%E6%BC%94%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>System.in</title>
    <link href="https://pazyx.xyz/2018/06/16/System-in/"/>
    <id>https://pazyx.xyz/2018/06/16/System-in/</id>
    <published>2018-06-16T12:18:32.000Z</published>
    <updated>2018-07-21T14:19:57.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scanner-in-new-Scanner-System-in"><a href="#Scanner-in-new-Scanner-System-in" class="headerlink" title=" Scanner in = new Scanner(System.in) "></a><center> Scanner in = new Scanner(System.in) </center></h1><h4 id="2018-6-10"><a href="#2018-6-10" class="headerlink" title=" 2018.6.10 "></a><center> 2018.6.10 </center></h4><p><img src="/2018/06/16/System-in/1.png" alt=""></p><p><img src="/2018/06/16/System-in/2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scanner-in-new-Scanner-System-in&quot;&gt;&lt;a href=&quot;#Scanner-in-new-Scanner-System-in&quot; class=&quot;headerlink&quot; title=&quot; Scanner in = new Scanner(Sy
      
    
    </summary>
    
      <category term="泛 - 纪念" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E7%BA%AA%E5%BF%B5/"/>
    
    
      <category term="ACM" scheme="https://pazyx.xyz/tags/ACM/"/>
    
      <category term="省赛" scheme="https://pazyx.xyz/tags/%E7%9C%81%E8%B5%9B/"/>
    
      <category term="ACM题目" scheme="https://pazyx.xyz/tags/ACM%E9%A2%98%E7%9B%AE/"/>
    
      <category term="纪念" scheme="https://pazyx.xyz/tags/%E7%BA%AA%E5%BF%B5/"/>
    
      <category term="Java" scheme="https://pazyx.xyz/tags/Java/"/>
    
      <category term="Scanner" scheme="https://pazyx.xyz/tags/Scanner/"/>
    
      <category term="System.in" scheme="https://pazyx.xyz/tags/System-in/"/>
    
  </entry>
  
  <entry>
    <title>GCC LD DD 命令选项</title>
    <link href="https://pazyx.xyz/2018/05/11/gcc-ld-dd-cmd/"/>
    <id>https://pazyx.xyz/2018/05/11/gcc-ld-dd-cmd/</id>
    <published>2018-05-11T15:36:31.000Z</published>
    <updated>2018-07-06T20:08:56.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>此篇仅介绍一些我在 ucore 操作系统的 makefile 文件中遇到的命令选项，作为 lab_1 实验报告的一部分。</p><h1 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h1><ul><li>-c 进行预处理、编译、汇编，生成目标代码文件，不进行链接</li><li>-S 仅进行预处理、编译，生成汇编代码文件</li><li>-E 仅进行预处理</li><li><p>-o file 指定输出文件名</p><p><a href="https://paste.ubuntu.com/p/yJmG6rPmXN/" target="_blank" rel="noopener">GCC 8.1 manuals 摘录</a></p></li><li><p>-I (大写 i ) 指定头文件位置</p></li><li>-L (大写 L ) 指定库文件位置</li><li><p>-l (小写 L) 指定库名字</p><p>-I -L -l 选项的详解分别在 <a href="https://gcc.gnu.org/onlinedocs/gcc-8.1.0/gcc/" target="_blank" rel="noopener">GCC 8.1 manuals</a> 的第 200、201、195 页</p></li><li>-Wall 开启大部分警告，列表如下。一些不常用的警告可加 -Wextra 选项配合 - Wall 全部打开</li></ul><table><thead><tr><th>选项</th></tr></thead><tbody><tr><td><code>-Waddress</code></td></tr><tr><td><code>-Warray-bounds=1 (only with ‘-O2’)</code></td></tr><tr><td><code>-Wbool-compare</code></td></tr><tr><td><code>-Wbool-operation</code></td></tr><tr><td><code>-Wc++11-compat -Wc++14-compat</code></td></tr><tr><td><code>-Wcatch-value (C++ and Objective-C++ only)</code></td></tr><tr><td><code>-Wchar-subscripts</code></td></tr><tr><td><code>-Wcomment</code></td></tr><tr><td><code>-Wduplicate-decl-specifier (C and Objective-C only)</code></td></tr><tr><td><code>-Wenum-compare (in C/ObjC; this is on by default in C++)</code></td></tr><tr><td><code>-Wformat</code></td></tr><tr><td><code>-Wint-in-bool-context</code></td></tr><tr><td><code>-Wimplicit (C and Objective-C only)</code></td></tr><tr><td><code>-Wimplicit-int (C and Objective-C only)</code></td></tr><tr><td><code>-Wimplicit-function-declaration (C and Objective-C only)</code></td></tr><tr><td><code>-Winit-self (only for C++)</code></td></tr><tr><td><code>-Wlogical-not-parentheses</code></td></tr><tr><td><code>-Wmain (only for C/ObjC and unless ‘-ffreestanding’)</code></td></tr><tr><td><code>-Wmaybe-uninitialized</code></td></tr><tr><td><code>-Wmemset-elt-size</code></td></tr><tr><td><code>-Wmemset-transposed-args</code></td></tr><tr><td><code>-Wmisleading-indentation (only for C/C++)</code></td></tr><tr><td><code>-Wmissing-attributes</code></td></tr><tr><td><code>-Wmissing-braces (only for C/ObjC)</code></td></tr><tr><td><code>-Wmultistatement-macros</code></td></tr><tr><td><code>-Wnarrowing (only for C++)</code></td></tr><tr><td><code>-Wnonnull</code></td></tr><tr><td><code>-Wnonnull-compare</code></td></tr><tr><td><code>-Wopenmp-simd</code></td></tr><tr><td><code>-Wparentheses</code></td></tr><tr><td><code>-Wpointer-sign</code></td></tr><tr><td><code>-Wreorder</code></td></tr><tr><td><code>-Wreorder</code></td></tr><tr><td><code>-Wrestrict</code></td></tr><tr><td><code>-Wreturn-type</code></td></tr><tr><td><code>-Wsequence-point</code></td></tr><tr><td><code>-Wsign-compare (only in C++)</code></td></tr><tr><td><code>-Wsizeof-pointer-div</code></td></tr><tr><td><code>-Wsizeof-pointer-memaccess</code></td></tr><tr><td><code>-Wstrict-aliasing</code></td></tr><tr><td><code>-Wstrict-overflow=1</code></td></tr><tr><td><code>-Wswitch</code></td></tr><tr><td><code>-Wtautological-compare</code></td></tr><tr><td><code>-Wtrigraphs</code></td></tr><tr><td><code>-Wuninitialized</code></td></tr><tr><td><code>-Wunknown-pragmas</code></td></tr><tr><td><code>-Wunused-function</code></td></tr><tr><td><code>-Wunused-label</code></td></tr><tr><td><code>-Wunused-value</code></td></tr><tr><td><code>-Wunused-variable</code></td></tr><tr><td><code>-Wvolatile-register-var</code></td></tr></tbody></table><ul><li>-fno-builtin 不承认不以 __builtin_ 开头的内建 ( built-in ) 函数。</li><li>-ggdb 生成用于GDB的调试信息</li><li>-gstabs 使用stabs格式生成调试信息，</li><li>-nostdinc 不搜索头文件的标准系统目录</li><li>-fno-stack-protector 禁用堆栈保护机制</li></ul><h1 id="GNU-linker-ld-命令选项"><a href="#GNU-linker-ld-命令选项" class="headerlink" title="GNU linker ( ld ) 命令选项"></a>GNU linker ( ld ) 命令选项</h1><ul><li>-m emulation 模拟仿真链接器 如：-m elf_i386</li><li>-nostdlib 只用在命令行中显式指定的搜索库目录</li><li>-N 设置代码段和数据段均可读写</li><li>-e 指定入口</li><li>-Ttext 连接时重定向初始地址</li></ul><h1 id="dd-命令参数"><a href="#dd-命令参数" class="headerlink" title="dd 命令参数"></a>dd 命令参数</h1><ul><li><strong>if</strong> 代表输入文件。如果不指定if，默认就会从stdin中读取输入。</li><li><strong>of</strong> 代表输出文件。如果不指定of，默认就会将stdout作为默认输出。</li><li><strong>bs</strong> 代表字节为单位的块大小。</li><li><strong>count</strong> 代表被复制的块数。</li><li><strong>/dev/zero</strong> 是一个字符设备，会不断返回0值字节（\0）</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://gcc.gnu.org/onlinedocs/gcc-8.1.0/gcc/" target="_blank" rel="noopener">GCC 8.1 manuals</a></li><li>ld GNU Development Tools ( man ld )</li><li><a href="http://man.linuxde.net/dd" target="_blank" rel="noopener">Linux dd 命令详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;此篇仅介绍一些我在 ucore 操作系统的 makefile 文件中遇到的命令选项，作为 lab_1 实验报告的一部分。&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Linux" scheme="https://pazyx.xyz/tags/Linux/"/>
    
      <category term="C" scheme="https://pazyx.xyz/tags/C/"/>
    
      <category term="gcc" scheme="https://pazyx.xyz/tags/gcc/"/>
    
      <category term="ld" scheme="https://pazyx.xyz/tags/ld/"/>
    
      <category term="dd" scheme="https://pazyx.xyz/tags/dd/"/>
    
      <category term="操作系统" scheme="https://pazyx.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linker" scheme="https://pazyx.xyz/tags/linker/"/>
    
  </entry>
  
  <entry>
    <title>X86 计算机启动流程</title>
    <link href="https://pazyx.xyz/2018/05/03/x86-cpu-boot/"/>
    <id>https://pazyx.xyz/2018/05/03/x86-cpu-boot/</id>
    <published>2018-05-03T11:56:37.000Z</published>
    <updated>2018-07-06T20:09:30.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="硬件加电后寄存器初始值"><a href="#硬件加电后寄存器初始值" class="headerlink" title="硬件加电后寄存器初始值"></a>硬件加电后寄存器初始值</h1><p><img src="/2018/05/03/x86-cpu-boot/硬件加电后寄存器初始值.png" alt=""><br>加电后 CPU 进入实模式（为了兼容早期的8086处理器），实模式下 CPU 只有 1M 的寻址空间，地址计算为: $EA = Base + EIP$</p><p>即加电后的起始地址为 </p><p>$CS:EIP = FFFF0000H+0000FFF0H = FFFFFFF0H$</p><h1 id="从-FFFFFFF0H-到-00007C00H"><a href="#从-FFFFFFF0H-到-00007C00H" class="headerlink" title="从 FFFFFFF0H 到 00007C00H"></a>从 FFFFFFF0H 到 00007C00H</h1><p>FFFFFFF0H 中有什么呢？这里放着的是 CPU 要执行的第一条指令，通常是一条长跳转指令，它会设置 CS 和 EIP 将控制权交给 BIOS 做初始化工作。 BIOS 的执行过程</p><ul><li>硬件自检</li><li>检测关键部件的存在和工作状态</li><li>查找并执行接口卡的 BIOS 进行设备初始化</li><li>执行系统 BIOS 进行系统检测，检测和配置即插即用设备</li><li>更新 CMOS 的扩展系统配置数据 ESCD (系统配置表)</li><li>按指定顺序从软盘、硬盘或光驱启动</li><li>读取主引导扇区代码，拿到主引导记录</li><li>主引导扇区代码读取活动分区的引导扇区代码</li><li>活动分区的引导扇区代码读取文件系统的加载程序到内存中的 00007C00H 处</li><li>将 CS:EIP 设置为 00007C00H 控制权交给加载程序( bootloader )</li></ul><p>至此计算机的控制权已经交给操作系统的 bootloader 程序。</p><h1 id="bootloader-启动过程"><a href="#bootloader-启动过程" class="headerlink" title="bootloader 启动过程"></a>bootloader 启动过程</h1><ul><li>切换到保护模式，启用分段机制</li><li>读磁盘中 ELF 执行文件格式的操作系统到内存</li><li>显示字符串信息</li><li>把控制权交给操作系统</li></ul><h3 id="bootloader-代码"><a href="#bootloader-代码" class="headerlink" title="bootloader 代码"></a>bootloader 代码</h3><p><strong>ucore</strong></p><ul><li><a href="https://paste.ubuntu.com/p/qThFWK4m6w/" target="_blank" rel="noopener">asm.h</a></li><li><a href="https://paste.ubuntu.com/p/S8gpwvjC9s/" target="_blank" rel="noopener">bootasm.S</a></li><li><a href="https://paste.ubuntu.com/p/dsShT59wc3/" target="_blank" rel="noopener">bootmain.c</a></li></ul><p><strong>xv6</strong></p><ul><li><a href="https://paste.ubuntu.com/p/tPfkVHS9gq/" target="_blank" rel="noopener">bootasm.S</a></li><li><a href="https://paste.ubuntu.com/p/rbtsqtkzzW/" target="_blank" rel="noopener">bootmain.c</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;硬件加电后寄存器初始值&quot;&gt;&lt;a href=&quot;#硬件加电后寄存器初始值&quot; class=&quot;headerlink&quot; title=&quot;硬件加电后寄存器初始值&quot;&gt;&lt;/a&gt;硬件加电后寄存器初始值&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/05/03/x86-cpu-boot
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="操作系统" scheme="https://pazyx.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="寄存器" scheme="https://pazyx.xyz/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    
      <category term="CPU" scheme="https://pazyx.xyz/tags/CPU/"/>
    
      <category term="硬件" scheme="https://pazyx.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="bootloader" scheme="https://pazyx.xyz/tags/bootloader/"/>
    
      <category term="BIOS" scheme="https://pazyx.xyz/tags/BIOS/"/>
    
      <category term="启动流程" scheme="https://pazyx.xyz/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
      <category term="X86" scheme="https://pazyx.xyz/tags/X86/"/>
    
      <category term="Intel" scheme="https://pazyx.xyz/tags/Intel/"/>
    
  </entry>
  
  <entry>
    <title>AT&amp;T 与 Intel 汇编主要语法差异</title>
    <link href="https://pazyx.xyz/2018/04/23/att-intel-differents/"/>
    <id>https://pazyx.xyz/2018/04/23/att-intel-differents/</id>
    <published>2018-04-23T13:51:49.000Z</published>
    <updated>2018-07-20T09:01:51.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作数顺序"><a href="#操作数顺序" class="headerlink" title="操作数顺序"></a>操作数顺序</h1><p>在一般的二元指令（如 mov、add …）中，两个操作数分为源操作数和目的操作数。AT&amp;T 与 Intel操作数的顺序正好相反。</p><ul><li>“Op-code dst src” in <strong>Intel</strong> syntax.</li><li>“Op-code src dst” in <strong>AT&amp;T</strong> syntax.</li></ul><h1 id="寄存器名称"><a href="#寄存器名称" class="headerlink" title="寄存器名称"></a>寄存器名称</h1><p>AT&amp;T 语法中寄存器名称需要加前缀 ’%’ ，而 Intel 不需要。</p><h1 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h1><p>AT&amp;T 语法中立即数需要加前缀 ’$’ ，对于静态 ‘C’ 变量也一样。Intel的语法标准不需要。</p><h1 id="操作数大小"><a href="#操作数大小" class="headerlink" title="操作数大小"></a>操作数大小</h1><p>AT&amp;T 语法中，操作数大小由指令的最后一个字符决定，“b”、“w” 和 “l” 的指令后缀分别表示字节(8位)、word(16位)和长(32位)内存引用。 Intel 语法中，由操作数的前缀 ’byte ptr’, ’word ptr’, 和 ’dword ptr’ 决定。</p><ul><li>“mov al, byte ptr foo” in <strong>Intel</strong> syntax</li><li>“movb foo, %al” in <strong>AT&amp;T</strong> syntax</li></ul><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p>AT&amp;T 语法中基指寄存器被 ( ) 括起来，而 Intel 语法中使用 [ ] 。 <strong>地址表示：</strong></p><ul><li>section:[base + index*scale + disp] in <strong>Intel</strong> syntax</li><li>section:disp(base, index, scale) in <strong>AT&amp;T</strong> syntax</li></ul><ul><li>section：段地址</li><li>disp：偏移地址</li><li>index：变址</li><li>scale：比例因子</li></ul><p><strong>计算公式：[EA = base + ( index * scale ) + disp]</strong></p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><table><thead><tr><th>Intel Code</th><th>AT&amp;T Code</th></tr></thead><tbody><tr><td><code>mov eax,1</code></td><td><code>movl $1,%eax</code></td></tr><tr><td><code>mov ebx,0ffh</code></td><td><code>movl $0xff,%ebx</code></td></tr><tr><td><code>int 80h</code></td><td><code>int $0x80</code></td></tr><tr><td><code>mov ebx,eax</code></td><td><code>movl %eax,%ebx</code></td></tr><tr><td><code>mov eax,[ecx]</code></td><td><code>movl (%ecx),%eax</code></td></tr><tr><td><code>mov eax,[ebx+3]</code></td><td><code>movl 3(%ebx),%eax</code></td></tr><tr><td><code>mov eax,[ebx+20h]</code></td><td><code>movl 0x20(%ebx),%eax</code></td></tr><tr><td><code>add eax,[ebx+ecx*2h]</code></td><td><code>addl (%ebx,%ecx,0x2),%eax</code></td></tr><tr><td><code>lea eax,[ebx+ecx]</code></td><td><code>leal (%ebx,%ecx),%eax</code></td></tr><tr><td><code>sub eax,[ebx+ecx*4h-20h]</code></td><td><code>subl -0x20(%ebx,%ecx,0x4),%eax</code></td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>GCC-Inline-Assembly-HOWTO : <a href="http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#s3" target="_blank" rel="noopener">http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#s3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作数顺序&quot;&gt;&lt;a href=&quot;#操作数顺序&quot; class=&quot;headerlink&quot; title=&quot;操作数顺序&quot;&gt;&lt;/a&gt;操作数顺序&lt;/h1&gt;&lt;p&gt;在一般的二元指令（如 mov、add …）中，两个操作数分为源操作数和目的操作数。AT&amp;amp;T 与 Intel操
      
    
    </summary>
    
      <category term="编程语言 - Assembly" scheme="https://pazyx.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Assembly/"/>
    
    
      <category term="汇编语言" scheme="https://pazyx.xyz/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
      <category term="编程语言" scheme="https://pazyx.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++类与对象总结（四）访问属性</title>
    <link href="https://pazyx.xyz/2018/04/15/cpp-class-4/"/>
    <id>https://pazyx.xyz/2018/04/15/cpp-class-4/</id>
    <published>2018-04-15T15:28:33.000Z</published>
    <updated>2018-07-04T17:34:05.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>C++的访问属性我在本系列的第一篇 <a href="http://wszyx.org/2018/01/cpp-class_1/" target="_blank" rel="noopener">C++类与对象总结（一）</a> 已经有了一些介绍，但那时没有介绍继承中的访问属性问题，而且最近对 C++的保护模型也有了一些新的理解。此篇为 <a href="http://wszyx.org/2018/01/cpp-class_1/" target="_blank" rel="noopener">C++类与对象总结（一）</a> 在访问属性方面的补充。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>在 C++ 语言中有 public、protected 和 private 这三种访问属性。</p><ul><li>public：任何地方都可以访问</li><li>protected：只有这个<strong>类</strong>和它的派生类可以访问</li><li>private：只有这个<strong>类</strong>可以访问</li></ul><p><strong>概念</strong></p><ul><li><strong>1 保护是通过编译时的机制提供的，目标防止发生意外事件，而不是防止欺骗或者有意侵犯。</strong></li><li><strong>2 保护的单位是类，而不是某个对象。</strong></li><li><strong>3 受控制的是访问权，而不是可见性。</strong></li></ul><p>这其中的前两条我已经在 <a href="http://wszyx.org/2018/01/cpp-class_1/" target="_blank" rel="noopener">C++类与对象总结（一）</a> 中讲解并搭配了实验。 讲解清楚第三条之前，我们需要弄清楚什么是可见性。 <strong>可见性：</strong> 这个概念很常见，比如下面的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段程序的输出显然是 2，因为在 main 函数中第 4 行的全局的整数 i 是不可见的，它被第 8 行的局部整数 i 所遮蔽了。 我们再来看这个程序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAB</span> :</span> <span class="keyword">public</span> AA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AAB x;</span><br><span class="line">x.fun();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 AA 类中有一个私有的成员 a ，AAB 类 public 继承了 AA 类。显然现在 AAB 类的对象有了一个私有成员 a ，但这个 a 是 AA 类私有的，a 对于 AAB 类的 fun 函数有可能是不可见的，也有可能是不可访问的。</p><ul><li>如果是不可见的：我们可以看到代码中有一个全局变量 a ，不可见的话 fun 函数中会修改全局的 a 。</li><li>如果是不可访问的：那编译应该通不过，因为它在访问修改一个 private 的成员。</li></ul><p>尝试编译得到下面的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp.cpp: In member function &apos;void AAB:fun()&apos;:</span><br><span class="line">temp.cpp:17:3 error: &apos;int AA:a&apos; is private within this context</span><br><span class="line">a = 1;</span><br><span class="line">temp.cpp:9:6: note: declared private here;</span><br><span class="line">int a;</span><br></pre></td></tr></table></figure></p><p>它说 AA 类中的 a 是私有的。所以说这三个关键字<strong>限制的是访问属性而不是可见性</strong>。</p><h2 id="访问权限究竟是在限制谁？"><a href="#访问权限究竟是在限制谁？" class="headerlink" title="访问权限究竟是在限制谁？"></a>访问权限究竟是在限制谁？</h2><p><strong>它是在限制该类后续的使用者，而不是在限制该类现在的设计者！</strong>在后面的组合和继承中的访问权限会出现访问权限的多次限制，很多初学者会分不清楚类内和类外访问权限的区别，所以在这里先说明一下。访问权限我们关心的是我们做的这个类在未来的使用者手中的访问权限。因为三种访问权限均允许在类内访问，类内的访问权限只由其中的成员之前设计访问权限有关，与当前要设计的类赋予的访问权限无关。 类会在哪些地方被使用？</p><ul><li>作为变量被使用</li><li>在其派生类中被使用</li><li>向上造型，是否可以做指针或引用的类型转换</li></ul><h2 id="对象组合中的访问属性问题"><a href="#对象组合中的访问属性问题" class="headerlink" title="对象组合中的访问属性问题"></a>对象组合中的访问属性问题</h2><p>在讲继承中的访问权限之前我想先介绍组合中的访问权限。它们很相近，区别也会在下面讲到。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">AA b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果在 AAB 类外访问成员 b 中的成员的 a，会怎么样呢？当然是编译错误。因为在访问成员 b 中的成员 a 实际上是在访问成员 b ，而成员 b 是私有的不可访问。 这里访问权限发生了叠加，成员 a 的访问权限 AA 类赋予它的 public 再加上 AAB 类赋予成员 b 的 private 。这里发生了访问权限的叠加。 <strong>访问权限叠加时会怎么样？</strong> 我们再来看一下这三种访问权限的特点，从 public 任何地方都可以访问，上升到 protected 只能在类内和其子子孙孙的类中可以访问，再上升到 private 只能在类内访问。不难发现这三种访问权限的严格程度逐级递增，<strong>在发生访问权限叠加时应选择最严格的访问权限声明去限制其访问权限</strong>。因为访问是逐层进行的。 这就比如你现在需要乘坐很多种交通工具回家，假设一路上要乘坐船、地铁、飞机、汽车。你的行李中有一个打火机，你会想一下坐飞机不让携带打火机而选择不带它，而不会因为坐船、汽车、地铁都可以携带打火机而带上它。因为是否可以携带这些行李取决于你这一路上要接受的所有安检中最严格的那一个。</p><h1 id="继承中的访问属性问题"><a href="#继承中的访问属性问题" class="headerlink" title="继承中的访问属性问题"></a>继承中的访问属性问题</h1><p>常见三种继承就对应于这三种访问权限，继承的分类也由这三种访问属性产生的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> b1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> b1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> b1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">protected</span> Base2, <span class="keyword">private</span> Base3</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>我们讨论这段代码中 Y 类每个成员的范围属性。 再次提醒初学者！我们讨论的是在之后用到 Y 类时的访问属性，比如：从由 Y 类所定义的对象对其中成员的访问、在 Y 类的派生类中对其成员的访问。初学者可能会想知道在 Y 类内部对这些成员的访问属性问题。这里说明一下<strong>在 Y 类内部访问继承得到的成员是否受限与继承方式无关，只与基类声明的访问属性有关。</strong>比如在 Y 类内部访问成员 c3 是可以的，因为在 Base3 中声明其是 public 的访问属性，而这与它是以 private 方式继承无关。 这就与对象组合中的访问属性问题很相似了，我们再来看一段代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base1 a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Base2 b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Base3 c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果把 Y 类改写成这个样子，其所有成员的访问属性与之前的 Y 类相同。虽然它们的访问属性是一致的，但因为现在 Y 类不再是三个Base类的派生类了，所以在 Base 类中访问属性为 protected 的成员将不能在 Y 类和其派生类中被访问。 判断一个成员在继承过程中的访问属性时，可以通过将其转变为对象组合时的访问属性问题判断。<strong>注意这样判断的是它究竟是哪种访问属性，而不是它能不能被访问。</strong>能不能被访问应根据访问属性和是否为派生类判断。</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p><strong>向上造型</strong> 这里要分为两个位置： </p><p>一、在该类的 public 派生类中</p><ul><li>public：可以</li><li>protected：可以</li><li>private：当做无子父类关系，无法做指针或引用的类型转换</li></ul><p>二、在其他位置</p><ul><li>public：可以</li><li>protected：当做无子父类关系，无法做指针或引用的类型转换</li><li>private：当做无子父类关系，无法做指针或引用的类型转换</li></ul><p><strong>内部类问题</strong> 在内部类中对该类中的成员访问与在该类的成员函数访问一致，与内部类声明的访问属性无关。 <strong>模板类问题</strong> 模板类只是声明，编译器会根据每次指定的类型每次定义一个新的类，所以同一个模板是使用两个不同的类型定义的类是属于两个不同的类。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> member;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span><span class="params">(X&lt;U&gt;&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        &amp;y.member;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line">X&lt;<span class="keyword">float</span>&gt; y;</span><br><span class="line">x.Method(x);<span class="comment">// 可以</span></span><br><span class="line">x.Method(y);<span class="comment">// 不可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的 18 和 19 行作为对比，x 的 Method 传入它自己（相同类型）访问其 private 成员不会报错，而 x 的 Method 传入它的模板根据 float 定义的对象 y 再访问其 private 成员则会报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;C++的访问属性我在本系列的第一篇 &lt;a href=&quot;http://wszyx.org/2018/01/cpp-class_1/&quot; targ
      
    
    </summary>
    
      <category term="编程语言 - Cpp" scheme="https://pazyx.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Cpp/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="访问属性" scheme="https://pazyx.xyz/tags/%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7/"/>
    
      <category term="对象组合" scheme="https://pazyx.xyz/tags/%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88/"/>
    
      <category term="继承" scheme="https://pazyx.xyz/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="多态" scheme="https://pazyx.xyz/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="可见性" scheme="https://pazyx.xyz/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>「公告」 近期文章中的错误and博客计划</title>
    <link href="https://pazyx.xyz/2018/04/06/notice-1/"/>
    <id>https://pazyx.xyz/2018/04/06/notice-1/</id>
    <published>2018-04-06T07:38:42.000Z</published>
    <updated>2018-07-06T20:09:01.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最短路算法1——Dijkstra"><a href="#最短路算法1——Dijkstra" class="headerlink" title="最短路算法1——Dijkstra"></a>最短路算法1——Dijkstra</h2><p><strong>描述不清楚：</strong> 在时间复杂度最后的总结中，我之前提到“对于稠密图来说有时不优化比利用最小堆优化更高效”。实际上一般的图，甚至是完全图，利用最小堆优化效率都是优于不优化的。只有一种情况是相反的，就是边确实特别多，是顶点数的高次幂（3以上）的情况。一般来说这种图很少见，完全图的边数也就是顶点数的平方量级的，出现高次幂量级的边只有可能是有存在大量重边，在这里我们处理的是最短路问题我们可以只保留两个顶点之间最短的边，以消除重边。 <strong>补充：</strong> 一般的最短路算法，还有一种问法就是最长路问题。这个可以把所有的边权值都取相反数，初始化时将dist数组初始化为最小值，一般为INT_MIN。将比较符合取相反，结果取相反数。</p><h2 id="C-C-程序中的内存分配"><a href="#C-C-程序中的内存分配" class="headerlink" title="C/C++程序中的内存分配"></a>C/C++程序中的内存分配</h2><p><strong>错误：</strong> 我在“运行中的内存分配回收时机”中提到，代码段、数据段和BSS段在程序刚开始运行时分配。 实际上代码段准确的说是在编译时刻分配，其中的数据写在二进制文件中。数据段和BSS段中的局部静态变量是在第一次运行到定义位置分配，这个我在下文提到。 <strong>错误原因：</strong> 自己想的不够清晰，表达时不够严谨。</p><h2 id="动态规划B1——01背包和动态规划B2——完全背包"><a href="#动态规划B1——01背包和动态规划B2——完全背包" class="headerlink" title="动态规划B1——01背包和动态规划B2——完全背包"></a>动态规划B1——01背包和动态规划B2——完全背包</h2><p><strong>错误：</strong> 存在一些字母大小写问题，引起伪代码歧义。</p><h2 id="串匹配算法2——KMP"><a href="#串匹配算法2——KMP" class="headerlink" title="串匹配算法2——KMP"></a>串匹配算法2——KMP</h2><p><strong>展示问题：</strong> 例子中的字符串对齐我采用了空格和tab对齐，在一些低分辨率的设备上可能对齐会有错误，影响理解。 我本想以图片形式展示，但考虑到例子较多、图片排版不美观等问题，暂时还是以现在这种形式，之后发现什么好的方式我再修改。</p><h1 id="博客计划"><a href="#博客计划" class="headerlink" title="博客计划"></a>博客计划</h1><p>德州扑克的学习笔记一再delay，下周前一定更新。 希望写一些面向对象程序设计的文章。准备写几篇Java面向对象程序设计的文章，关注设计模式和一些实现手法。而C++主要还是想研究一下它的底层实现和准确的标准定义细节问题。结合Java 和 C++学习面向对象的设计模式。 数据结构和算法方面，我的计划是先学习一些对ACM题目实用的算法，对图论和动态规划有些兴趣。基础的数据结构（链表、树…）已经有一定了解，暂时先用STL苟住，之后再研究其各种实现细节。一些高级数据结构广泛了解一下。 题解，一直没更的原因是一直没有写过题了，由于时间不够由于懒惰。之前想写一类题目搞成一整篇发出去。但同一类题我能找到的有限感觉不成篇幅，就先存着草稿了。之后我计划是对于难度较高和有思考难度的题目单独发，简单的算法只给出简单思路和代码写成一整篇打包发。之后我还计划参加一些线上的竞赛，写一些竞赛中的经验体会。 娱乐节目，之前买了一堆可乐准备做个可乐大评测。一直没有写也没有喝，原因在于我一直发现有新的可乐，总想及其后一起体验。我想我估计是集不齐了，实在不行我就开个系列慢慢体验。这个也不是什么大事，我就看看什么时候有时间有心情，写一些吧。 书摘和笔记，我爱什么时候写什么时候写！ 淘宝店计划，店已经开好了，纸还没搞到。大概依旧是性冷淡风，反正也没人买，我就开个玩一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最短路算法1——Dijkstra&quot;&gt;&lt;a href=&quot;#最短路算法1——Dijkstra&quot; class=&quot;headerlink&quot; title=&quot;最短路算法1——Dijkstra&quot;&gt;&lt;/a&gt;最短路算法1——Dijkstra&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;描述不清楚：
      
    
    </summary>
    
      <category term="泛 - 公告" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E5%85%AC%E5%91%8A/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="算法" scheme="https://pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://pazyx.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包问题" scheme="https://pazyx.xyz/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
      <category term="01背包" scheme="https://pazyx.xyz/tags/01%E8%83%8C%E5%8C%85/"/>
    
      <category term="公告" scheme="https://pazyx.xyz/tags/%E5%85%AC%E5%91%8A/"/>
    
      <category term="C" scheme="https://pazyx.xyz/tags/C/"/>
    
      <category term="完全背包" scheme="https://pazyx.xyz/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    
      <category term="计划" scheme="https://pazyx.xyz/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="Dijkstra" scheme="https://pazyx.xyz/tags/Dijkstra/"/>
    
      <category term="KMP" scheme="https://pazyx.xyz/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>C/C++程序中的内存分配</title>
    <link href="https://pazyx.xyz/2018/04/03/ccppmemory/"/>
    <id>https://pazyx.xyz/2018/04/03/ccppmemory/</id>
    <published>2018-04-03T09:28:07.000Z</published>
    <updated>2018-07-04T17:33:32.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-C-程序中内存分为五个区域名称及其储存的数据如下"><a href="#C-C-程序中内存分为五个区域名称及其储存的数据如下" class="headerlink" title="C/C++程序中内存分为五个区域名称及其储存的数据如下"></a>C/C++程序中内存分为五个区域名称及其储存的数据如下</h1><ul><li>代码段：可执行代码、字符串常量</li><li>数据段：已初始化的全局变量（包括所有静态变量）、常量</li><li>BSS段：未初始化的全局变量（包括所有静态变量）、常量</li><li>栈：局部变量（包括函数参数）</li><li>堆：动态内存分配</li></ul><p><img src="/2018/04/03/ccppmemory/内存分布图.png" alt=""><br>需要注意这其中的代码段是只读的，其他区域都是可读可写的。 比如这种操作就是错误的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="comment">//char ss[] = "Hello";</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">'E'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Unix-like的系统中运行时会产生 <strong>Bus error: 10</strong> 的错误，原因就在于”Hello”为字符串常量它在代码段，它是不可写的。 第 7 行中给出了另一种的写法，这种写法就不会有问题，原因是编译器会给这个数组在栈中分配一块内存把代码段中的”Hello”拷贝过来。</p><h1 id="运行中的内存分配回收时机"><a href="#运行中的内存分配回收时机" class="headerlink" title="运行中的内存分配回收时机"></a>运行中的内存分配回收时机</h1><p>代码段的空间在编译时刻分配，数据段和BSS段中的全局变量在程序开始运行时被分配，而栈、堆和静态变量的内存分配就会相对复杂一些。 </p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = f(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这段程序中所有的变量都为局部变量，都存放在栈区。栈区的内存分配发生在进大括号时，回收发生在出大括号时。</p><ul><li>变量 a 在 12 行被定义，而它的内存空间已经在 11 行进大括号时就分配好了，内存的回收会在 main 函数结束前的 14 行发生。</li><li>f 函数中的参数变量 b 在 13 行分配空间并初始化，在离开 f 函数时回收空间。</li><li>变量 c 在第 6 行被定义，它的内存分配和回收与变量 a 类似。</li><li>临时变量 b + c 作为返回值在第 13 行调用 f 函数时分配，回收应在出 main 函数结束前。（临时变量的地址，可通过 C++11 的右值引用查看。）</li></ul><h3 id="static局部变量"><a href="#static局部变量" class="headerlink" title="static局部变量"></a>static局部变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样的静态局部变量 c 它的内存分配只会在<strong>第一次</strong>进入 f 函数时分配，内存回收与已初始化的全局变量一样放在全局数据区（数据段）中（若未初始化或初始化的值在编译时刻不可得到则在分配在BSS段中），它的内存回收与其他全局变量一致在程序结束之前回收。<br>关于如何保证局部静态变量只初始化一次的问题可以看这里：<a href="https://www.cnblogs.com/novice-dxx/p/7094690.html" target="_blank" rel="noopener">https://www.cnblogs.com/novice-dxx/p/7094690.html</a> </p><h3 id="vector的内存回收"><a href="#vector的内存回收" class="headerlink" title="vector的内存回收"></a>vector的内存回收</h3><p>vector可以通过 clear() 函数清空，但其内存空间却并没有回收。根据栈中内存回收的机制，我们可以以下面这种方式进行内存回收。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line">    v.swap(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>在内层括号中定义一个空 vector x 交换两者后，出括号后临时的 vector x会析构并回收内存空间。</strong></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆中的内存用于动态内存分配，动态申请像 C 中的 malloc 和 C++中的 new 运算符都可完成。</p><ul><li>堆中的内存分配只发生在调用内存申请函数或使用 new 运算符时</li><li>堆中的内存回收在 delete 时或程序结束时发生</li></ul><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/WXScjfWQ3z/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/WXScjfWQ3z/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_initialized_0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> global_initialized_1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_0;</span><br><span class="line"><span class="keyword">int</span> global_1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *const_string_0 = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> *const_string_1 = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_initialized_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_initialized_1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_0;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> local_0;</span><br><span class="line">    <span class="keyword">int</span> local_1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p_0 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> *p_1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"代码段:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main = %p\n"</span>,main);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"const_string_0 = %p\n"</span>,const_string_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"const_string_1 = %p\n"</span>,const_string_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数据段:\n"</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"global_initialized_0 = %p\n"</span>,&amp;global_initialized_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"global_initialized_1 = %p\n"</span>,&amp;global_initialized_1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"static_local_initialized_0 = %p\n"</span>,&amp;static_local_initialized_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"static_local_initialized_1 = %p\n"</span>,&amp;static_local_initialized_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSS:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"global_0 = %p\n"</span>,&amp;global_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"global_1 = %p\n"</span>,&amp;global_1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"static_local_0 = %p\n"</span>,&amp;static_local_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"static_local_1 = %p\n"</span>,&amp;static_local_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p_0 = %p\n"</span>, p_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p_1 = %p\n"</span>, p_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"local_0 = %p\n"</span>, &amp;local_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"local_1 = %p\n"</span>, &amp;local_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] p_0;</span><br><span class="line">    <span class="keyword">delete</span>[] p_1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Mac OS 64bit 输出结果</strong><br>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/5z3Kb5SZrk/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/5z3Kb5SZrk/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">代码段:</span><br><span class="line">main = 0x1066afb80</span><br><span class="line">const_string_0 = 0x1066afe56</span><br><span class="line">const_string_1 = 0x1066afe5c</span><br><span class="line"></span><br><span class="line">数据段:</span><br><span class="line">global_initialized_0 = 0x1066b0028</span><br><span class="line">global_initialized_1 = 0x1066b002c</span><br><span class="line">static_local_initialized_0 = 0x1066b0038</span><br><span class="line">static_local_initialized_1 = 0x1066b003c</span><br><span class="line"></span><br><span class="line">BSS:</span><br><span class="line">global_0 = 0x1066b0030</span><br><span class="line">global_1 = 0x1066b0034</span><br><span class="line">static_local_0 = 0x1066b0040</span><br><span class="line">static_local_1 = 0x1066b0044</span><br><span class="line"></span><br><span class="line">堆:</span><br><span class="line">p_0 = 0x7fcd6f4028f0</span><br><span class="line">p_1 = 0x7fcd6f402a80</span><br><span class="line"></span><br><span class="line">栈:</span><br><span class="line">local_0 = 0x7ffee95507e4</span><br><span class="line">local_1 = 0x7ffee95507e0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-C-程序中内存分为五个区域名称及其储存的数据如下&quot;&gt;&lt;a href=&quot;#C-C-程序中内存分为五个区域名称及其储存的数据如下&quot; class=&quot;headerlink&quot; title=&quot;C/C++程序中内存分为五个区域名称及其储存的数据如下&quot;&gt;&lt;/a&gt;C/C++程序
      
    
    </summary>
    
      <category term="编程语言 - Cpp" scheme="https://pazyx.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Cpp/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="C" scheme="https://pazyx.xyz/tags/C/"/>
    
      <category term="内存分配" scheme="https://pazyx.xyz/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
</feed>
