<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Microwave. Five minutes.</title>
  
  <subtitle>他大概会说你想得太多</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://pazyx.xyz/"/>
  <updated>2018-07-21T14:19:51.393Z</updated>
  <id>https://pazyx.xyz/</id>
  
  <author>
    <name>pazyx.xyz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>macOS 灾难</title>
    <link href="https://pazyx.xyz/2018/07/21/mac_os_disaster/"/>
    <id>https://pazyx.xyz/2018/07/21/mac_os_disaster/</id>
    <published>2018-07-21T10:52:18.000Z</published>
    <updated>2018-07-21T14:19:51.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="macOS-10-14-beta3"><a href="#macOS-10-14-beta3" class="headerlink" title=" macOS 10.14 beta3 "></a><center> macOS 10.14 beta3 </center></h1><h4 id="灾难性的数据丢失事故，博客数据险些全部丢失！"><a href="#灾难性的数据丢失事故，博客数据险些全部丢失！" class="headerlink" title=" 灾难性的数据丢失事故，博客数据险些全部丢失！ "></a><center> 灾难性的数据丢失事故，博客数据险些全部丢失！ </center></h4><h4 id="2018-7-21-凌晨"><a href="#2018-7-21-凌晨" class="headerlink" title=" 2018.7.21 凌晨 "></a><center> 2018.7.21 凌晨 </center></h4><p><img src="/2018/07/21/mac_os_disaster/disaster.png" alt=""></p><p>博客数据在废纸篓里找到了，历劫度人。。。<br>调整一下<strong>继续～</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;macOS-10-14-beta3&quot;&gt;&lt;a href=&quot;#macOS-10-14-beta3&quot; class=&quot;headerlink&quot; title=&quot; macOS 10.14 beta3 &quot;&gt;&lt;/a&gt;&lt;center&gt; macOS 10.14 beta3 &lt;/cent
      
    
    </summary>
    
      <category term="泛 - 纪念" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E7%BA%AA%E5%BF%B5/"/>
    
    
      <category term="灾难" scheme="https://pazyx.xyz/tags/%E7%81%BE%E9%9A%BE/"/>
    
      <category term="MacOS" scheme="https://pazyx.xyz/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 指南</title>
    <link href="https://pazyx.xyz/2018/07/15/markdown_guide/"/>
    <id>https://pazyx.xyz/2018/07/15/markdown_guide/</id>
    <published>2018-07-14T16:53:18.000Z</published>
    <updated>2018-07-21T12:03:16.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-是什么？"><a href="#Markdown-是什么？" class="headerlink" title="Markdown 是什么？"></a>Markdown 是什么？</h1><blockquote><p><strong>Markdown</strong> 是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML ）文档”。</p></blockquote><p><strong>注意！</strong>Markdown是标记语言，而不是样式表。<strong>它只是在标注说明文本中每一块是什么。</strong>比如标题、引用、代码。最终它显示的是什么样子的取决于你浏览它的工具，如果转成 HTML 那就由浏览器决定，你想改变它的样式就需要添加 CSS（层叠样式表）。</p><h1 id="我为什么学-Markdown？"><a href="#我为什么学-Markdown？" class="headerlink" title="我为什么学 Markdown？"></a>我为什么学 Markdown？</h1><p>主要是博客写作需要用到，用 Markdown 写作最大的好处是自由，你的文本是独立的。如果你使用WordPress 自带的编辑器写作，它的可移植性是很低的，导出 XML 文件后转换成其他格式后很多地方都需要手动调整。还有就是项目中 Readme 文件一般用 Markdown 写，你写作时不需要任何鼠标操作。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h2 id="文本基础样式"><a href="#文本基础样式" class="headerlink" title="文本基础样式"></a>文本基础样式</h2><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**加粗**</span></span><br></pre></td></tr></table></figure><p><strong>效果：**</strong>加粗**</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**斜体**</span></span><br></pre></td></tr></table></figure><p><strong>效果：*</strong>斜体*</p><h3 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">***斜体加粗**</span>*</span><br></pre></td></tr></table></figure><p><strong>效果：***</strong>斜体加粗***</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除~~</span><br></pre></td></tr></table></figure><p><strong>效果：</strong><del>删除</del></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 引用的内容</span></span><br><span class="line">&gt;&gt; 引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 引用的内容</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><blockquote><p>引用的内容</p><blockquote><p>引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>可以多级嵌套引用</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="strong">*****</span></span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><hr><hr><hr><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">超链接名</span>](<span class="link">超链接地址 "超链接title"</span>)</span><br><span class="line">title可缺省</span><br><span class="line"><span class="strong">**效果：**</span></span><br><span class="line">[<span class="string">Home</span>](<span class="link">https//pazyx.xyz "pazyx"</span>)</span><br></pre></td></tr></table></figure><p><strong>效果：</strong><br><a href="https//pazyx.xyz" title="pazyx">Home</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片alt</span>](<span class="link">图片地址 ''图片title''</span>)</span><br><span class="line">title可缺省</span><br><span class="line"><span class="strong">**效果：**</span></span><br><span class="line">![<span class="string">logo</span>](<span class="link">/markdown_basic/logo.png ''blogLogo''</span>)</span><br></pre></td></tr></table></figure><p><strong>效果：</strong><br><img src="/2018/07/15/markdown_guide/markdown_basic/logo.png" alt="logo" title="&#39;blogLogo&#39;"><br>图片地址可以是相对地址也可以是超链接</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>列表内容</span><br><span class="line"><span class="bullet">+ </span>列表内容</span><br><span class="line"><span class="bullet">* </span>列表内容</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p>1.列表内容<br>2.列表内容<br>3.列表内容</p><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>一级列表内容</span><br><span class="line">  - 二级列表内容</span><br><span class="line"><span class="code">    - 三级列表内容</span></span><br><span class="line"><span class="code">      - 四级列表内容</span></span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><ul><li>一级列表内容<ul><li>二级列表内容<ul><li>三级列表内容<ul><li>四级列表内容</li></ul></li></ul></li></ul></li></ul><p>两级之间差两个空格即可</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|表头|表头|表头|</span><br><span class="line">| - | :-: | :- |</span><br><span class="line">|内容|内容|内容|</span><br><span class="line">|内容|内容|内容|</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><table><thead><tr><th>表头</th><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>内容</td><td>内容</td><td>内容</td></tr><tr><td>内容</td><td>内容</td><td>内容</td></tr></tbody></table><p>默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行内 `code` 行内</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p>行内 <code>code</code> 行内</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`cpp</span><br><span class="line"><span class="section">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    std::cout &lt;&lt; "Hello World." &lt;&lt; endl;</span></span><br><span class="line"><span class="code">    return 0;</span></span><br><span class="line">&#125;</span><br><span class="line">\<span class="code">`\`</span>\`</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">markdown基本语法</a></li><li><a href="https://www.jianshu.com/p/2df05f279331" target="_blank" rel="noopener">Markdown插入表格语法</a></li><li><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown维基百科</a></li><li><a href="http://www.markdown.cn" target="_blank" rel="noopener">Markdown中文官网</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown-是什么？&quot;&gt;&lt;a href=&quot;#Markdown-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Markdown 是什么？&quot;&gt;&lt;/a&gt;Markdown 是什么？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Markd
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Markdown" scheme="https://pazyx.xyz/tags/Markdown/"/>
    
      <category term="标记语言" scheme="https://pazyx.xyz/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"/>
    
      <category term="写作工具" scheme="https://pazyx.xyz/tags/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>数学建模——动态规划</title>
    <link href="https://pazyx.xyz/2018/07/14/mathematical_modeling_dp/"/>
    <id>https://pazyx.xyz/2018/07/14/mathematical_modeling_dp/</id>
    <published>2018-07-14T10:13:18.000Z</published>
    <updated>2018-07-20T07:35:57.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前在学算法时接触过不少动态规划的题目，但最近实践周在上数学建模的课，发现自己在动态规划算法上欠缺很多。步骤不规范、思路不清晰、数学推导欠缺，大多数时候我都是靠直觉推状态转移方程的。这篇我希望从数学建模的角度重新总结一下动态规划（算法中的动态规划也会继续更新，最近将更新状压DP）。<br>算法竞赛和数学建模竞赛中动态规划，在数据和方程的表示上有很大不同。<br>算法竞赛中一般以数组单元的形式表示一个状态并用其推导状态转移方程，并且不对指标函数与最优值函数的单独推导。其形式更接近伪代码，方便将模型快速转换为代码。<br>数学建模竞赛中步骤相当严谨很多，各个方程相互独立，各个方程也更注重数学的严谨性。</p><hr><h1 id="标准步骤"><a href="#标准步骤" class="headerlink" title="标准步骤"></a>标准步骤</h1><ul><li>阶段</li><li>状态变量（无后效性）  \(s_k\)</li><li>决策变量  \(x_k\)</li><li>状态转移方程  \(s_{k+1} = T_k(s_k,x_k)\)</li><li>指标函数  \(V_{k,n} = V_{k,n}(s_k,x_k,s_{k+1},…,s_{n+1},k = 1,2,…,n\)</li><li>最优值函数  \[f_k(s_k) = \max_{\{x_k,…,x_n\}} V_{k,n}\]</li><li>边界条件</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>一个简单的完全背包问题，其算法我在<a href="/2018/03/01/cp-bp/">动态规划B2——完全背包</a>给出。</p><p>有一个容量为 V 的背包和 N 种物品。每种物品的价值为 \(W_k\) 体积为 \(C_k\) ，每种物品有无限件，问最大背包价值。</p><h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><p>N 种物品按编号排序，视为 N 个阶段。</p><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>\(s_k\) 第 k 阶段初可装载的质量</p><h3 id="决策变量"><a href="#决策变量" class="headerlink" title="决策变量"></a>决策变量</h3><p>装入第k种物品的数量：\(x_i\)</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>\[s_{k+1} = s_k - C_kx_k\] </p><h3 id="指标函数"><a href="#指标函数" class="headerlink" title="指标函数"></a>指标函数</h3><p>装入的第 k 种物品到第 N 种物品总价值：\(v_k\) </p><h3 id="最优值函数"><a href="#最优值函数" class="headerlink" title="最优值函数"></a>最优值函数</h3><p>\[f_k(s_k) = \max_{0≤x_k≤[s_k/a_k]} \{C_kx_k + f_k(s_{k+1})\ \ (k = 1…n)\]</p><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul><li>\(s_1 = V\)</li><li>\(f_{n+1}(s_{n+1}) = 0\)</li></ul><h3 id="与算法竞赛中的动态规划对比"><a href="#与算法竞赛中的动态规划对比" class="headerlink" title="与算法竞赛中的动态规划对比"></a>与算法竞赛中的动态规划对比</h3><ul><li>算法竞赛<br>\[F[i, v] = max \{ F[i − 1, v − kC_i] + kW_i \ \  0 ≤ kC_i ≤ v \} \]</li><li>数学建模竞赛<br>$$<br>\begin{cases}<br>f_k(s_k) = \max_{0≤x_k≤[s_k/a_k]} \{C_kx_k + f_k(s_{k+1})\} &amp;\text{(k = 1…n)} \\<br>f_{n+1}(s_{n+1}) = 0<br>\end{cases}<br>$$</li></ul><hr><h1 id="连续型动态规划"><a href="#连续型动态规划" class="headerlink" title="连续型动态规划"></a>连续型动态规划</h1><p>在大多数算法竞赛的题目中，决策点都是离散的。而在数学建模竞赛中可能出现连续型的动态规划问题，这种题目写出具体算法相当困难，多大需要笔算。</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>100 台某种机器可在高低两种不同的负荷下进行生产，设机器在高负荷下生产的产量函数为 g = 9x ，其中 x 为投入生产的机器数量，季度完好率为 a = 0.65 。在低负荷下生产的产量函数为 h = 4y ，其中 y 为投入生产的机器数量,季度完好率为 b = 0.95 。</p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><ul><li>把4个季度看成是4个阶段，用k表示。</li><li>状态变量\(s_k\)：表示第k季度初拥有的完好机器数量。(\(s_1\) = 100)</li><li>决策变量\(x_k\)：表示第k季度分配高负荷下生产的机器数量，于是\(s_k-x_k\)为该季度分配在低负荷下生产的机器数量。\(s_k\),\(x_k\)为连续变量，其小数部分表示一台机器正常工作时间所占的比例。允许决策集合:\(D_k(s_k) = \{ x_k \ \ |\ \ 0≤x_k≤s_k \}\)</li><li>状态转移方程：\[s_{k+1} = ax_k + b( s_k - x_k ) = 0.65x_k + (s_k - x_k ) \ \ (k = 1,2,3,4) \]</li><li>指标函数：\(v_k\) 表示第 k 季度的产量 \(v_k = 9x_k + 4(s_k+x_k)\)</li><li>最优值函数：<br>$$<br>\begin{cases}<br>f_k(s_k) = \max_{0≤x_k≤s_k} \{ v_k + f_{k+1}(s_{k+1}) \} = \max_{0≤x_k≤s_k} \{ 9x_k + 4(s_k-x_k) + f_{k+1}(s_{k+1}) \}\\<br>f_5(s_5) = 0<br>\end{cases}<br>$$</li></ul><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><p><strong>当 k = 4 时</strong></p><p>$$<br>\begin{align}<br>f_4(s_4)&amp; = \max_{0≤x_4≤s_4} \{ 9x_4 + 4(s_4-x_4) + f_5(s_5) \} \\<br>&amp; = \max_{0≤x_4≤s_4} \{ 9x_4 + 4(s_4-x_4) \} \\<br>&amp; = \max_{0≤x_4≤s_4} \{ 5x_4 + 4s_4 \}<br>\end{align}<br>$$<br>\[x^*_4 = s_4 ,f_4(s_4) = 9s_4\]</p><p><strong>当 k = 3 时</strong></p><p>$$<br>\begin{align}<br>f_3(s_3)&amp; = \max_{0≤x_3≤s_3} \{ 9x_3 + 4(s_3-x_3) + f_4(s_4) \} \\<br>&amp; = \max_{0≤x_3≤s_3} \{ 9x_3 + 4(s_3-x_3)+9[0.65x_3+0.95(s_3-x_3)] \} \\<br>&amp; = \max_{0≤x_3≤s_3} \{ 2.3x_3 + 12.55s_3 \}<br>\end{align}<br>$$<br>\[x^*_3 = s_3 ,f_3(s_3) = 14.85s_3\]</p><p><strong>当 k = 2 时</strong></p><p>$$<br>\begin{align}<br>f_2(s_2)&amp; = \max_{0≤x_2≤s_2} \{ 9x_2 + 4(s_2-x_2) + f_3(s_3) \} \\<br>&amp; = \max_{0≤x_2≤s_2} \{ 9x_2 + 4(s_2-x_2)+14.85[0.65x_2+0.95(s_2-x_2)] \} \\<br>&amp; = \max_{0≤x_2≤s_2} \{ 0.545x_2 + 18.1075s_3 \}<br>\end{align}<br>$$<br>\[x^*_2 = s_2 ,f_2(s_2) = 18.6525s_2\]</p><p><strong>当 k = 1 时</strong></p><p>$$<br>\begin{align}<br>f_1(s_1)&amp; = \max_{0≤x_1≤s_1} \{ 9x_1 + 4(s_1-x_1) + f_2(s_2) \} \\<br>&amp; = \max_{0≤x_1≤s_1} \{ 9x_1 + 4(s_1-x_1)+18.6525[0.65x_1+0.95(s_1-x_1)] \} \\<br>&amp; = \max_{0≤x_1≤s_1} \{ -0.596x_1 + 21.72s_1 \}<br>\end{align}<br>$$</p><p>\[ x^*_1 = 0 , s_1 = 100 , y^*_1 = s_1 - x^*_1 = 100 , f_1(s_1) = 21.72s_1 = 2172 \]</p><p><strong>反推</strong></p><p>$$<br>\begin{cases}<br>s_2 &amp; = 0.65x_1 + 0.95(s_1 - x_1) = 95; x_2^* = s_2 = 95,y_2^* = 0 \\<br>s_3 &amp; = 0.65x_2 + 0.95(s_2 - x_2) = 61.75,取整得61,x_3^* = s_3 = 61,y_3^* = 0 \\<br>s_4 &amp; = 0.65x_3 + 0.95(s_3 - x_3) = 39.65,取整得39,x_4^* = s_4 = 39,y_4^* = 0<br>\end{cases}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;之前在学算法时接触过不少动态规划的题目，但最近实践周在上数学建模的课，发现自己在动态规划算法上欠缺很多。步骤不规范、思路不清晰、数学推导欠缺
      
    
    </summary>
    
      <category term="数学" scheme="https://pazyx.xyz/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="动态规划" scheme="https://pazyx.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="完全背包" scheme="https://pazyx.xyz/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    
      <category term="数学建模" scheme="https://pazyx.xyz/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="连续型动态规划" scheme="https://pazyx.xyz/tags/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3254 Corn Fields（状压DP）</title>
    <link href="https://pazyx.xyz/2018/07/07/poj-3254-corn-fields/"/>
    <id>https://pazyx.xyz/2018/07/07/poj-3254-corn-fields/</id>
    <published>2018-07-06T19:22:10.000Z</published>
    <updated>2018-07-13T13:55:29.480Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：<a href="http://poj.org/problem?id=3254" target="_blank" rel="noopener">http://poj.org/problem?id=3254</a> </strong></p><h1 id="Corn-Fields"><a href="#Corn-Fields" class="headerlink" title="Corn Fields"></a>Corn Fields</h1><p><strong>Time Limit:</strong> 2000MS     <strong>Memory Limit:</strong> 65536K</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Farmer John has purchased a lush new rectangular pasture composed of <em>M</em> by <em>N</em> (1 ≤ <em>M</em> ≤ 12; 1 ≤ <em>N</em> ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant.</p><p>Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Line 1: Two space-separated integers: <em>M</em> and <em>N</em><br>Lines 2..<em>M</em>+1: Line <em>i</em>+1 describes row <em>i</em> of the pasture with <em>N</em> space-separated integers indicating whether a square is fertile (1 for fertile, 0 for infertile)</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Line 1: One integer: the number of ways that FJ can choose the squares modulo 100,000,000.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 1 1</span><br><span class="line">0 1 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>Number the squares as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">  4</span><br></pre></td></tr></table></figure><p>There are four ways to plant only on one squares (1, 2, 3, or 4), three ways to plant on two squares (13, 14, or 34), 1 way to plant on three squares (134), and one way to plant on no squares. 4+3+1+1=9.</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 M×N 的玉米地，但其中有些是不肥沃的，不能种植。用 1 来代表肥沃，0 代表不肥沃。另外奶牛不喜欢挨着吃玉米，也就是说要间隔着种植，求有几种种植方式，并将计算结果对 100000000 取模。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>状压DP入门题目。题目中要求不能挨着种，也就是行内不允许有相邻的地，行内比较好控制，而行间思考一下其实只需要考虑相邻两行的玉米地是否有冲突。<br>使用一个二进制数表示一行的玉米种植情况<br>状态：某行的玉米地分布情况</p><p>转移方程：<code>dp[i][j] = (dp[i][j] + dp[i - 1][k])%mod</code><br>第 i 行种植方案为 j 的种植方式数为等于其本身加上第 i-1 行种植方案为 k 的种植方式数，j 和 k 方案不冲突，且 j 和 k 方案本身行内不冲突，且种植土地都为肥沃的土地。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> state[MAX_N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">1</span>][<span class="number">1</span> &lt;&lt; MAX_M];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fit</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (now | flag) == flag;</span><br><span class="line">&#125;<span class="comment">//是否都是肥沃的土地</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; (x / <span class="number">2</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断行内是否冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_intersect</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (now &amp; prev) == <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断两行间是否冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> flag;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; flag;</span><br><span class="line">            state[i] |= (<span class="number">1</span> &lt;&lt; j) * flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ok(i))</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; m); ++j)&#123;<span class="comment">//枚举当前行</span></span><br><span class="line">            <span class="keyword">if</span>(!ok(j) || !fit(j,state[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; m); ++k)&#123;<span class="comment">//枚举下一行</span></span><br><span class="line">                <span class="keyword">if</span>(ok(k) &amp;&amp; fit(k,state[i<span class="number">-1</span>]) &amp;&amp; not_intersect(j,k))&#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][k]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); ++i)&#123;</span><br><span class="line">        ans = (ans + dp[n][i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目链接：&lt;a href=&quot;http://poj.org/problem?id=3254&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://poj.org/problem?id=3254&lt;/a&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
      <category term="题解" scheme="https://pazyx.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="https://pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://pazyx.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="题解" scheme="https://pazyx.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="POJ" scheme="https://pazyx.xyz/tags/POJ/"/>
    
      <category term="状压DP" scheme="https://pazyx.xyz/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>「周记」0x01 可乐</title>
    <link href="https://pazyx.xyz/2018/07/04/cola_a/"/>
    <id>https://pazyx.xyz/2018/07/04/cola_a/</id>
    <published>2018-07-04T13:39:47.000Z</published>
    <updated>2018-07-06T20:08:13.300Z</updated>
    
    <content type="html"><![CDATA[<p>考试周终于过去 我想写点什么 想写点自由的东西 因为考试周实在太过压抑 我已经一个月没去厦门放纵了 身体和心理都受到了折磨<br>在为数不多的几门需要大量写字的考试中 我多次提到自由和可乐 因为我渴望自由 我想在一堆答案里写点心里话自由一下<br>事实上我今天想写一写 <strong>可乐</strong> 我本想写的正经一点 因为我要发到我的博客上 一直以来我希望我的博客能够严谨认真 写完一篇检查多次 有什么错误马上打开电脑修改提交<br>今天我觉得既然要谈自由 我就自由一点吧 我也不想写什么标点符号 随便写写 反正这是我的博客 我来决定它的风格 我也不分段落和什么乱七八糟的 markdown 语法了 就按我想的来吧 其中可能有错别字（我已经看到了）我也不想改了 一切都波普</p><p>说到可乐 我已经在很多地方写过很多篇了 我想在这里总结一下 别回来都没了</p><ul><li><p>2017年8月28日 23:23</p><blockquote><p>去楼下超市买罐装可乐 发现罐装的雪碧和芬达都在唯独少了我的可乐 我很难过 之后我在罐装的雪碧芬达面前犹豫了一会儿 又看了看瓶装的可乐 我感觉那些都不是我想要的 你们知道我是个贵族非常讲究 瓶装和罐装的可乐完全是两个味儿 我走出那个超市决定去远方那个超市闯荡一次 之后我探访了两家超市结果它们只有瓶装的 最后我鼓足勇气走进了一家火锅店 问老板有罐装的可乐吗 他犹豫了一下说只有…… 说到这儿我心凉了 心想肯定是只有瓶装的 交谈间老板带着我走到了冰柜前 老板愣了一下说只有绿茶 他估计是在想怎么瓶装的可乐也没了 突然 我看到了冰柜上层的北冰洋 我想去他妈的罐装可乐 真够麻烦的 给我来瓶北冰洋 我喝着我的北冰洋走上了回家的路 感觉味道还可以 只是我感觉今天我有点儿不讲究了 所以说今天我这个贵族落魄了 我们等待明天 明天我带你们看看我的罐装可乐 带你们体验那种自由的味道     </p></blockquote></li><li><p>2017年10月24日 11:25</p><blockquote><p>自由的阳光 自由的可乐 军训让我体验了自由 唯一的遗憾就是为什么中区食堂的党员示范岗窗口的菜最好吃 我想如果我再多吃几天 也许我也能发现它不如人意的一面</p></blockquote></li><li><p>2018年3月16日 知乎问题：为什么有人愿意买 2.5 元 330ml 的易拉罐汽水，而不买 3 元 500ml 的瓶装？回答</p><blockquote><p>太巧了？我就是你说的那种买罐装可乐的人，而且我只买罐装的，更夸张的是我们学校罐装和瓶装都是3块。每次我买瓶装可乐都会剩一半以上后扔掉。<br>我想说啊，罐装的和瓶装的可乐它完全是两个味道。罐装的一般你需要一次喝完，汽很足。而瓶装的，打开放半个小时那口感是完全不能被接受的，只能扔掉。<br>对于我每天在食堂吃饭的情况来说，一罐罐装的可乐刚刚好，而瓶装的500ml显得略多，我还需要把它带回宿舍并且不能马上扔掉，因为那显得我很浪费。那样我就需要把它放上一段时间（一般是几个小时）得到一个足以安慰我内心的理由（它真的没汽了）再把它扔掉。我这个人很懒，不想那么麻烦。<br>还有就是在我喝完罐装可乐并扔掉罐的时候，我会有一种奇妙的感觉，就是我感觉到了自由。因为它不像瓶装可乐每次剩下的那些给我一种束缚感，我不需要为它找一个理由再扔掉。要知道自由在我们这个社会是很稀缺的，我很享受这种感觉，我很需要罐装可乐。<br>注意！我之前说的瓶装都是指塑料瓶装的，玻璃瓶装的那真是好味道，我可以保证它比塑料瓶装的和罐装的都更好喝并且更能让你感觉到那种自由的状态。</p></blockquote></li><li><p>2018年6月27日</p><blockquote><p>我想这可乐可能也没多自由 我一想象到可口可乐中国公司里的党支部开会的场面就浑身难受 这可乐代表不了自由 考完试我一定去买一瓶进口可乐感受一下自由 此刻请让我在外面溜达一会儿 让我吹一吹太平洋的风 今晚就是我的波普时间</p></blockquote></li></ul><p>要说我最喜欢这其中的哪篇 我觉得是第一篇 那篇写的很自由 很有现场感 也很有Andy Warhol的风格 而且它象征着我会写故事了<br>好了 言归正传 可乐为什么能代表自由？ 我也纳闷 我仔细回忆了一下应该是<strong>我瞎编的吧</strong> 高中我看了一些Andy Warhol的书<br>他说啊</p><blockquote><p>What’s great about this country is America started the tradition where the richest consumers buy essentially the same things as the poorest. You can be watching TV and see Coca-Cola, and you can know that the President drinks Coke, Liz Taylor drinks Coke, and just think, you can drink Coke, too. A Coke is a Coke and no amount of money can get you a better Coke than the one the bum on the corner is drinking. All the Cokes are the same and all the Cokes are good.<br>翻译：这个国家的伟大之处在于，美国开始了这样的传统:最富有的消费者买的东西基本上和最穷的人买的一样。你可以看电视，看可口可乐，你可以知道总统喝可乐，莉兹·泰勒喝可乐，想想，你也可以喝可乐。可口可乐就是可乐，再多的钱也买不到比街角的流浪汉喝的更好的可乐。所有的可乐都是一样的，所有的可乐都一样好。</p></blockquote><p><strong>现实 表面 瞬间 感性 快乐 平等 简单 机械 重复 大众</strong> 这是波普精神 可乐全占了 但就是没有自由 我也不知道 这个精神是谁想的 要是我就给它加上自由<br>写到这儿我大概明白了 可乐代表自由也许是因为快乐 我在自由的时刻最快乐 而且喝可乐也许这世上最简单的自由方式了 电影 肖申克的救赎 里他们在监狱房顶喝着啤酒 感受到了难得的自由<br>我想我喝可乐的时候跟他们一样 我感觉这个社会管得实在是太多了 各种网络社交媒体不能评论 不能发不能发的 各种好的网站都需要翻墙 媒体都在宣传正能量 说点其他都不行 我讨厌政治 但现在哪都是政治 可能我写了这一段我的网站就被封禁了 而且它们是合法的 因为我没备案 反正啊 我是托管在国外服务器上的 域名也是在国外买的也没备案 我也有了自己的梯子 封了我也可以自己写自己看<br>我还是希望人民们意识到自己的自由在一点一点被剥夺 实际上我们也无力反抗 如果不能像安迪一样逃出肖申克的话 还是与我一起共饮可乐吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考试周终于过去 我想写点什么 想写点自由的东西 因为考试周实在太过压抑 我已经一个月没去厦门放纵了 身体和心理都受到了折磨&lt;br&gt;在为数不多的几门需要大量写字的考试中 我多次提到自由和可乐 因为我渴望自由 我想在一堆答案里写点心里话自由一下&lt;br&gt;事实上我今天想写一写 &lt;s
      
    
    </summary>
    
      <category term="泛 - 周记" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E5%91%A8%E8%AE%B0/"/>
    
    
      <category term="周记" scheme="https://pazyx.xyz/tags/%E5%91%A8%E8%AE%B0/"/>
    
      <category term="可乐" scheme="https://pazyx.xyz/tags/%E5%8F%AF%E4%B9%90/"/>
    
      <category term="自由" scheme="https://pazyx.xyz/tags/%E8%87%AA%E7%94%B1/"/>
    
      <category term="波普" scheme="https://pazyx.xyz/tags/%E6%B3%A2%E6%99%AE/"/>
    
      <category term="Andy Warhol" scheme="https://pazyx.xyz/tags/Andy-Warhol/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」Effective C++ 读书笔记（二）</title>
    <link href="https://pazyx.xyz/2018/07/03/effective-cpp02/"/>
    <id>https://pazyx.xyz/2018/07/03/effective-cpp02/</id>
    <published>2018-07-03T09:42:25.000Z</published>
    <updated>2018-07-20T12:30:47.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h1><p>这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）。</p><h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造 / 析构 / 赋值运算"></a>构造 / 析构 / 赋值运算</h1><h2 id="条款05：了解-C-默默编写并调用哪些函数"><a href="#条款05：了解-C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解 C++ 默默编写并调用哪些函数"></a>条款05：了解 C++ 默默编写并调用哪些函数</h2><p>一个 class 如果没有声明任何构造函数和析构函数，编译器会帮你声明以下的函数</p><ul><li>default 构造函数</li><li>copy 构造函数</li><li>copy assignment 操作符</li><li>析构函数<br>所有这些编译器为你生成的函数都是 public 的、<strong>大多数</strong>都是 inline 的（ Effective C++ 写的是都是 inline ），且只在需要时生成。</li></ul><p>当你声明了任何一个构造函数，编译器将不再为你声明 default 构造函数。</p><p>对于两个要做拷贝的函数，它们可能是 bitwise 或者 memberwise。具体的 Effective C++ 只做了简略的解释。想深入了解的可以看《深度探索C++对象模型》，之后我也会写读书笔记或书摘。</p><p>如果类中存在不可重新赋值的成员将报错。</p><p>比如下面的类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">NamedObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NamedObject(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> T&amp; value):nameValue(name),objectValue(value)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; nameValue;</span><br><span class="line"><span class="keyword">const</span> T objectValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>引用类型和 const 修饰的成员不可被重新赋值，如果存在两个 <code>NamedObject&lt;int&gt;</code> 类的对象 a 和 b ，做 <code>a = b</code> 将直接报错。编译器无法为它声明拷贝函数。<br>如果基类的 copy assignment 操作符被声明为 private 也是会导致编译失败。</p><h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>可以将构造函数声明为 private 禁止调用。比如有些类不希望被拷贝，可以将 copy 构造函数和 copy assignment 操作符声明为 private 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Uncopyable()&#123;&#125;</span><br><span class="line">~Uncopyable()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>也可以让不希望被拷贝的类直接继承 Uncopyable 类。Boost 库中也提供了名为 noncopyable 的class 保证被继承的类不被拷贝。</p><h2 id="条款07：为多态基类声明-virtual-析构函数"><a href="#条款07：为多态基类声明-virtual-析构函数" class="headerlink" title="条款07：为多态基类声明 virtual 析构函数"></a>条款07：为多态基类声明 virtual 析构函数</h2><p>基类无虚析构函数，会导致向上造型后被部分销毁导致内存泄露。</p><p>谨慎继承不带虚析构函数的类，如：string、STL 库中的所有容器…</p><p>不是所有的类都需要虚析构函数，vptr 和 vtbl 会占有大量空间，且降低了可移植性（不可传给其他语言）。</p><blockquote><p>许多人的心得时：只有当 class 内含至少一个 virtual 函数 才为它声明 virtual 析构函数。</p></blockquote><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p>C++ 不能同时处理多个异常，主要原因是被抛出的元素的内存空间是分配在栈区的，抛出异常后会跳出那一层括号，栈区应该被清理。如果你在存在一个异常的情况下去处理另一个异常很可能会覆盖掉之前异常抛出的元素，<strong>导致程序过早结束或出现不明确行为</strong>。<br>如果你的类中析构会抛出异常，那这个类的容器或数组在析构时很可能遇到多个异常，造成严重的后果。</p><p>有时我们类的析构函数必须执行一个可能抛出异常的行为时怎么办？比如关闭各种连接。<br>书中提供了三种方案<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; A.close(); &#125;</span><br><span class="line"><span class="keyword">catch</span>(...)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">&#125; <span class="comment">//调用 abort 结束程序</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; A.close(); &#125;</span><br><span class="line"><span class="keyword">catch</span>(...)&#123;</span><br><span class="line"><span class="comment">//记下运转记录，记下对 close 的调用失败</span></span><br><span class="line">&#125; <span class="comment">//吞下异常</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">db.close();</span><br><span class="line">closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line"><span class="keyword">if</span>(!closed)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123; db.close(); &#125;</span><br><span class="line"><span class="keyword">catch</span>(...)&#123;</span><br><span class="line"><span class="comment">//记下运转记录，记下对 close 的调用失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种就是直接将 close 函数开放给使用者，让使用者在析构前调用。</p><h2 id="条款09：绝不在构造和析构过程中调用-virtual-函数"><a href="#条款09：绝不在构造和析构过程中调用-virtual-函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用 virtual 函数"></a>条款09：绝不在构造和析构过程中调用 virtual 函数</h2><p>在构造函数和析构函数中调用虚成员函数，可能得不到你想要的结果，它实际上会调用基类的那个函数。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><h4 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h4><p>构造过程进入基类的构造函数时，派生类的成员还没被初始化，如果调用派生类的虚函数可能会用到派生类部分的成员，所以编译器将构造过程中的对象当做 当前进入的构造函数所属的类的一个对象，当然只能调用与当前构造函数同属一个类的函数了。</p><h4 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h4><p>进入析构函数，先销毁掉派生类的成员，在刚进入析构函数时这个对象已经不是完整的一个派生类的对象了，编译器只能把它当做它的基类的一个对象来看待。</p><blockquote><p>在构造和析构期间不要调用 virtual 函数，因为这个类调用从不下降至 drived class (比起当前执行构造函数和析构函数的那层)。</p></blockquote><h2 id="条款10：令-operator-返回一个-reference-to-this"><a href="#条款10：令-operator-返回一个-reference-to-this" class="headerlink" title="条款10：令 operator= 返回一个 reference to *this"></a>条款10：令 operator= 返回一个 <code>reference to *this</code></h2><p>返回 <code>*this</code> 的引用，可以让你的类的对象实现连锁赋值。<br>如：<code>x = y = z = 15;</code></p><h2 id="条款11：在-operator-中处理“自我赋值”"><a href="#条款11：在-operator-中处理“自我赋值”" class="headerlink" title="条款11：在 operator= 中处理“自我赋值”"></a>条款11：在 operator= 中处理“自我赋值”</h2><p>如果类中存在一个指向堆中元素的成员，那就要注意赋值时的自我赋值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">string</span> *s;</span><br><span class="line">A():s(<span class="keyword">new</span> <span class="built_in">string</span>())&#123;&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">s = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果 <code>this</code> 和 <code>&amp;rhs</code> 相等就尴尬了，它会先 delete 自己的 s ，实际上 <code>*this</code> 和 <code>rhs</code> 里的 s 指向的 string 对象都被销毁了。数据丢失而去之后也没办法使用成员 s 了。</p><p>相对安全的版本是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">string</span> *s;</span><br><span class="line">A():s(<span class="keyword">new</span> <span class="built_in">string</span>())&#123;&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">s = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>加入认同测试，保证了 “自我赋值” 的安全性，但还不具备 “异常安全性”。<br>如果在 <code>s = new string(*rhs.s);</code> 这一步导致异常，那 s 将指向一块已被删除的 string 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span>* pOrig = pb;</span><br><span class="line">s = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.s);</span><br><span class="line"><span class="keyword">delete</span> pOrig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样即使抛出异常，赋值失败也不会造成其他副作用，可以将 s 保持原状。</p><p><strong>copy and swap</strong> 技术<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span></span>; <span class="comment">//交换*this 和 rhs 的数据 见条款29</span></span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">A temp(rhs);</span><br><span class="line">swap(temp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>by value</strong> 传值方式的 <strong>copy and swap</strong> 技术<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span></span>; <span class="comment">//交换*this 和 rhs 的数据 见条款29</span></span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A rhs)</span><br><span class="line">&#123;</span><br><span class="line">swap(rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="条款12：复制对象时勿忘其每个成分"><a href="#条款12：复制对象时勿忘其每个成分" class="headerlink" title="条款12：复制对象时勿忘其每个成分"></a>条款12：复制对象时勿忘其每个成分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">A()&#123;&#125;</span><br><span class="line">A(A &amp;rhs):a(rhs.a)&#123;&#125;</span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>= (A &amp;rhs)&#123;</span><br><span class="line">a = rhs.a;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B()&#123;&#125;</span><br><span class="line">B(B &amp;rhs):b(rhs.b)&#123;&#125;</span><br><span class="line"></span><br><span class="line">B&amp; <span class="keyword">operator</span>= (B &amp;rhs)&#123;</span><br><span class="line">b = rhs.b;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>小心这样的代码，B 的两个 <strong>Copying</strong> 函数，都没有拷贝基类的数据( <code>int a</code> )。</p><blockquote><p><strong>Copying</strong> 函数应该确保赋值“对象内的所有成员变量” 及 “所有 base class 成分”。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B()&#123;&#125;</span><br><span class="line">B(B &amp;rhs):b(rhs.b),A(rhs)&#123;&#125; <span class="comment">// + ! </span></span><br><span class="line"></span><br><span class="line">B&amp; <span class="keyword">operator</span>= (B &amp;rhs)&#123;</span><br><span class="line">A::<span class="keyword">operator</span>=(rhs);<span class="comment">// + !</span></span><br><span class="line">b = rhs.b;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>两个 <strong>Copying</strong> 函数一般有相近的代码，但不要在一个 <strong>Copying</strong> 函数内调用另一个 <strong>Copying</strong> 函数。</p><blockquote><p>应该将共同机能放进第三个函数中，并由两个 <strong>Copying</strong> 函数共同调用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注意！&quot;&gt;&lt;a href=&quot;#注意！&quot; class=&quot;headerlink&quot; title=&quot;注意！&quot;&gt;&lt;/a&gt;注意！&lt;/h1&gt;&lt;p&gt;这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）
      
    
    </summary>
    
      <category term="泛 - 笔记" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="构造函数" scheme="https://pazyx.xyz/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="运算符重载" scheme="https://pazyx.xyz/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="读书" scheme="https://pazyx.xyz/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="笔记" scheme="https://pazyx.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective C++" scheme="https://pazyx.xyz/tags/Effective-C/"/>
    
      <category term="拷贝构造函数" scheme="https://pazyx.xyz/tags/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="缺省构造函数" scheme="https://pazyx.xyz/tags/%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="virtual 函数" scheme="https://pazyx.xyz/tags/virtual-%E5%87%BD%E6%95%B0/"/>
    
      <category term="自我赋值" scheme="https://pazyx.xyz/tags/%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC/"/>
    
      <category term="异常" scheme="https://pazyx.xyz/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Java 与 C++ 细节差异 （一）</title>
    <link href="https://pazyx.xyz/2018/07/01/cpptojava/"/>
    <id>https://pazyx.xyz/2018/07/01/cpptojava/</id>
    <published>2018-07-01T15:08:37.000Z</published>
    <updated>2018-07-04T17:34:10.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>相比 C++，Java提供了三种注释方式分别为</p><ul><li><code>//</code> 单行注释</li><li><code>/* ... */</code> 多行注释 </li><li><code>/** ... */</code> 文档注释<br>前两种与 C++ 相同，最后一种可以自动将注释内容生成文档。供使用者直接查看。</li></ul><hr><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><table><thead><tr><th>Java</th><th>存储空间</th><th>C++</th><th>存储空间</th></tr></thead><tbody><tr><td>int</td><td>4 字节</td><td>int</td><td>至少 4 字节，且大于等于 short</td></tr><tr><td>short</td><td>2 字节</td><td>short</td><td>至少 2 字节</td></tr><tr><td>long</td><td>8 字节</td><td>long</td><td>至少 4 字节，且大于等于 int</td></tr><tr><td>byte</td><td>1 字节</td><td></td><td></td></tr><tr><td></td><td></td><td>long long</td><td>至少 8 字节，且大于等于 long</td></tr></tbody></table><p>Java 提供了 4 种整数类型，与 C++ 相比 Java 的规范更为严格。可以看出 C++ 更在乎效率，而 Java 更在乎可移植性。</p><p>十六进制数和八进制数两种语言均可以使用  0x 和 0 为前缀来表示，而 Java 还提供了前缀 0b 来表示二进制数。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><table><thead><tr><th>Java</th><th>存储空间</th><th>C++</th><th>存储空间</th></tr></thead><tbody><tr><td>float</td><td>4 字节</td><td>float</td><td>4 字节</td></tr><tr><td>double</td><td>8 字节</td><td>double</td><td>8 字节</td></tr><tr><td></td><td></td><td>long double ( Intel )</td><td>16 字节</td></tr></tbody></table><p>两者都遵循  IEEE-754 标准</p><p>C++ 直接提供了 80 位的扩展精度浮点数，而 Java 没有提供。<br>Java 没有提供的原因还是对可移植性的考虑，值得注意的是如果 JVM 运行在 Intel 的处理器上时，浮点数的中间运算结果默认是采用扩展精度存储的。这是因为截断会使效率大幅降低，但 Java 也提供了截断的可能性，使用 <code>strictfp</code> 关键字标记的方法（函数）必须严格的对中间结果截断，保证在任何处理器环境的结果的一致性。<br>例：<code>public static strictfp void main(String[] args)</code></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Java 禁止使用未初始化的<strong>本地变量</strong>，C++ 可以。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>修饰符不同，Java 使用 final 修饰常量，但 const 也是 Java 的保留字。</p><table><thead><tr><th>Java</th><th>C++</th></tr></thead><tbody><tr><td><code>final type</code></td><td><code>const type</code></td></tr></tbody></table><p>常量可以不在定义出初始化，但必须保证在第一次使用前被初始化，且只初始化一次。</p><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Java 没有 C++ 中在栈区分配到数组，你不可以写出这样的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p><p>所有的数组，都需要使用 <code>new</code> 在堆上分配空间。</p><p>Java 提供了两种定义数组的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br></pre></td></tr></table></figure></p><p>如果你没有初始化数组，Java 会帮你做数组的初始化。数字数组将所有元素初始化为 0 ，boolean 数组初始化为 false，对象数组初始化为 null 。</p><p>Java 中 <code>[]</code>运算符被定义为检查数组边界，而且 Java 没有指针运算，不可以通过 <code>a + 1</code> 得到下一个元素。</p><hr><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><table><thead><tr><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>一个以字母开头的由字母或数字组成的序列，字母包括{‘A’ ~ ‘Z’、’a’ ~ ‘z’、’_’、’$’ 或在某种语言中代表字母的任何 Unicode 字符 }。</td><td>一个由数字，下划线，小写和大写拉丁字母，和大多数 Unicode 字符组成的任意长度的序列。有效的标识符必须以一个非数字字符（拉丁语字母，下划线或 Unicode 非数字字符）开头。</td></tr></tbody></table><p>注：<br>Java 中在某种语言中代表字母的任何 Unicode 字符，比如德国用户可以用 ä 。可以使用 Character 类的 isJavaIdentifierStart 和 isJavaIdentifierPart 方法检测。</p><p>C++ 中大多数 Unicode 字符是指除下表中的字符以外的 Unicode 字符。</p><table><thead><tr><th>代码点</th><th>说明</th></tr></thead><tbody><tr><td>U+0300 - U+036F</td><td>组合用抑音符 - 组合用拉丁文小写字母 X</td></tr><tr><td>U+1DC0 - U+1DFF</td><td>组合用带点抑音符 - 组合用下右箭头尖和向下箭头尖</td></tr><tr><td>U+20D0 - U+20FF</td><td>组合用上左鱼叉 - 组合用上星号</td></tr><tr><td>U+FE20 - U+FE2F</td><td>组合用连字左半 - 组合用西里尔文 Titlo 右半</td></tr></tbody></table><hr><h1 id="重名问题"><a href="#重名问题" class="headerlink" title="重名问题"></a>重名问题</h1><p>在 C++ 中你可以写出这样的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样进入大括号后，外层的整数 a 就被隐藏了，看不到了无法访问了，出大括号就可以继续访问外层的整数 a 了。</p><p>而在 Java 中编译器是不允许你写出这样的代码的。<br>Java 和 C++ 大体上相同，本地变量的生存期是由其所在的大括号决定的。它们两者的不同之处在于 Java 是完全不允许在一个变量的生存期内出现另一个重名的变量，而 C++ 允许在内层定义新的重名变量隐藏外层变量。</p><p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure></p><p>这样的代码在两种语言中都是错误的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure><p>这样的代码在两种语言中都是正确的。</p><p>二者唯一的差别就是我在最开始的那个例子，Java 在外层 a 的生存期还没结束前不可以定义新的重名变量，而 C++ 可以。</p><hr><h1 id="String-与-string"><a href="#String-与-string" class="headerlink" title="String 与 string"></a>String 与 string</h1><p>String 和 string 分别为 Java 和 C++ 库里的字符串，虽然只是差一个字母大小写，实际上它们有着巨大的差异。<br>string 更像是 char 的数组，它的每个单位都是可以直接这样 <code>s[index]</code> 访问的，而且可以进行修改。<br>String 就没有那么方便了，Java 没有运算符重载只能通过 <code>s.charAt( index )</code> 来转换成 <code>char</code> 再读。<strong>注意！String 没有提供写操作的方法。String 在 Java 中是一种不可修改的字符串。</strong></p><p>这实际上是效率优化上的不同想法，C++ 中每个 string 的对象都独占一块内存空间，Java 的 String 不可修改就可以将多个相同的字符串变量共享一块内存空间，复制操作效率也变得很高。但这样就要在字符串比较时特别注意，Java 的对象变量都是对象的管理者，且 Java 没有运算符重载，如果你有两个 String 的对象 a 和 b ，<code>a == b</code> 只是在判断它们管理的是不是一块内存空间。Java 相同字符串的共享内存空间的分配方案也不是 100% 的，它只是在合适的情况下共享空间，所以两个内容相同的字符串也不一定指向同一个内存空间。它的比较有时相等有时不相等都是很有可能的，所以不要那么做！<br>比较操作 <code>a.equals(b)</code> 使用 String 的 equals 方法即可。</p><p>那到底怎么修改字符串呢？你可以使用 <code>+</code> 运算符和 <code>substring</code> 方法进行拼接和切割字符串最后再赋值给原字符串。但这会有很大的开销，因为中间结果要生成很多不可改变的 String 对象。可以使用 StringBuilder 或者 StringBuffer。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.cppreference.com/w/cpp/language/types" target="_blank" rel="noopener">C++ 基础类型标准</a><br><a href="https://zh.cppreference.com/w/cpp/language/identifiers" target="_blank" rel="noopener">C++ 标识符标准</a><br><a href="https://docs.oracle.com/javase/specs/" target="_blank" rel="noopener">The Java® Language Specification</a><br>Java 核心技术 卷I —— Cay S. Horstmann、Gary Cornell<br>深入理解 Java 虚拟机 —— 周志明</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h1&gt;&lt;p&gt;相比 C++，Java提供了三种注释方式分别为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;//&lt;/code&gt; 单行注释&lt;/li&gt;
&lt;li&gt;&lt;co
      
    
    </summary>
    
      <category term="编程语言 - Java" scheme="https://pazyx.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Java/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="浮点数" scheme="https://pazyx.xyz/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
      <category term="Java" scheme="https://pazyx.xyz/tags/Java/"/>
    
      <category term="整数" scheme="https://pazyx.xyz/tags/%E6%95%B4%E6%95%B0/"/>
    
      <category term="命名规则" scheme="https://pazyx.xyz/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
    
      <category term="String" scheme="https://pazyx.xyz/tags/String/"/>
    
      <category term="string" scheme="https://pazyx.xyz/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>basic_ios 如何穿上它的 bool</title>
    <link href="https://pazyx.xyz/2018/06/29/cin-return/"/>
    <id>https://pazyx.xyz/2018/06/29/cin-return/</id>
    <published>2018-06-28T17:19:17.000Z</published>
    <updated>2018-07-04T17:33:36.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么可以-while-cin-gt-gt-n-？"><a href="#为什么可以-while-cin-gt-gt-n-？" class="headerlink" title="为什么可以 while( cin &gt;&gt; n ) ？"></a>为什么可以 while( cin &gt;&gt; n ) ？</h1><p>这个问题困扰了我很久。每次写出那行代码都在为什么没有输入时它会停，为什么可以这样写，每次写时都有些虚。<br>为了保持我的自信，我想象了很多情况来安抚自己。<br>起初我类比 C 语言，想着应该是 <code>cin</code> 这个鬼东西返回了一个 <code>bool</code> 类型的值。之后在学习了类与对象后，发现 <code>cin</code> 不过是个对象不可能返回什么值。我又给出了新的解释：也许 <code>cin &gt;&gt; n</code> 这个表达式是个 <code>bool</code> 类型的值吧。再之后我看运算符重载时，刚刚的解释也凉了。表达式 <code>cin &gt;&gt; n</code> 的值是 <code>&lt;&lt;</code> 的运算符重载函数返回的一个 basic_istream 类的对象而已。</p><p><strong>我的想象力有一些枯竭了 … …</strong></p><p>直到这几天我在看《深度探索C++对象模型》书时，书中的例子中提到了 basic_ios 的类型转换函数，又让我想起了之前的问题。我查阅了大量资料，大致搞清楚了 究竟为什么可以？和 解决方案的演变过程。</p><h2 id="while-的括号里能放什么？"><a href="#while-的括号里能放什么？" class="headerlink" title="while 的括号里能放什么？"></a>while 的括号里能放什么？</h2><blockquote><p>任何能按语境转换为 bool 的表达式，或带花括号或等号初始化器的单个变量声明。<br>每次迭代前求值此表达式，而若它产出 <code>false</code> ，则退出循环。若此为声明，则每次迭代前求值初始化器，且若被声明变量的值转换为 <code>false</code> ，则退出循环。</p></blockquote><h2 id="什么可以转换为-bool？"><a href="#什么可以转换为-bool？" class="headerlink" title="什么可以转换为 bool？"></a>什么可以转换为 bool？</h2><p>对于原始数据类型，适用于C++ 标准中的<strong>布尔转换</strong>规则<br>规则如下：</p><blockquote><p><strong>整数</strong>、浮点、无作用域枚举、<strong>指针和指向成员指针类型的纯右值</strong>能转换成 <code>bool</code> 类型纯右值。<br>值零（对于整数、浮点和无作用域枚举）、<strong>空指针值和空成员指针值</strong>变为 <code>false</code> 。所有其他值变为 <code>true</code> 。<br><code>std::nullptr_t</code> 类型纯右值，包括 <code>nullptr</code> ，能在直接初始化的语境中转换成 <code>bool</code> 类型纯右值。结果值为 <code>false</code> 。(C++11 起)</p></blockquote><p>对于用户定义类型，则需要给出 类型转换函数 或 以目标类型为参数的构造函数。</p><h2 id="究竟为什么可以？"><a href="#究竟为什么可以？" class="headerlink" title="究竟为什么可以？"></a>究竟为什么可以？</h2><p>我直接给出答案：basic_istream 的基类 basic_ios 类有一个 bool( ) 的运算符重载函数，也就是类型转换函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// C++11 </span></span><br><span class="line"><span class="comment">//若流无错误则为 true ，否则为 false 。</span></span><br></pre></td></tr></table></figure></p><p>这样就解决了上述问题，表达式 <code>cin &gt;&gt; n</code> 的值被转换为 <code>bool</code> 类型当然可以放在 while 的括号内没有任何问题。</p><hr><h1 id="演变过程"><a href="#演变过程" class="headerlink" title="演变过程"></a>演变过程</h1><p>上面的只是 C++11 标准库的解决方案。其实更有意思的是 basic_istream 的对象转换到 bool 类型在实现上的一些历史演变过程。</p><h2 id="operator-int-const"><a href="#operator-int-const" class="headerlink" title="operator int() const;"></a>operator int() const;</h2><p>由于 C++ 早期是没有 <code>bool</code> 类型的，iostream 库的构建者 Jerry Schwarz 希望通过为 basic_ios 类编写一个类型转换函数，提供将 basic_ios 类转换为 <code>int</code> 类型的方式，实现 <code>while( cin &gt;&gt; n )</code>。<br>可这样写后他发现一个问题，就是有人可能写出下面这种代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &lt;&lt; intValue; <span class="comment">// 正确的应该为 cin &gt;&gt; Value;</span></span><br></pre></td></tr></table></figure></p><p>由于 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符很容易让程序员用乱，有的人可能会写出上面的错误代码，但当时的编译器没有报错。<br>因为编译器发现 <code>cin</code> 是没有重载 <code>&lt;&lt;</code> ，但 <code>int</code> 是可以做左移 ( <code>&lt;&lt;</code> ) 的，程序将 basic_ios 的对象转换为 <code>int</code> 又进行了左移操作。这算不上错误，但至少将大部分程序员的错误隐藏了，让人难以定位错误。<br>这个错误之后被戏称为“Schwarz Error”，在这之后 Jerry Schwarz 用下面的函数取代了 <code>operator int () const;</code></p><h2 id="operator-void-const"><a href="#operator-void-const" class="headerlink" title="operator void*() const;"></a>operator void*() const;</h2><p>C++ 的标准中 <code>void*</code> 能隐式转换为 <code>bool</code> 类型，Jerry Schwarz 想到了这种方式，<br>并且还为 basic_ios 类重载了 <code>!</code> 运算符，以支持 <code>while( ! ( cin &gt;&gt; n ) )</code>。<br>这个函数一直维持到 C++11 的出现。</p><h2 id="explicit-operator-bool-const"><a href="#explicit-operator-bool-const" class="headerlink" title="explicit operator bool() const;"></a>explicit operator bool() const;</h2><p>之前的 <code>operato void*() const;</code> 其实是有安全风险的。<br>你可以直接给一个 <code>void*</code> 类型的变量赋一个 basic_ios 类的对象，并且没有任何的错误或警告。这是不安全的，这种类型转换应该是显性的才安全。<br>C++11 改变了隐式转换的一些规则，解决了安全 bool 问题。<br>C++11 之前在类型转换运算符重载函数前加上 <code>explicit</code> 关键字，声明它必须显式使用，以强制类型转换的形式去操作。比如：<code>bool b = (bool)cin</code> 才可以使用类型转换函数，而不能做 <code>bool b = cin</code> 这样的操作。<br>而 C++11 标准对目标为 <code>bool</code> 类型的转换，改变了标准。</p><p><strong>具体标准如下：</strong></p><blockquote><p>下列语境中，期待类型 <code>bool</code> ，而若声明 <code>bool t(e)</code>; 为良式则进行隐式转换（即考虑如 <code>explicit T::operator bool() const;</code> 的隐式转换函数）。我们说这种表达式 <code>e</code> 可按语境转换为 <code>bool</code>。</p><ul><li><code>if</code> 、 <code>while</code> 、 <code>for</code> 的控制表达式；</li><li>内建逻辑运算符 <code>!</code> 、 <code>&amp;&amp;</code> 和 <code>||</code> 的运算数；</li><li>条件运算符 <code>?:</code> 的首个运算数；</li><li><code>static_assert</code>  声明中的谓词；(C++11起)</li><li><code>noexcept</code>  指定符中的表达式；</li><li><code>explicit</code>  指定符中的表达式；(C++20 起)</li><li>契约属性 的谓词。(C++20 起)</li></ul></blockquote><p>这样在非上述语境下转换为 <code>bool</code> 类型就需要显式转换，而在控制表达式中可以自动的隐式转换。增强安全性的同时也保证向前兼容。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">隐式转换</a></li><li><a href="https://zh.cppreference.com/w/cpp/io/basic_ios" target="_blank" rel="noopener">std::basic_ios</a></li><li><a href="https://zh.cppreference.com/w/cpp/io/basic_ios/operator_bool" target="_blank" rel="noopener">std::basic_ios::operator bool</a></li><li><a href="https://zh.cppreference.com/w/cpp/language/explicit" target="_blank" rel="noopener">explicit 指定符</a></li><li><a href="https://zh.cppreference.com/w/cpp/language/while" target="_blank" rel="noopener">while 循环</a></li><li><a href="https://zh.cppreference.com/w/cpp/language/if" target="_blank" rel="noopener">if 语句</a></li><li>《深度探索C++对象模型》—— Stanley B. Lippman</li><li>《C++语言的设计与演化》—— Bjarne Stroustrup</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么可以-while-cin-gt-gt-n-？&quot;&gt;&lt;a href=&quot;#为什么可以-while-cin-gt-gt-n-？&quot; class=&quot;headerlink&quot; title=&quot;为什么可以 while( cin &amp;gt;&amp;gt; n ) ？&quot;&gt;&lt;/a&gt;为什么可以
      
    
    </summary>
    
      <category term="编程语言 - Cpp" scheme="https://pazyx.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Cpp/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="bool" scheme="https://pazyx.xyz/tags/bool/"/>
    
      <category term="basic_ios" scheme="https://pazyx.xyz/tags/basic-ios/"/>
    
      <category term="运算符重载" scheme="https://pazyx.xyz/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="类型转换" scheme="https://pazyx.xyz/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="Cpp演化" scheme="https://pazyx.xyz/tags/Cpp%E6%BC%94%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>System.in</title>
    <link href="https://pazyx.xyz/2018/06/16/System-in/"/>
    <id>https://pazyx.xyz/2018/06/16/System-in/</id>
    <published>2018-06-16T12:18:32.000Z</published>
    <updated>2018-07-21T14:19:57.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scanner-in-new-Scanner-System-in"><a href="#Scanner-in-new-Scanner-System-in" class="headerlink" title=" Scanner in = new Scanner(System.in) "></a><center> Scanner in = new Scanner(System.in) </center></h1><h4 id="2018-6-10"><a href="#2018-6-10" class="headerlink" title=" 2018.6.10 "></a><center> 2018.6.10 </center></h4><p><img src="/2018/06/16/System-in/1.png" alt=""></p><p><img src="/2018/06/16/System-in/2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scanner-in-new-Scanner-System-in&quot;&gt;&lt;a href=&quot;#Scanner-in-new-Scanner-System-in&quot; class=&quot;headerlink&quot; title=&quot; Scanner in = new Scanner(Sy
      
    
    </summary>
    
      <category term="泛 - 纪念" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E7%BA%AA%E5%BF%B5/"/>
    
    
      <category term="ACM" scheme="https://pazyx.xyz/tags/ACM/"/>
    
      <category term="省赛" scheme="https://pazyx.xyz/tags/%E7%9C%81%E8%B5%9B/"/>
    
      <category term="ACM题目" scheme="https://pazyx.xyz/tags/ACM%E9%A2%98%E7%9B%AE/"/>
    
      <category term="纪念" scheme="https://pazyx.xyz/tags/%E7%BA%AA%E5%BF%B5/"/>
    
      <category term="Java" scheme="https://pazyx.xyz/tags/Java/"/>
    
      <category term="Scanner" scheme="https://pazyx.xyz/tags/Scanner/"/>
    
      <category term="System.in" scheme="https://pazyx.xyz/tags/System-in/"/>
    
  </entry>
  
  <entry>
    <title>GCC LD DD 命令选项</title>
    <link href="https://pazyx.xyz/2018/05/11/gcc-ld-dd-cmd/"/>
    <id>https://pazyx.xyz/2018/05/11/gcc-ld-dd-cmd/</id>
    <published>2018-05-11T15:36:31.000Z</published>
    <updated>2018-07-06T20:08:56.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>此篇仅介绍一些我在 ucore 操作系统的 makefile 文件中遇到的命令选项，作为 lab_1 实验报告的一部分。</p><h1 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h1><ul><li>-c 进行预处理、编译、汇编，生成目标代码文件，不进行链接</li><li>-S 仅进行预处理、编译，生成汇编代码文件</li><li>-E 仅进行预处理</li><li><p>-o file 指定输出文件名</p><p><a href="https://paste.ubuntu.com/p/yJmG6rPmXN/" target="_blank" rel="noopener">GCC 8.1 manuals 摘录</a></p></li><li><p>-I (大写 i ) 指定头文件位置</p></li><li>-L (大写 L ) 指定库文件位置</li><li><p>-l (小写 L) 指定库名字</p><p>-I -L -l 选项的详解分别在 <a href="https://gcc.gnu.org/onlinedocs/gcc-8.1.0/gcc/" target="_blank" rel="noopener">GCC 8.1 manuals</a> 的第 200、201、195 页</p></li><li>-Wall 开启大部分警告，列表如下。一些不常用的警告可加 -Wextra 选项配合 - Wall 全部打开</li></ul><table><thead><tr><th>选项</th></tr></thead><tbody><tr><td><code>-Waddress</code></td></tr><tr><td><code>-Warray-bounds=1 (only with ‘-O2’)</code></td></tr><tr><td><code>-Wbool-compare</code></td></tr><tr><td><code>-Wbool-operation</code></td></tr><tr><td><code>-Wc++11-compat -Wc++14-compat</code></td></tr><tr><td><code>-Wcatch-value (C++ and Objective-C++ only)</code></td></tr><tr><td><code>-Wchar-subscripts</code></td></tr><tr><td><code>-Wcomment</code></td></tr><tr><td><code>-Wduplicate-decl-specifier (C and Objective-C only)</code></td></tr><tr><td><code>-Wenum-compare (in C/ObjC; this is on by default in C++)</code></td></tr><tr><td><code>-Wformat</code></td></tr><tr><td><code>-Wint-in-bool-context</code></td></tr><tr><td><code>-Wimplicit (C and Objective-C only)</code></td></tr><tr><td><code>-Wimplicit-int (C and Objective-C only)</code></td></tr><tr><td><code>-Wimplicit-function-declaration (C and Objective-C only)</code></td></tr><tr><td><code>-Winit-self (only for C++)</code></td></tr><tr><td><code>-Wlogical-not-parentheses</code></td></tr><tr><td><code>-Wmain (only for C/ObjC and unless ‘-ffreestanding’)</code></td></tr><tr><td><code>-Wmaybe-uninitialized</code></td></tr><tr><td><code>-Wmemset-elt-size</code></td></tr><tr><td><code>-Wmemset-transposed-args</code></td></tr><tr><td><code>-Wmisleading-indentation (only for C/C++)</code></td></tr><tr><td><code>-Wmissing-attributes</code></td></tr><tr><td><code>-Wmissing-braces (only for C/ObjC)</code></td></tr><tr><td><code>-Wmultistatement-macros</code></td></tr><tr><td><code>-Wnarrowing (only for C++)</code></td></tr><tr><td><code>-Wnonnull</code></td></tr><tr><td><code>-Wnonnull-compare</code></td></tr><tr><td><code>-Wopenmp-simd</code></td></tr><tr><td><code>-Wparentheses</code></td></tr><tr><td><code>-Wpointer-sign</code></td></tr><tr><td><code>-Wreorder</code></td></tr><tr><td><code>-Wreorder</code></td></tr><tr><td><code>-Wrestrict</code></td></tr><tr><td><code>-Wreturn-type</code></td></tr><tr><td><code>-Wsequence-point</code></td></tr><tr><td><code>-Wsign-compare (only in C++)</code></td></tr><tr><td><code>-Wsizeof-pointer-div</code></td></tr><tr><td><code>-Wsizeof-pointer-memaccess</code></td></tr><tr><td><code>-Wstrict-aliasing</code></td></tr><tr><td><code>-Wstrict-overflow=1</code></td></tr><tr><td><code>-Wswitch</code></td></tr><tr><td><code>-Wtautological-compare</code></td></tr><tr><td><code>-Wtrigraphs</code></td></tr><tr><td><code>-Wuninitialized</code></td></tr><tr><td><code>-Wunknown-pragmas</code></td></tr><tr><td><code>-Wunused-function</code></td></tr><tr><td><code>-Wunused-label</code></td></tr><tr><td><code>-Wunused-value</code></td></tr><tr><td><code>-Wunused-variable</code></td></tr><tr><td><code>-Wvolatile-register-var</code></td></tr></tbody></table><ul><li>-fno-builtin 不承认不以 __builtin_ 开头的内建 ( built-in ) 函数。</li><li>-ggdb 生成用于GDB的调试信息</li><li>-gstabs 使用stabs格式生成调试信息，</li><li>-nostdinc 不搜索头文件的标准系统目录</li><li>-fno-stack-protector 禁用堆栈保护机制</li></ul><h1 id="GNU-linker-ld-命令选项"><a href="#GNU-linker-ld-命令选项" class="headerlink" title="GNU linker ( ld ) 命令选项"></a>GNU linker ( ld ) 命令选项</h1><ul><li>-m emulation 模拟仿真链接器 如：-m elf_i386</li><li>-nostdlib 只用在命令行中显式指定的搜索库目录</li><li>-N 设置代码段和数据段均可读写</li><li>-e 指定入口</li><li>-Ttext 连接时重定向初始地址</li></ul><h1 id="dd-命令参数"><a href="#dd-命令参数" class="headerlink" title="dd 命令参数"></a>dd 命令参数</h1><ul><li><strong>if</strong> 代表输入文件。如果不指定if，默认就会从stdin中读取输入。</li><li><strong>of</strong> 代表输出文件。如果不指定of，默认就会将stdout作为默认输出。</li><li><strong>bs</strong> 代表字节为单位的块大小。</li><li><strong>count</strong> 代表被复制的块数。</li><li><strong>/dev/zero</strong> 是一个字符设备，会不断返回0值字节（\0）</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://gcc.gnu.org/onlinedocs/gcc-8.1.0/gcc/" target="_blank" rel="noopener">GCC 8.1 manuals</a></li><li>ld GNU Development Tools ( man ld )</li><li><a href="http://man.linuxde.net/dd" target="_blank" rel="noopener">Linux dd 命令详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;此篇仅介绍一些我在 ucore 操作系统的 makefile 文件中遇到的命令选项，作为 lab_1 实验报告的一部分。&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Linux" scheme="https://pazyx.xyz/tags/Linux/"/>
    
      <category term="C" scheme="https://pazyx.xyz/tags/C/"/>
    
      <category term="gcc" scheme="https://pazyx.xyz/tags/gcc/"/>
    
      <category term="ld" scheme="https://pazyx.xyz/tags/ld/"/>
    
      <category term="dd" scheme="https://pazyx.xyz/tags/dd/"/>
    
      <category term="操作系统" scheme="https://pazyx.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linker" scheme="https://pazyx.xyz/tags/linker/"/>
    
  </entry>
  
  <entry>
    <title>X86 计算机启动流程</title>
    <link href="https://pazyx.xyz/2018/05/03/x86-cpu-boot/"/>
    <id>https://pazyx.xyz/2018/05/03/x86-cpu-boot/</id>
    <published>2018-05-03T11:56:37.000Z</published>
    <updated>2018-07-06T20:09:30.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="硬件加电后寄存器初始值"><a href="#硬件加电后寄存器初始值" class="headerlink" title="硬件加电后寄存器初始值"></a>硬件加电后寄存器初始值</h1><p><img src="/2018/05/03/x86-cpu-boot/硬件加电后寄存器初始值.png" alt=""><br>加电后 CPU 进入实模式（为了兼容早期的8086处理器），实模式下 CPU 只有 1M 的寻址空间，地址计算为: $EA = Base + EIP$</p><p>即加电后的起始地址为 </p><p>$CS:EIP = FFFF0000H+0000FFF0H = FFFFFFF0H$</p><h1 id="从-FFFFFFF0H-到-00007C00H"><a href="#从-FFFFFFF0H-到-00007C00H" class="headerlink" title="从 FFFFFFF0H 到 00007C00H"></a>从 FFFFFFF0H 到 00007C00H</h1><p>FFFFFFF0H 中有什么呢？这里放着的是 CPU 要执行的第一条指令，通常是一条长跳转指令，它会设置 CS 和 EIP 将控制权交给 BIOS 做初始化工作。 BIOS 的执行过程</p><ul><li>硬件自检</li><li>检测关键部件的存在和工作状态</li><li>查找并执行接口卡的 BIOS 进行设备初始化</li><li>执行系统 BIOS 进行系统检测，检测和配置即插即用设备</li><li>更新 CMOS 的扩展系统配置数据 ESCD (系统配置表)</li><li>按指定顺序从软盘、硬盘或光驱启动</li><li>读取主引导扇区代码，拿到主引导记录</li><li>主引导扇区代码读取活动分区的引导扇区代码</li><li>活动分区的引导扇区代码读取文件系统的加载程序到内存中的 00007C00H 处</li><li>将 CS:EIP 设置为 00007C00H 控制权交给加载程序( bootloader )</li></ul><p>至此计算机的控制权已经交给操作系统的 bootloader 程序。</p><h1 id="bootloader-启动过程"><a href="#bootloader-启动过程" class="headerlink" title="bootloader 启动过程"></a>bootloader 启动过程</h1><ul><li>切换到保护模式，启用分段机制</li><li>读磁盘中 ELF 执行文件格式的操作系统到内存</li><li>显示字符串信息</li><li>把控制权交给操作系统</li></ul><h3 id="bootloader-代码"><a href="#bootloader-代码" class="headerlink" title="bootloader 代码"></a>bootloader 代码</h3><p><strong>ucore</strong></p><ul><li><a href="https://paste.ubuntu.com/p/qThFWK4m6w/" target="_blank" rel="noopener">asm.h</a></li><li><a href="https://paste.ubuntu.com/p/S8gpwvjC9s/" target="_blank" rel="noopener">bootasm.S</a></li><li><a href="https://paste.ubuntu.com/p/dsShT59wc3/" target="_blank" rel="noopener">bootmain.c</a></li></ul><p><strong>xv6</strong></p><ul><li><a href="https://paste.ubuntu.com/p/tPfkVHS9gq/" target="_blank" rel="noopener">bootasm.S</a></li><li><a href="https://paste.ubuntu.com/p/rbtsqtkzzW/" target="_blank" rel="noopener">bootmain.c</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;硬件加电后寄存器初始值&quot;&gt;&lt;a href=&quot;#硬件加电后寄存器初始值&quot; class=&quot;headerlink&quot; title=&quot;硬件加电后寄存器初始值&quot;&gt;&lt;/a&gt;硬件加电后寄存器初始值&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/05/03/x86-cpu-boot
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="操作系统" scheme="https://pazyx.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="寄存器" scheme="https://pazyx.xyz/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    
      <category term="CPU" scheme="https://pazyx.xyz/tags/CPU/"/>
    
      <category term="硬件" scheme="https://pazyx.xyz/tags/%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="bootloader" scheme="https://pazyx.xyz/tags/bootloader/"/>
    
      <category term="BIOS" scheme="https://pazyx.xyz/tags/BIOS/"/>
    
      <category term="启动流程" scheme="https://pazyx.xyz/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
      <category term="X86" scheme="https://pazyx.xyz/tags/X86/"/>
    
      <category term="Intel" scheme="https://pazyx.xyz/tags/Intel/"/>
    
  </entry>
  
  <entry>
    <title>AT&amp;T 与 Intel 汇编主要语法差异</title>
    <link href="https://pazyx.xyz/2018/04/23/att-intel-differents/"/>
    <id>https://pazyx.xyz/2018/04/23/att-intel-differents/</id>
    <published>2018-04-23T13:51:49.000Z</published>
    <updated>2018-07-20T09:01:51.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作数顺序"><a href="#操作数顺序" class="headerlink" title="操作数顺序"></a>操作数顺序</h1><p>在一般的二元指令（如 mov、add …）中，两个操作数分为源操作数和目的操作数。AT&amp;T 与 Intel操作数的顺序正好相反。</p><ul><li>“Op-code dst src” in <strong>Intel</strong> syntax.</li><li>“Op-code src dst” in <strong>AT&amp;T</strong> syntax.</li></ul><h1 id="寄存器名称"><a href="#寄存器名称" class="headerlink" title="寄存器名称"></a>寄存器名称</h1><p>AT&amp;T 语法中寄存器名称需要加前缀 ’%’ ，而 Intel 不需要。</p><h1 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h1><p>AT&amp;T 语法中立即数需要加前缀 ’$’ ，对于静态 ‘C’ 变量也一样。Intel的语法标准不需要。</p><h1 id="操作数大小"><a href="#操作数大小" class="headerlink" title="操作数大小"></a>操作数大小</h1><p>AT&amp;T 语法中，操作数大小由指令的最后一个字符决定，“b”、“w” 和 “l” 的指令后缀分别表示字节(8位)、word(16位)和长(32位)内存引用。 Intel 语法中，由操作数的前缀 ’byte ptr’, ’word ptr’, 和 ’dword ptr’ 决定。</p><ul><li>“mov al, byte ptr foo” in <strong>Intel</strong> syntax</li><li>“movb foo, %al” in <strong>AT&amp;T</strong> syntax</li></ul><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p>AT&amp;T 语法中基指寄存器被 ( ) 括起来，而 Intel 语法中使用 [ ] 。 <strong>地址表示：</strong></p><ul><li>section:[base + index*scale + disp] in <strong>Intel</strong> syntax</li><li>section:disp(base, index, scale) in <strong>AT&amp;T</strong> syntax</li></ul><ul><li>section：段地址</li><li>disp：偏移地址</li><li>index：变址</li><li>scale：比例因子</li></ul><p><strong>计算公式：[EA = base + ( index * scale ) + disp]</strong></p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><table><thead><tr><th>Intel Code</th><th>AT&amp;T Code</th></tr></thead><tbody><tr><td><code>mov eax,1</code></td><td><code>movl $1,%eax</code></td></tr><tr><td><code>mov ebx,0ffh</code></td><td><code>movl $0xff,%ebx</code></td></tr><tr><td><code>int 80h</code></td><td><code>int $0x80</code></td></tr><tr><td><code>mov ebx,eax</code></td><td><code>movl %eax,%ebx</code></td></tr><tr><td><code>mov eax,[ecx]</code></td><td><code>movl (%ecx),%eax</code></td></tr><tr><td><code>mov eax,[ebx+3]</code></td><td><code>movl 3(%ebx),%eax</code></td></tr><tr><td><code>mov eax,[ebx+20h]</code></td><td><code>movl 0x20(%ebx),%eax</code></td></tr><tr><td><code>add eax,[ebx+ecx*2h]</code></td><td><code>addl (%ebx,%ecx,0x2),%eax</code></td></tr><tr><td><code>lea eax,[ebx+ecx]</code></td><td><code>leal (%ebx,%ecx),%eax</code></td></tr><tr><td><code>sub eax,[ebx+ecx*4h-20h]</code></td><td><code>subl -0x20(%ebx,%ecx,0x4),%eax</code></td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>GCC-Inline-Assembly-HOWTO : <a href="http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#s3" target="_blank" rel="noopener">http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html#s3</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作数顺序&quot;&gt;&lt;a href=&quot;#操作数顺序&quot; class=&quot;headerlink&quot; title=&quot;操作数顺序&quot;&gt;&lt;/a&gt;操作数顺序&lt;/h1&gt;&lt;p&gt;在一般的二元指令（如 mov、add …）中，两个操作数分为源操作数和目的操作数。AT&amp;amp;T 与 Intel操
      
    
    </summary>
    
      <category term="编程语言 - Assembly" scheme="https://pazyx.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Assembly/"/>
    
    
      <category term="汇编语言" scheme="https://pazyx.xyz/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
      <category term="编程语言" scheme="https://pazyx.xyz/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C++类与对象总结（四）访问属性</title>
    <link href="https://pazyx.xyz/2018/04/15/cpp-class-4/"/>
    <id>https://pazyx.xyz/2018/04/15/cpp-class-4/</id>
    <published>2018-04-15T15:28:33.000Z</published>
    <updated>2018-07-04T17:34:05.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>C++的访问属性我在本系列的第一篇 <a href="http://wszyx.org/2018/01/cpp-class_1/" target="_blank" rel="noopener">C++类与对象总结（一）</a> 已经有了一些介绍，但那时没有介绍继承中的访问属性问题，而且最近对 C++的保护模型也有了一些新的理解。此篇为 <a href="http://wszyx.org/2018/01/cpp-class_1/" target="_blank" rel="noopener">C++类与对象总结（一）</a> 在访问属性方面的补充。</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>在 C++ 语言中有 public、protected 和 private 这三种访问属性。</p><ul><li>public：任何地方都可以访问</li><li>protected：只有这个<strong>类</strong>和它的派生类可以访问</li><li>private：只有这个<strong>类</strong>可以访问</li></ul><p><strong>概念</strong></p><ul><li><strong>1 保护是通过编译时的机制提供的，目标防止发生意外事件，而不是防止欺骗或者有意侵犯。</strong></li><li><strong>2 保护的单位是类，而不是某个对象。</strong></li><li><strong>3 受控制的是访问权，而不是可见性。</strong></li></ul><p>这其中的前两条我已经在 <a href="http://wszyx.org/2018/01/cpp-class_1/" target="_blank" rel="noopener">C++类与对象总结（一）</a> 中讲解并搭配了实验。 讲解清楚第三条之前，我们需要弄清楚什么是可见性。 <strong>可见性：</strong> 这个概念很常见，比如下面的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段程序的输出显然是 2，因为在 main 函数中第 4 行的全局的整数 i 是不可见的，它被第 8 行的局部整数 i 所遮蔽了。 我们再来看这个程序<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAB</span> :</span> <span class="keyword">public</span> AA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">AAB x;</span><br><span class="line">x.fun();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 AA 类中有一个私有的成员 a ，AAB 类 public 继承了 AA 类。显然现在 AAB 类的对象有了一个私有成员 a ，但这个 a 是 AA 类私有的，a 对于 AAB 类的 fun 函数有可能是不可见的，也有可能是不可访问的。</p><ul><li>如果是不可见的：我们可以看到代码中有一个全局变量 a ，不可见的话 fun 函数中会修改全局的 a 。</li><li>如果是不可访问的：那编译应该通不过，因为它在访问修改一个 private 的成员。</li></ul><p>尝试编译得到下面的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp.cpp: In member function &apos;void AAB:fun()&apos;:</span><br><span class="line">temp.cpp:17:3 error: &apos;int AA:a&apos; is private within this context</span><br><span class="line">a = 1;</span><br><span class="line">temp.cpp:9:6: note: declared private here;</span><br><span class="line">int a;</span><br></pre></td></tr></table></figure></p><p>它说 AA 类中的 a 是私有的。所以说这三个关键字<strong>限制的是访问属性而不是可见性</strong>。</p><h2 id="访问权限究竟是在限制谁？"><a href="#访问权限究竟是在限制谁？" class="headerlink" title="访问权限究竟是在限制谁？"></a>访问权限究竟是在限制谁？</h2><p><strong>它是在限制该类后续的使用者，而不是在限制该类现在的设计者！</strong>在后面的组合和继承中的访问权限会出现访问权限的多次限制，很多初学者会分不清楚类内和类外访问权限的区别，所以在这里先说明一下。访问权限我们关心的是我们做的这个类在未来的使用者手中的访问权限。因为三种访问权限均允许在类内访问，类内的访问权限只由其中的成员之前设计访问权限有关，与当前要设计的类赋予的访问权限无关。 类会在哪些地方被使用？</p><ul><li>作为变量被使用</li><li>在其派生类中被使用</li><li>向上造型，是否可以做指针或引用的类型转换</li></ul><h2 id="对象组合中的访问属性问题"><a href="#对象组合中的访问属性问题" class="headerlink" title="对象组合中的访问属性问题"></a>对象组合中的访问属性问题</h2><p>在讲继承中的访问权限之前我想先介绍组合中的访问权限。它们很相近，区别也会在下面讲到。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AAB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">AA b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果在 AAB 类外访问成员 b 中的成员的 a，会怎么样呢？当然是编译错误。因为在访问成员 b 中的成员 a 实际上是在访问成员 b ，而成员 b 是私有的不可访问。 这里访问权限发生了叠加，成员 a 的访问权限 AA 类赋予它的 public 再加上 AAB 类赋予成员 b 的 private 。这里发生了访问权限的叠加。 <strong>访问权限叠加时会怎么样？</strong> 我们再来看一下这三种访问权限的特点，从 public 任何地方都可以访问，上升到 protected 只能在类内和其子子孙孙的类中可以访问，再上升到 private 只能在类内访问。不难发现这三种访问权限的严格程度逐级递增，<strong>在发生访问权限叠加时应选择最严格的访问权限声明去限制其访问权限</strong>。因为访问是逐层进行的。 这就比如你现在需要乘坐很多种交通工具回家，假设一路上要乘坐船、地铁、飞机、汽车。你的行李中有一个打火机，你会想一下坐飞机不让携带打火机而选择不带它，而不会因为坐船、汽车、地铁都可以携带打火机而带上它。因为是否可以携带这些行李取决于你这一路上要接受的所有安检中最严格的那一个。</p><h1 id="继承中的访问属性问题"><a href="#继承中的访问属性问题" class="headerlink" title="继承中的访问属性问题"></a>继承中的访问属性问题</h1><p>常见三种继承就对应于这三种访问权限，继承的分类也由这三种访问属性产生的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> b1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> b1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base3</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a1;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> b1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> c1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">protected</span> Base2, <span class="keyword">private</span> Base3</span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>我们讨论这段代码中 Y 类每个成员的范围属性。 再次提醒初学者！我们讨论的是在之后用到 Y 类时的访问属性，比如：从由 Y 类所定义的对象对其中成员的访问、在 Y 类的派生类中对其成员的访问。初学者可能会想知道在 Y 类内部对这些成员的访问属性问题。这里说明一下<strong>在 Y 类内部访问继承得到的成员是否受限与继承方式无关，只与基类声明的访问属性有关。</strong>比如在 Y 类内部访问成员 c3 是可以的，因为在 Base3 中声明其是 public 的访问属性，而这与它是以 private 方式继承无关。 这就与对象组合中的访问属性问题很相似了，我们再来看一段代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Base1 a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Base2 b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Base3 c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果把 Y 类改写成这个样子，其所有成员的访问属性与之前的 Y 类相同。虽然它们的访问属性是一致的，但因为现在 Y 类不再是三个Base类的派生类了，所以在 Base 类中访问属性为 protected 的成员将不能在 Y 类和其派生类中被访问。 判断一个成员在继承过程中的访问属性时，可以通过将其转变为对象组合时的访问属性问题判断。<strong>注意这样判断的是它究竟是哪种访问属性，而不是它能不能被访问。</strong>能不能被访问应根据访问属性和是否为派生类判断。</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><p><strong>向上造型</strong> 这里要分为两个位置： </p><p>一、在该类的 public 派生类中</p><ul><li>public：可以</li><li>protected：可以</li><li>private：当做无子父类关系，无法做指针或引用的类型转换</li></ul><p>二、在其他位置</p><ul><li>public：可以</li><li>protected：当做无子父类关系，无法做指针或引用的类型转换</li><li>private：当做无子父类关系，无法做指针或引用的类型转换</li></ul><p><strong>内部类问题</strong> 在内部类中对该类中的成员访问与在该类的成员函数访问一致，与内部类声明的访问属性无关。 <strong>模板类问题</strong> 模板类只是声明，编译器会根据每次指定的类型每次定义一个新的类，所以同一个模板是使用两个不同的类型定义的类是属于两个不同的类。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> member;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Method</span><span class="params">(X&lt;U&gt;&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        &amp;y.member;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line">X&lt;<span class="keyword">float</span>&gt; y;</span><br><span class="line">x.Method(x);<span class="comment">// 可以</span></span><br><span class="line">x.Method(y);<span class="comment">// 不可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的 18 和 19 行作为对比，x 的 Method 传入它自己（相同类型）访问其 private 成员不会报错，而 x 的 Method 传入它的模板根据 float 定义的对象 y 再访问其 private 成员则会报错。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;C++的访问属性我在本系列的第一篇 &lt;a href=&quot;http://wszyx.org/2018/01/cpp-class_1/&quot; targ
      
    
    </summary>
    
      <category term="编程语言 - Cpp" scheme="https://pazyx.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Cpp/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="访问属性" scheme="https://pazyx.xyz/tags/%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7/"/>
    
      <category term="对象组合" scheme="https://pazyx.xyz/tags/%E5%AF%B9%E8%B1%A1%E7%BB%84%E5%90%88/"/>
    
      <category term="继承" scheme="https://pazyx.xyz/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="多态" scheme="https://pazyx.xyz/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="可见性" scheme="https://pazyx.xyz/tags/%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>「公告」 近期文章中的错误and博客计划</title>
    <link href="https://pazyx.xyz/2018/04/06/notice-1/"/>
    <id>https://pazyx.xyz/2018/04/06/notice-1/</id>
    <published>2018-04-06T07:38:42.000Z</published>
    <updated>2018-07-06T20:09:01.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最短路算法1——Dijkstra"><a href="#最短路算法1——Dijkstra" class="headerlink" title="最短路算法1——Dijkstra"></a>最短路算法1——Dijkstra</h2><p><strong>描述不清楚：</strong> 在时间复杂度最后的总结中，我之前提到“对于稠密图来说有时不优化比利用最小堆优化更高效”。实际上一般的图，甚至是完全图，利用最小堆优化效率都是优于不优化的。只有一种情况是相反的，就是边确实特别多，是顶点数的高次幂（3以上）的情况。一般来说这种图很少见，完全图的边数也就是顶点数的平方量级的，出现高次幂量级的边只有可能是有存在大量重边，在这里我们处理的是最短路问题我们可以只保留两个顶点之间最短的边，以消除重边。 <strong>补充：</strong> 一般的最短路算法，还有一种问法就是最长路问题。这个可以把所有的边权值都取相反数，初始化时将dist数组初始化为最小值，一般为INT_MIN。将比较符合取相反，结果取相反数。</p><h2 id="C-C-程序中的内存分配"><a href="#C-C-程序中的内存分配" class="headerlink" title="C/C++程序中的内存分配"></a>C/C++程序中的内存分配</h2><p><strong>错误：</strong> 我在“运行中的内存分配回收时机”中提到，代码段、数据段和BSS段在程序刚开始运行时分配。 实际上代码段准确的说是在编译时刻分配，其中的数据写在二进制文件中。数据段和BSS段中的局部静态变量是在第一次运行到定义位置分配，这个我在下文提到。 <strong>错误原因：</strong> 自己想的不够清晰，表达时不够严谨。</p><h2 id="动态规划B1——01背包和动态规划B2——完全背包"><a href="#动态规划B1——01背包和动态规划B2——完全背包" class="headerlink" title="动态规划B1——01背包和动态规划B2——完全背包"></a>动态规划B1——01背包和动态规划B2——完全背包</h2><p><strong>错误：</strong> 存在一些字母大小写问题，引起伪代码歧义。</p><h2 id="串匹配算法2——KMP"><a href="#串匹配算法2——KMP" class="headerlink" title="串匹配算法2——KMP"></a>串匹配算法2——KMP</h2><p><strong>展示问题：</strong> 例子中的字符串对齐我采用了空格和tab对齐，在一些低分辨率的设备上可能对齐会有错误，影响理解。 我本想以图片形式展示，但考虑到例子较多、图片排版不美观等问题，暂时还是以现在这种形式，之后发现什么好的方式我再修改。</p><h1 id="博客计划"><a href="#博客计划" class="headerlink" title="博客计划"></a>博客计划</h1><p>德州扑克的学习笔记一再delay，下周前一定更新。 希望写一些面向对象程序设计的文章。准备写几篇Java面向对象程序设计的文章，关注设计模式和一些实现手法。而C++主要还是想研究一下它的底层实现和准确的标准定义细节问题。结合Java 和 C++学习面向对象的设计模式。 数据结构和算法方面，我的计划是先学习一些对ACM题目实用的算法，对图论和动态规划有些兴趣。基础的数据结构（链表、树…）已经有一定了解，暂时先用STL苟住，之后再研究其各种实现细节。一些高级数据结构广泛了解一下。 题解，一直没更的原因是一直没有写过题了，由于时间不够由于懒惰。之前想写一类题目搞成一整篇发出去。但同一类题我能找到的有限感觉不成篇幅，就先存着草稿了。之后我计划是对于难度较高和有思考难度的题目单独发，简单的算法只给出简单思路和代码写成一整篇打包发。之后我还计划参加一些线上的竞赛，写一些竞赛中的经验体会。 娱乐节目，之前买了一堆可乐准备做个可乐大评测。一直没有写也没有喝，原因在于我一直发现有新的可乐，总想及其后一起体验。我想我估计是集不齐了，实在不行我就开个系列慢慢体验。这个也不是什么大事，我就看看什么时候有时间有心情，写一些吧。 书摘和笔记，我爱什么时候写什么时候写！ 淘宝店计划，店已经开好了，纸还没搞到。大概依旧是性冷淡风，反正也没人买，我就开个玩一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最短路算法1——Dijkstra&quot;&gt;&lt;a href=&quot;#最短路算法1——Dijkstra&quot; class=&quot;headerlink&quot; title=&quot;最短路算法1——Dijkstra&quot;&gt;&lt;/a&gt;最短路算法1——Dijkstra&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;描述不清楚：
      
    
    </summary>
    
      <category term="泛 - 公告" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E5%85%AC%E5%91%8A/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="算法" scheme="https://pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://pazyx.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="背包问题" scheme="https://pazyx.xyz/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
      <category term="01背包" scheme="https://pazyx.xyz/tags/01%E8%83%8C%E5%8C%85/"/>
    
      <category term="公告" scheme="https://pazyx.xyz/tags/%E5%85%AC%E5%91%8A/"/>
    
      <category term="C" scheme="https://pazyx.xyz/tags/C/"/>
    
      <category term="完全背包" scheme="https://pazyx.xyz/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    
      <category term="计划" scheme="https://pazyx.xyz/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="Dijkstra" scheme="https://pazyx.xyz/tags/Dijkstra/"/>
    
      <category term="KMP" scheme="https://pazyx.xyz/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>C/C++程序中的内存分配</title>
    <link href="https://pazyx.xyz/2018/04/03/ccppmemory/"/>
    <id>https://pazyx.xyz/2018/04/03/ccppmemory/</id>
    <published>2018-04-03T09:28:07.000Z</published>
    <updated>2018-07-04T17:33:32.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-C-程序中内存分为五个区域名称及其储存的数据如下"><a href="#C-C-程序中内存分为五个区域名称及其储存的数据如下" class="headerlink" title="C/C++程序中内存分为五个区域名称及其储存的数据如下"></a>C/C++程序中内存分为五个区域名称及其储存的数据如下</h1><ul><li>代码段：可执行代码、字符串常量</li><li>数据段：已初始化的全局变量（包括所有静态变量）、常量</li><li>BSS段：未初始化的全局变量（包括所有静态变量）、常量</li><li>栈：局部变量（包括函数参数）</li><li>堆：动态内存分配</li></ul><p><img src="/2018/04/03/ccppmemory/内存分布图.png" alt=""><br>需要注意这其中的代码段是只读的，其他区域都是可读可写的。 比如这种操作就是错误的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="comment">//char ss[] = "Hello";</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    s[<span class="number">1</span>] = <span class="string">'E'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Unix-like的系统中运行时会产生 <strong>Bus error: 10</strong> 的错误，原因就在于”Hello”为字符串常量它在代码段，它是不可写的。 第 7 行中给出了另一种的写法，这种写法就不会有问题，原因是编译器会给这个数组在栈中分配一块内存把代码段中的”Hello”拷贝过来。</p><h1 id="运行中的内存分配回收时机"><a href="#运行中的内存分配回收时机" class="headerlink" title="运行中的内存分配回收时机"></a>运行中的内存分配回收时机</h1><p>代码段的空间在编译时刻分配，数据段和BSS段中的全局变量在程序开始运行时被分配，而栈、堆和静态变量的内存分配就会相对复杂一些。 </p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a = f(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这段程序中所有的变量都为局部变量，都存放在栈区。栈区的内存分配发生在进大括号时，回收发生在出大括号时。</p><ul><li>变量 a 在 12 行被定义，而它的内存空间已经在 11 行进大括号时就分配好了，内存的回收会在 main 函数结束前的 14 行发生。</li><li>f 函数中的参数变量 b 在 13 行分配空间并初始化，在离开 f 函数时回收空间。</li><li>变量 c 在第 6 行被定义，它的内存分配和回收与变量 a 类似。</li><li>临时变量 b + c 作为返回值在第 13 行调用 f 函数时分配，回收应在出 main 函数结束前。（临时变量的地址，可通过 C++11 的右值引用查看。）</li></ul><h3 id="static局部变量"><a href="#static局部变量" class="headerlink" title="static局部变量"></a>static局部变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样的静态局部变量 c 它的内存分配只会在<strong>第一次</strong>进入 f 函数时分配，内存回收与已初始化的全局变量一样放在全局数据区（数据段）中（若未初始化或初始化的值在编译时刻不可得到则在分配在BSS段中），它的内存回收与其他全局变量一致在程序结束之前回收。<br>关于如何保证局部静态变量只初始化一次的问题可以看这里：<a href="https://www.cnblogs.com/novice-dxx/p/7094690.html" target="_blank" rel="noopener">https://www.cnblogs.com/novice-dxx/p/7094690.html</a> </p><h3 id="vector的内存回收"><a href="#vector的内存回收" class="headerlink" title="vector的内存回收"></a>vector的内存回收</h3><p>vector可以通过 clear() 函数清空，但其内存空间却并没有回收。根据栈中内存回收的机制，我们可以以下面这种方式进行内存回收。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x;</span><br><span class="line">    v.swap(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>在内层括号中定义一个空 vector x 交换两者后，出括号后临时的 vector x会析构并回收内存空间。</strong></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆中的内存用于动态内存分配，动态申请像 C 中的 malloc 和 C++中的 new 运算符都可完成。</p><ul><li>堆中的内存分配只发生在调用内存申请函数或使用 new 运算符时</li><li>堆中的内存回收在 delete 时或程序结束时发生</li></ul><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/WXScjfWQ3z/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/WXScjfWQ3z/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_initialized_0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> global_initialized_1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_0;</span><br><span class="line"><span class="keyword">int</span> global_1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *const_string_0 = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> *const_string_1 = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_initialized_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_initialized_1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_0;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_local_1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> local_0;</span><br><span class="line">    <span class="keyword">int</span> local_1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p_0 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> *p_1 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"代码段:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main = %p\n"</span>,main);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"const_string_0 = %p\n"</span>,const_string_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"const_string_1 = %p\n"</span>,const_string_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"数据段:\n"</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"global_initialized_0 = %p\n"</span>,&amp;global_initialized_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"global_initialized_1 = %p\n"</span>,&amp;global_initialized_1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"static_local_initialized_0 = %p\n"</span>,&amp;static_local_initialized_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"static_local_initialized_1 = %p\n"</span>,&amp;static_local_initialized_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"BSS:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"global_0 = %p\n"</span>,&amp;global_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"global_1 = %p\n"</span>,&amp;global_1);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"static_local_0 = %p\n"</span>,&amp;static_local_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"static_local_1 = %p\n"</span>,&amp;static_local_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"堆:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p_0 = %p\n"</span>, p_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p_1 = %p\n"</span>, p_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"栈:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"local_0 = %p\n"</span>, &amp;local_0);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"local_1 = %p\n"</span>, &amp;local_1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] p_0;</span><br><span class="line">    <span class="keyword">delete</span>[] p_1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Mac OS 64bit 输出结果</strong><br>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/5z3Kb5SZrk/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/5z3Kb5SZrk/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">代码段:</span><br><span class="line">main = 0x1066afb80</span><br><span class="line">const_string_0 = 0x1066afe56</span><br><span class="line">const_string_1 = 0x1066afe5c</span><br><span class="line"></span><br><span class="line">数据段:</span><br><span class="line">global_initialized_0 = 0x1066b0028</span><br><span class="line">global_initialized_1 = 0x1066b002c</span><br><span class="line">static_local_initialized_0 = 0x1066b0038</span><br><span class="line">static_local_initialized_1 = 0x1066b003c</span><br><span class="line"></span><br><span class="line">BSS:</span><br><span class="line">global_0 = 0x1066b0030</span><br><span class="line">global_1 = 0x1066b0034</span><br><span class="line">static_local_0 = 0x1066b0040</span><br><span class="line">static_local_1 = 0x1066b0044</span><br><span class="line"></span><br><span class="line">堆:</span><br><span class="line">p_0 = 0x7fcd6f4028f0</span><br><span class="line">p_1 = 0x7fcd6f402a80</span><br><span class="line"></span><br><span class="line">栈:</span><br><span class="line">local_0 = 0x7ffee95507e4</span><br><span class="line">local_1 = 0x7ffee95507e0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C-C-程序中内存分为五个区域名称及其储存的数据如下&quot;&gt;&lt;a href=&quot;#C-C-程序中内存分为五个区域名称及其储存的数据如下&quot; class=&quot;headerlink&quot; title=&quot;C/C++程序中内存分为五个区域名称及其储存的数据如下&quot;&gt;&lt;/a&gt;C/C++程序
      
    
    </summary>
    
      <category term="编程语言 - Cpp" scheme="https://pazyx.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Cpp/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="C" scheme="https://pazyx.xyz/tags/C/"/>
    
      <category term="内存分配" scheme="https://pazyx.xyz/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>最短路算法1——Dijkstra</title>
    <link href="https://pazyx.xyz/2018/03/23/dijkstra/"/>
    <id>https://pazyx.xyz/2018/03/23/dijkstra/</id>
    <published>2018-03-22T18:31:41.000Z</published>
    <updated>2018-07-04T17:34:17.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最短路径问题有众多的算法，对于无权图的最短路径 <a href="http://wszyx.org/2018/02/dfs-bfs/" target="_blank" rel="noopener">DFS与BFS</a> 就可以轻松解决。而对于有权图来说就相对复杂一些，接下来要介绍的就是一种求有权图的单源最短路径的算法—— Dijkstra 算法。需要注意的是这里的 Dijkstra 算法要求图中<strong>不能出现负值圈</strong>。</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>无权图可以认为是特殊的有权图，只是它的边权全都为 1 。想一想 BFS 是怎么找到最短路径的，它是通过一层一层的扩展，按照非递减的顺序去收录每个点。Dijkstra 算法的思想也是按照非递减的顺序收录每个点，最终找到最短路径。 与 BFS 不同的是，有权图中什么算一层呢？实际上 BFS 说是按层扩展，另一种理解可以是按照距离的从近到远去扩展。Dijkstra 算法就是每次收录一个距离最近且未被收录的点。这里还有一些小问题，比如收进来的点会不会影响其他点到起始点的距离？怎么初始化？怎么找出最近的点？我们先上代码之后给出答案。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><strong>代码：</strong><br>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/WjHPFqMqpc/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/WjHPFqMqpc/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[MAX_N][MAX_N];  <span class="comment">//  使用邻接矩阵表示图</span></span><br><span class="line"><span class="keyword">bool</span> collected[MAX_N];  <span class="comment">//  每个结点是否被收录</span></span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];        <span class="comment">//  每个结点到起始点的距离</span></span><br><span class="line"><span class="keyword">int</span> path[MAX_N];        <span class="comment">//  最短路径中的每个结点的上一个节点的下标</span></span><br><span class="line"><span class="keyword">int</span> n;                  <span class="comment">//  结点个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>             <span class="comment">//  初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        collected[i] = <span class="literal">false</span>;</span><br><span class="line">        dist[i] = INT_MAX;</span><br><span class="line">        path[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="built_in">map</span>[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    collected[start] = <span class="literal">true</span>;    <span class="comment">//将起始点收录</span></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[start][i] != <span class="number">-1</span>)&#123;</span><br><span class="line">            dist[i] = <span class="built_in">map</span>[<span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> min_index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min &gt; dist[i] &amp;&amp; !collected[i])&#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">                min_index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;           <span class="comment">//34-41行为找出最近的未被收录的点</span></span><br><span class="line">        <span class="keyword">if</span>(min_index == <span class="number">-1</span>)&#123;    <span class="comment">//如果找不到，跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        collected[min_index] = <span class="literal">true</span>;    <span class="comment">//将该点收录，</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;   <span class="comment">//遍历该点的邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[min_index][i] != <span class="number">-1</span> &amp;&amp; !collected[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = dist[min_index] + <span class="built_in">map</span>[min_index][i];</span><br><span class="line">                <span class="keyword">if</span>(temp &lt; dist[i])&#123;</span><br><span class="line">                    dist[i] = temp;</span><br><span class="line">                    path[i] = min_index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>dist 数组中保存着什么？它保存的是从起点开始经过已被收录的点到达每个点的最短距离，初始状态下没有任何点被收录所以全为正无穷。 当程序将一个最近的点收录进来时，该点是有可能会影响其他的点到起始点的距离。<br><img src="/2018/03/23/dijkstra/1.png" alt=""><br>比如这个图，从1走到3。我们先收录了1点，更新 2 的距离为 1 ，3 的距离为5，下一步我们将收录 2 ，收录之后就会影响到它的<strong>邻接点</strong>（也就是 3 ）的距离。我们会把 3 的距离更新为 2 。这就是 47-55 行的意义。 <strong>初始化问题：</strong> 一开始将所有点的距离初始化为正无穷，将路径数组初始化为-1。如果最终某点的距离仍为正无穷或路径数组仍为-1，说明该点到起始点之间不连通。 <strong>重边问题：</strong>如果图用邻接表来表示的话不会有重边问题，而邻接矩阵的话如果两点间有很多条边，它只会保存最后插入的边。如果是最短路问题的话我们可以在插入边时检查当前这条边的权重是否小于之前插入的边，是则插入覆盖，否则不插入当前边。 <strong>输出路径问题：</strong>一般的可以用一个栈依次压入 path 数组中的值，再将它们依次弹出输出。有些题目给的是一个无向图且只问起点与终点的最短路径，这样的话我们可以颠倒起点和终点，path 数组也就被颠倒就不用栈就输出最短路径了。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>我们上面的代码最浪费时间的就是找出未收录的点中最近的点的操作，每次都要遍历所有的点去查找。我们可以用一个优先队列或最小堆去优化它。接下来我先给出利用优先队列优化后的代码，此代码将用邻接表来保存图以区别于之前的代码，帮助大家更好的了解 Dijkstra 算法的各种实现。</p><h3 id="利用STL库中的优先队列优化"><a href="#利用STL库中的优先队列优化" class="headerlink" title="利用STL库中的优先队列优化"></a>利用STL库中的优先队列优化</h3><p><strong>代码：</strong><br>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/ttngrNMyf7/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/ttngrNMyf7/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> next, weight;&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt;G[MAX_N];   <span class="comment">//邻接表表示的图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];</span><br><span class="line"><span class="keyword">int</span> path[MAX_N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;P, <span class="built_in">vector</span>&lt;P&gt;, greater&lt;P&gt; &gt;que;   </span><br><span class="line">    <span class="comment">//建立一个以小数值为高优先级的的优先队列</span></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    que.push(P(<span class="number">0</span>,start));   <span class="comment">//将起始点入队</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;    </span><br><span class="line">    <span class="comment">//如果队列为空，说明所有点都已被收录，结束该算法</span></span><br><span class="line">        P p = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">int</span> v = p.second;</span><br><span class="line">        <span class="keyword">if</span>(dist[v] &lt; p.first)&#123;  </span><br><span class="line">        <span class="comment">//如果找到的节点不符合非递减规则，找下一个队列中的节点</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class="line">            edge e = G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(dist[e.next] &gt; dist[v] + e.weight)&#123;</span><br><span class="line">                dist[e.next] = dist[v] + e.weight;</span><br><span class="line">                path[e.next] = v;</span><br><span class="line">                que.push(P(dist[e.next],e.next));   </span><br><span class="line">                <span class="comment">//将邻接点入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们看到跟之前的代码逻辑可能有一些不太一样，按照之前的逻辑while循环应该按下面的方式实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!que.empty())&#123;    </span><br><span class="line"><span class="comment">//如果队列为空，说明所有点都已被收录，结束该算法</span></span><br><span class="line">    P p = que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">int</span> v = p.second;</span><br><span class="line">    collected[v] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class="line">        edge e = G[v][i];</span><br><span class="line">        <span class="keyword">if</span>(!collected[e.next] </span><br><span class="line">        &amp;&amp; dist[e.next] &gt; dist[v] + e.weight)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[e.next] = dist[v] + e.weight;</span><br><span class="line">            path[e.next] = v;</span><br><span class="line">            <span class="keyword">if</span>(!in_que[e.next])&#123;</span><br><span class="line"><span class="comment">//在定义一个全局的bool数组标记点是否入队</span></span><br><span class="line">            que.push(P(dist[e.next],e.next));</span><br><span class="line">            <span class="comment">//将邻接点入队</span></span><br><span class="line">                in_que[e.next] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是很常见的一种错误优化，我之前也写出过这样的代码。错误是因为已入队的元素是无法实时更新，无法保证更新 dist 数组时同时更新队列中的元素，所以我们改为允许结点多次入队不收录它，像之前的代码虽然效率有所下降但保证了代码的正确性。</p><h3 id="利用最小堆优化"><a href="#利用最小堆优化" class="headerlink" title="利用最小堆优化"></a>利用最小堆优化</h3><p>使用优先队列优化时遇到的问题是不能及时更新队列中元素的信息，而最小堆可以快速的查找删除再插入可以随时更新想更新的结点的信息，解决之前使用STL库中的优先队列所遇到的问题。<br><strong>代码：</strong><br>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/thKfPjDRvd/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/thKfPjDRvd/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span> <span class="keyword">int</span> next, weight;&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt;G[MAX_N];   <span class="comment">//邻接表表示的图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];</span><br><span class="line"><span class="keyword">int</span> path[MAX_N];</span><br><span class="line"><span class="keyword">bool</span> collected[MAX_N];  <span class="comment">//标记每个顶点是否被收录</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;P, less&lt;P&gt; &gt; min_heap;  </span><br><span class="line">    <span class="comment">//用 set 来伪实现一个小根堆，并具有映射二叉堆的功能。</span></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    min_heap.insert(make_pair(<span class="number">0</span>, start));</span><br><span class="line">    collected[start] = <span class="literal">true</span>;   </span><br><span class="line">    <span class="keyword">while</span>(min_heap.size())&#123;    </span><br><span class="line">    <span class="comment">//如果堆为空，说明所有点都已被收录，结束该算法</span></span><br><span class="line">        <span class="keyword">auto</span> iter = min_heap.begin();</span><br><span class="line">        <span class="keyword">int</span> v = iter-&gt;second;</span><br><span class="line">        min_heap.erase(*iter);</span><br><span class="line">        collected[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class="line">            edge e = G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(!collected[e.next] </span><br><span class="line">            &amp;&amp; dist[e.next] &gt; dist[v] + e.weight)</span><br><span class="line">            &#123;</span><br><span class="line">                min_heap.erase(make_pair(dist[e.next], e.next));    </span><br><span class="line">                <span class="comment">//删除之前插入堆中的数据</span></span><br><span class="line">                dist[e.next] = dist[v] + e.weight;</span><br><span class="line">                path[e.next] = v;</span><br><span class="line">                min_heap.insert(make_pair(dist[e.next], e.next));   </span><br><span class="line">                <span class="comment">//更新之后重修插入该结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h1><p>V 代表结点的个数，E 代表边的个数。</p><ul><li>完全没有优化的算法：每个顶点被收录一次，所以外层的while循环是O( V )的，while中每次需要遍历一次所有的顶点，又是一个 O( V ) 的扫描。再加上每条边都要被访问一次时间复杂度为 O( V^2 + E )。</li><li>利用优先队列优化：虽然节点会多次入队，但每条边最多导致一次入队，所以其时间复杂度为 O( E*logE )。</li><li>利用最小堆优化：利用最小堆之后我们不用在内层需要进行O( V )的扫描了，获得最近的结点的操作时间复杂度变为 O( logV )，而每次更新 dist 数组的操作因为要删除再插入堆中复杂度从 O( 1 ) 变为 O( logV )。总体的时间复杂度为 O( V*logV + E*logV )。</li></ul><p><strong>对于一个稀疏图来说利用最小堆做优化会效率会高很多，而对于一个稠密图来说两者效率是差不多的。利用优先队列的优化方式编程复杂度相对最小堆优化的方式会低一些，方便快速实现该算法。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;最短路径问题有众多的算法，对于无权图的最短路径 &lt;a href=&quot;http://wszyx.org/2018/02/dfs-bfs/&quot; ta
      
    
    </summary>
    
      <category term="算法" scheme="https://pazyx.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="https://pazyx.xyz/tags/ACM/"/>
    
      <category term="算法" scheme="https://pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="优化" scheme="https://pazyx.xyz/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="Dijkstra" scheme="https://pazyx.xyz/tags/Dijkstra/"/>
    
      <category term="优先队列" scheme="https://pazyx.xyz/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
      <category term="最短路径" scheme="https://pazyx.xyz/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
      <category term="最小堆" scheme="https://pazyx.xyz/tags/%E6%9C%80%E5%B0%8F%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」Effective C++ 读书笔记（一）</title>
    <link href="https://pazyx.xyz/2018/03/16/effective-cpp01/"/>
    <id>https://pazyx.xyz/2018/03/16/effective-cpp01/</id>
    <published>2018-03-16T15:28:25.000Z</published>
    <updated>2018-07-20T12:30:41.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h1><p>这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）。</p><h1 id="让自己习惯C"><a href="#让自己习惯C" class="headerlink" title="让自己习惯C++"></a>让自己习惯C++</h1><h2 id="条款01：视-C-为语言联邦"><a href="#条款01：视-C-为语言联邦" class="headerlink" title="条款01：视 C++ 为语言联邦"></a>条款01：视 C++ 为语言联邦</h2><p>C++ 是一个多重范型编程语言，一个同时支持过程形式、对象形式、函数形式、泛型编程、元编程形式的语言。 将 C++ 的理解为一个由相关语言组成的联邦而非单一语言。记住以下四个次语言你就会发现C++p容易理解很多。 C++ 主要的四种次语言：</p><ul><li><strong>C：</strong>C++以C为基础，基本的语句、基础数据类型、预处理器等等都来自于 C，许多时候 C++ 对问题的解法其实不过就是高级的C语言解法。</li><li><strong>Objective-Oriented C++：</strong>C++ 诞生之初就是想在 C 语言高效的基础上，增加 Simula 语言的特性。Class、封装、继承、多态、virtual 函数等等，改善了 C 的代码可读性、并发性、编译错误的提示等等。</li><li><strong>Template C++：</strong>泛型编程，大多数程序员经验最少的部分。它带来的崭新的编程范型，所谓的模板元编程。TMP 相关规则很少与 C++ 主流编程互相影响。</li><li><strong>STL：</strong>STL 是个 Template 程序库。它对容器、迭代器、算法、函数对象的规约有极佳的紧密配合与协调。STL有自己特殊的办事方式，当你同 STL 一起工作，你必须遵守它的规约。</li></ul><ul><li>C++高效编程守则视状况而变化，取决于你使用C++的哪一部分。</li></ul><h2 id="条款02：尽量以-const、enum、inline-替换-define"><a href="#条款02：尽量以-const、enum、inline-替换-define" class="headerlink" title="条款02：尽量以 const、enum、inline 替换 #define"></a>条款02：尽量以 const、enum、inline 替换 #define</h2><p>降低对编译预处理的使用。 #define 的缺点：</p><ul><li>让编译器的错误提示不易定位</li><li>缺乏类型检查</li><li>不重视作用域，除非在某处 #undef，不能用来定义class专属常量，不能提供任何封装</li><li>未记入符号表，增大目标代码文件</li></ul><p>旧式的编译器不支持“in-class 初值设定”，可以用枚举来替换常量。 相比 const，enum 更像 #define，可以对 const 常量取地址，而不可以对 enum 的地址。如果不想用指针和引用值指向你的某个常量，enum 可以帮助你实现这个约束。 对于宏函数，可读性差、写宏函数时需要小心注意带上很多括号，一不小心就会出现难以检查的错误。我们可以使用 inline 关键词代替宏函数，提高代码可读性和安全性。  </p><ul><li>对于单纯常量，最好以 const 对象或 enums 代替 #defines。</li><li>对于形似函数的宏，最好改用 inline 函数替换 #defines。</li></ul><h2 id="条款03：尽可能使用-const"><a href="#条款03：尽可能使用-const" class="headerlink" title="条款03：尽可能使用 const"></a>条款03：尽可能使用 const</h2><p>令函数的返回值为 const ，往往可以降低因用户错误而造成的意外，而又不至于放弃安全性和高效性。 两个成员函数如果只是常量性不同可以被重载，传入函数参数是 const 和非 const 时要区分处理，如在重载运算符 [] 时，非 const 要返回其单元的引用，const 时要返回其单元的 const 引用。 成员函数是 const 意味着它在某种程度上是不可以修改对象中的任何成员变量，但对于成员变量是指针时，它不能保证该成员函数不修改指针成员指向位置的数据。 可以使用 mutable（可变的）释放掉非 staic 成员变量的 bitwise constness 约束。 为 const 重载的函数，会造成代码复制的情况。可以通过单独写一个私有函数运行不冲突的部分，只重载与 const 相关的部分。也可以通过在 non-const里用 const_cast 去除 const 属性再返回的方式减少代码复制。但不要用在 const 函数中调 non-const 函数再返回的方式实现，这样会违背你在 const 版本中绝不改变其对象的逻辑状态的承诺，因为 non-const 版本没有做过此承诺。</p><ul><li>将某些东西声明为 const 可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数主体。</li><li>编译器强制实施 bitwise constness ，但你变形程序时应该使用“概念上的常量性”（conceptual constness）。</li><li>当 const 和 non-const 成员函数有着实质等价的实现时，令 non-const 版本调用 const 版本可避免代码重复。</li></ul><h2 id="条款04：确定对象被使用前已先被初始化"><a href="#条款04：确定对象被使用前已先被初始化" class="headerlink" title="条款04：确定对象被使用前已先被初始化"></a>条款04：确定对象被使用前已先被初始化</h2><p>不要混淆赋值和初始化，一定要在初始化列表中初始化成员。在我之前的博文 <a href="http://wszyx.org/2018/02/cpp-class2/" target="_blank" rel="noopener">C++类与对象总结（二）构造函数</a> 中对构造函数中的赋值和初始化问题有一定的解释。 继承关系的初始化顺序：基类（base classes）更早于其派生类（derived classes）被初始化。 对于某个编译单元内的某个 non-local static 对象的初始化动作使用了另一个编译单元内的某个 non-local static 对象，它所用到的这个对象可能尚未被初始化，因为 C++ 对“定义于不同编译单元内的 non-local static  对象” 的初始化次序并无明确定义。可以将有初始化依赖的几个 non-local static 对象放在一个编译单元解决。 书中的解决方案为：将每个 non-local static 对象搬到自己的专属函数内（该对象在此函数内被声明为 static ）。这些函数返回一个 reference 指向它所含的对象。我们将这些函数称为 reference-returning 函数。</p><ul><li>为内置型对象进行手工初始化，因为 C++ 不保证初始化它们。</li><li>构造函数最好使用成员初值列，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在 class 中的声明次序相同。</li><li>为免除“跨编译单元之初始化次序”问题，请以 local staic 对象替换 non-local static 对象。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注意！&quot;&gt;&lt;a href=&quot;#注意！&quot; class=&quot;headerlink&quot; title=&quot;注意！&quot;&gt;&lt;/a&gt;注意！&lt;/h1&gt;&lt;p&gt;这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）
      
    
    </summary>
    
      <category term="泛 - 笔记" scheme="https://pazyx.xyz/categories/%E6%B3%9B-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://pazyx.xyz/tags/Cpp/"/>
    
      <category term="读书" scheme="https://pazyx.xyz/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="笔记" scheme="https://pazyx.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective C++" scheme="https://pazyx.xyz/tags/Effective-C/"/>
    
      <category term="多重范型" scheme="https://pazyx.xyz/tags/%E5%A4%9A%E9%87%8D%E8%8C%83%E5%9E%8B/"/>
    
      <category term="const" scheme="https://pazyx.xyz/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>求质数表3——增量式筛法</title>
    <link href="https://pazyx.xyz/2018/03/14/isprimes-3/"/>
    <id>https://pazyx.xyz/2018/03/14/isprimes-3/</id>
    <published>2018-03-14T15:27:26.000Z</published>
    <updated>2018-07-04T17:34:44.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="增量式筛法"><a href="#增量式筛法" class="headerlink" title="增量式筛法"></a>增量式筛法</h2><p>之前的筛法都需要事先指定一个N，然后求N以内的质数，但没办法求N以上的质数。我们想要一种算法不用事先指定N一直求下去，如试除法就是增量式运行的。 增量式算法可以在简易欧拉筛进行改进的。<br><img src="/2018/03/14/isprimes-3/1.jpg" alt=""><br>简易欧拉筛限制它不能增量式运行的问题是在于它的空间。比如增量式运行筛选到 11 时你需要划掉 121 ，这样你就需要维持 N^2 的空间，这样就很成问题，想象如果 N 到1亿时，那空间将是不可接受的。<br><img src="/2018/03/14/isprimes-3/2.jpg" alt=""><br>我们将不再枚举p和f，而是依次检查每个数，检查到一个数时划去下一个数，并再下一个数处做标记。比如我们检查到 10 ，我们通过某种方式计算出它的下一个要被划掉的数为 15 ，我们划掉 15 并在 15 处做标记，保证检查到 15 时我们可以轻松的算出 25 。由 <a href="https://en.wikipedia.org/wiki/Bertrand%27s_postulate" target="_blank" rel="noopener">Bertrand’s postulate</a> 这个数学结论得出相邻两个质数相差不会超过两倍，所以我们只需将数组维持在当前检查的数的两倍即可。这样空间复杂度就将为了 O(N) 。 这个标记需要干什么，它需要帮助我们在拿到一个数时迅速找出它的p和f。我们用一个数组保存当前被检查的数的最小质因子在质数表的位置即可。这样比如我们在拿到 15 时，我们找到它的最小质因子p为 3 ，15/3 算出 f 为 5，我们就可以用 f 乘下一个质数去找到 25 划掉它并继续传递标记了。标记从每个偶数处（因为第一个素数为 2 ）产生的，到列末尾消失（p 最大增长到 f 的最小质因子）。 </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/DtN2WPpppf/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/DtN2WPpppf/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bengalloun</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nPrimes = <span class="number">0</span>;</span><br><span class="line">    flag[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        flag[i * <span class="number">2</span> - <span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//假设它为质数</span></span><br><span class="line">        flag[i * <span class="number">2</span>] = <span class="literal">false</span>;    <span class="comment">//偶数一定为合数</span></span><br><span class="line">        lpfindex[i * <span class="number">2</span>] = <span class="number">0</span>;    <span class="comment">//建立列首标记</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">            primes[nPrimes++] = i;  <span class="comment">//如果还没被筛掉加入质数表</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;      <span class="comment">//如果是合数</span></span><br><span class="line">            <span class="keyword">int</span> u = lpfindex[i];</span><br><span class="line">            <span class="keyword">int</span> p = primes[u];  </span><br><span class="line">            <span class="keyword">int</span> f = i / p;      <span class="comment">//计算p和f</span></span><br><span class="line">            <span class="keyword">if</span>(f % p != <span class="number">0</span>)&#123;     <span class="comment">//如果没有到列尾就传递标记</span></span><br><span class="line">                <span class="keyword">int</span> j = primes[u + <span class="number">1</span>] * f;</span><br><span class="line">                flag[j] = <span class="literal">false</span>;</span><br><span class="line">                lpfindex[j] = u + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h3><p>与思想与简易欧拉筛相同，依然为O(N)。因为要为增量式运行做准备实际要比简易欧拉筛多花一倍的时间。 </p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>flag和lpfindex数组都为O(N)的复杂度。总体空间复杂度为O(N)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;增量式筛法&quot;&gt;&lt;a href=&quot;#增量式筛法&quot; class=&quot;headerlink&quot; title=&quot;增量式筛法&quot;&gt;&lt;/a&gt;增量式筛法&lt;/h2&gt;&lt;p&gt;之前的筛法都需要事先指定一个N，然后求N以内的质数，但没办法求N以上的质数。我们想要一种算法不用事先指定N一直求下去
      
    
    </summary>
    
      <category term="算法" scheme="https://pazyx.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="质数" scheme="https://pazyx.xyz/tags/%E8%B4%A8%E6%95%B0/"/>
    
      <category term="求质数表" scheme="https://pazyx.xyz/tags/%E6%B1%82%E8%B4%A8%E6%95%B0%E8%A1%A8/"/>
    
      <category term="优化" scheme="https://pazyx.xyz/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="增量式筛法" scheme="https://pazyx.xyz/tags/%E5%A2%9E%E9%87%8F%E5%BC%8F%E7%AD%9B%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>求质数表2——线性筛法</title>
    <link href="https://pazyx.xyz/2018/03/09/isprimes-2/"/>
    <id>https://pazyx.xyz/2018/03/09/isprimes-2/</id>
    <published>2018-03-09T02:20:01.000Z</published>
    <updated>2018-07-04T17:34:41.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合数的标准分解"><a href="#合数的标准分解" class="headerlink" title="合数的标准分解"></a>合数的标准分解</h1><p>每个合数可以分解质因数，对于60，最小质因子（LPF）为 2，最大质因子（GPF）为 5。 根据 LPF 和 GPF，可以将 60 分解为 2 <em> 30 或 5 </em> 12。这里的30为LPF的补，12为GPF的补。</p><h1 id="欧拉筛"><a href="#欧拉筛" class="headerlink" title="欧拉筛"></a>欧拉筛</h1><p>对于60之前的埃氏筛法最大的问题就是在 2、3、5 都会划去一次，浪费了很多时间。欧拉筛的改进方法就是保证每个合数只被划掉一次。 枚举最小质因子（LPF），把它与未筛掉的各数相乘，筛掉乘积。 那怎么找到未筛掉的数呢？我们不能再用一个 bool 数组来保存是否被筛掉了，因为那样你依然是在遍历数组看看那个数是否被划掉，如果没有的话就将它与最小质因子的积划掉。这样还是遍历了所有的数，我们只想要遍历没有被划掉的数。 我们需要一个数据结构可以高效的进行遍历、查找、删除操作。链表的遍历和删除都可以满足我们的需求，但查找过慢。 我们用数组模拟链表来保证这三个操作的高效。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prev[MAX_N + <span class="number">2</span>];<span class="comment">//保存每个节点的前一个节点的值</span></span><br><span class="line"><span class="keyword">int</span> next[MAX_N + <span class="number">2</span>];<span class="comment">//保存每个节点的后一个节点的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;<span class="comment">//初始化</span></span><br><span class="line">prev[i] = i - <span class="number">1</span>;</span><br><span class="line">prev[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next[prev[x]] = next[x];</span><br><span class="line">prev[next[x]] = prev[x];<span class="comment">//删除 x 节点的操作</span></span><br></pre></td></tr></table></figure></p><p>数组模拟的链表的实现及相关操作<br>解决“链表”问题后，我们在埃氏筛法的基础上改进划掉的操作就可以。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/CCWTJHjSYJ/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/CCWTJHjSYJ/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prev[MAX_N + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> next[MAX_N + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        prev[i] = i - <span class="number">1</span>;</span><br><span class="line">        prev[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nPrimes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> p = <span class="number">2</span>; p * p &lt;= N; p = next[p])&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> f = p; p * f &lt;= N; f = next[f])&#123;</span><br><span class="line">            <span class="keyword">int</span> x = p * f;</span><br><span class="line">            next[prev[x]] = next[x];</span><br><span class="line">            prev[next[x]] = prev[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> p = <span class="number">2</span>; p &lt;= N; p = next[p])&#123;</span><br><span class="line">        primes[nPrimes++] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但此代码有个大BUG，因为我们在选定一个 p 时想划去的是<strong>当时</strong>在它之后<strong>没有被划掉的数与它的积</strong>，但选定 p 是在找没有被划掉的数之前的。会发生这样的事情，比如我们 p 为 2，我们划掉了 4，那我们就没办法通过 2 * 4 划掉 8。 为了解决这个问题，人们想出了两种解决方案。</p><ul><li>第一种：从大到小的去划掉需要划掉的数，这个方案需要解决的问题是需要定位链表的最后一个节点。</li><li><p>第二种：为什么 8 不能通过 2 <em> 4 划掉，因为 8 存在多个质因子为 2，所以我们在划去p\</em>f时，可以顺便划掉p*p*f，p*p*p*f…… 解决。</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/4cPKvKw6ys/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/4cPKvKw6ys/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prev[MAX_N + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> next[MAX_N + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        prev[i] = i - <span class="number">1</span>;</span><br><span class="line">        prev[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nPrimes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> p = <span class="number">2</span>; p * p &lt;= N; p = next[p])&#123;</span><br><span class="line">        primes[nPrimes++] = p; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> f = p;</span><br><span class="line">        <span class="keyword">while</span>(p * next[f] &lt;= N)&#123;    <span class="comment">//遍历链表找到最大的f</span></span><br><span class="line">            f = next[f];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(f &gt;= p)&#123;              <span class="comment">//反向遍历链表划去p * f</span></span><br><span class="line">            <span class="keyword">int</span> x = p * f;</span><br><span class="line">            next[prev[x]] = next[x];</span><br><span class="line">            prev[next[x]] = prev[x];</span><br><span class="line">            f = prev[f];   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>Ubuntu Pastebin :<a href="https://paste.ubuntu.com/p/rnjmh7vTPF/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/rnjmh7vTPF/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prev[MAX_N + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> next[MAX_N + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        prev[i] = i - <span class="number">1</span>;</span><br><span class="line">        prev[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nPrimes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> p = <span class="number">2</span>; p * p &lt;= N; p = next[p])&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> f = p; p * f &lt;= N; f = next[f])&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> x = p * f; ; x *= p)&#123;</span><br><span class="line">                next[prev[x]] = next[x];</span><br><span class="line">                prev[next[x]] = prev[x];</span><br><span class="line">                <span class="keyword">if</span>(x &gt; N / p) <span class="keyword">break</span>;    <span class="comment">//x增长较快，防止x溢出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> p = <span class="number">2</span>; p &lt;= N; p = next[p])&#123;</span><br><span class="line">        primes[nPrimes++] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>每个数只被划掉一次所以是O(N)。但划掉的速度要通过链表，<strong>其实导致速度通常还不如埃氏筛法</strong>。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>只开了两个链表的数组和一个primes数组，O(N)。</p><h1 id="简易欧拉筛"><a href="#简易欧拉筛" class="headerlink" title="简易欧拉筛"></a>简易欧拉筛</h1><p>再考虑欧拉筛的缺点，它时间复杂度已经达到线性，但链表操作太慢。怎么可以不使用链表实现欧拉筛呢？ 我们为什么要用到链表？因为 f 是动态变化的。我们换一种方式，考虑枚举<strong>LPF的补</strong>也就是先枚举 p （从质数表primes数组中取即可）再枚举 f 。根据LPF的定义我们给定 p 后，f 只需枚举到第一个整除 p 的数。 </p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/xfVS3ctQWr/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/xfVS3ctQWr/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[MAX_N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simple_euler</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="literal">true</span>, (N + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line">    <span class="keyword">int</span> nPrimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> f = <span class="number">2</span>; f &lt;= N / <span class="number">2</span>; f++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[f])&#123;</span><br><span class="line">            primes[nPrimes++] = f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; nPrimes; u++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = primes[u];</span><br><span class="line">            <span class="keyword">if</span>(p * f &gt; N) <span class="keyword">break</span>;</span><br><span class="line">            flag[p * f] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(f % p == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = N / <span class="number">2</span> + <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">            primes[nPrimes++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>依然是O(N)，但没有了复杂操作，效率优于之前的埃氏筛和枚举LPF的欧拉筛。 空间复杂度：O(N)与欧拉筛相同。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;合数的标准分解&quot;&gt;&lt;a href=&quot;#合数的标准分解&quot; class=&quot;headerlink&quot; title=&quot;合数的标准分解&quot;&gt;&lt;/a&gt;合数的标准分解&lt;/h1&gt;&lt;p&gt;每个合数可以分解质因数，对于60，最小质因子（LPF）为 2，最大质因子（GPF）为 5。 根据 L
      
    
    </summary>
    
      <category term="算法" scheme="https://pazyx.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="质数" scheme="https://pazyx.xyz/tags/%E8%B4%A8%E6%95%B0/"/>
    
      <category term="求质数表" scheme="https://pazyx.xyz/tags/%E6%B1%82%E8%B4%A8%E6%95%B0%E8%A1%A8/"/>
    
      <category term="优化" scheme="https://pazyx.xyz/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="欧拉筛法" scheme="https://pazyx.xyz/tags/%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95/"/>
    
      <category term="简易欧拉筛法" scheme="https://pazyx.xyz/tags/%E7%AE%80%E6%98%93%E6%AC%A7%E6%8B%89%E7%AD%9B%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>求质数表1——朴素算法</title>
    <link href="https://pazyx.xyz/2018/03/08/isprimes-1/"/>
    <id>https://pazyx.xyz/2018/03/08/isprimes-1/</id>
    <published>2018-03-08T01:20:42.000Z</published>
    <updated>2018-07-04T17:34:37.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h1><p><strong>对每个整数 i ，用 2 到 √i 的所有质数去试除它。</strong> </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/wmGwPfGvGW/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/wmGwPfGvGW/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[MAX_PRIMES];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trial_division</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nPrimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; nPrimes; u++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = primes[u];</span><br><span class="line">            <span class="keyword">if</span>(p * p &gt; i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % p == <span class="number">0</span>)&#123;</span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ok) primes[nPrimes++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O[ N√N / (logN)^2 ] 检查N个数每个数检查到它的平方根，1 / logN是质数的密度，只用质数去试除所以乘1 / logN，只有质数可以完全经受住考验再乘1 / logN。 O[ N√N / (logN)^2 ] ≈  N^1.5。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>N以内质数的密度为 1 / logN ，所以primes数组需要开到 O( N / logN)。  </p><h1 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h1><p>埃拉托色尼筛选法(the Sieve of Eratosthenes)简称埃氏筛法，是古希腊数学家埃拉托色尼(Eratosthenes 274B.C.～194B.C.)提出的一种筛选法。 <strong>枚举每个因子，看哪些数可以整除它，划掉它。</strong> </p><h2 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h2><p><img src="http://wszyx.org/wp-content/uploads/2018/03/Sieve_of_Eratosthenes_animation.gif" alt=""><br>图片来自<a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="noopener">维基百科</a></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/cymfGPHgMW/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/cymfGPHgMW/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag[MAX_N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eratosthenes</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>( flag, <span class="literal">true</span>, (N + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> p = <span class="number">2</span>; p * p &lt;= N; p++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[p])&#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> x = p * p; x &lt;= N; x += p)&#123;</span><br><span class="line">                flag[x] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nPrimes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">            primes[nPrimes++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="为什么x从-p-p-开始呢？"><a href="#为什么x从-p-p-开始呢？" class="headerlink" title="为什么x从 p * p 开始呢？"></a>为什么x从 p * p 开始呢？</h2><p>因为p <em> (p-i) ( 1 ≤ i ≤ p ) 的数已经在之前划掉过了，比如在检查 3 时，不需要划掉 3 </em> 2 因为在检查 2 的时候已经划过了。 <strong>为什么 p 到 √N 截止？</strong> 因为内层循环中的 x 是从 p * p 开始的，p 大于 √N 时就不能划掉更多的数了，没有意义。 </p><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>N/2 + N/3 + N/5 + N/7 + …… = O( N logN logN ) </p><h3 id="证明参考"><a href="#证明参考" class="headerlink" title="证明参考"></a>证明参考</h3><ul><li><a href="https://www.zhihu.com/question/21105642" target="_blank" rel="noopener">https://www.zhihu.com/question/21105642</a> </li><li><a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes</a> </li></ul><h2 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>N 个单位的 bool 数组，空间复杂度为 O(N) 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;试除法&quot;&gt;&lt;a href=&quot;#试除法&quot; class=&quot;headerlink&quot; title=&quot;试除法&quot;&gt;&lt;/a&gt;试除法&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;对每个整数 i ，用 2 到 √i 的所有质数去试除它。&lt;/strong&gt; &lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="算法" scheme="https://pazyx.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="质数" scheme="https://pazyx.xyz/tags/%E8%B4%A8%E6%95%B0/"/>
    
      <category term="求质数表" scheme="https://pazyx.xyz/tags/%E6%B1%82%E8%B4%A8%E6%95%B0%E8%A1%A8/"/>
    
      <category term="试除法" scheme="https://pazyx.xyz/tags/%E8%AF%95%E9%99%A4%E6%B3%95/"/>
    
      <category term="埃氏筛法" scheme="https://pazyx.xyz/tags/%E5%9F%83%E6%B0%8F%E7%AD%9B%E6%B3%95/"/>
    
      <category term="优化" scheme="https://pazyx.xyz/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
