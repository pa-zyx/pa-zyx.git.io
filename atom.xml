<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Microwave. Five minutes.</title>
  
  <subtitle>他大概会说你想得太多</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.pazyx.xyz/"/>
  <updated>2018-12-21T12:23:05.895Z</updated>
  <id>https://blog.pazyx.xyz/</id>
  
  <author>
    <name>pazyx.xyz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「书摘」深度探索 C++ 对象模型（三）</title>
    <link href="https://blog.pazyx.xyz/2018/12/21/inside_cpp_obj_model_3/"/>
    <id>https://blog.pazyx.xyz/2018/12/21/inside_cpp_obj_model_3/</id>
    <published>2018-12-21T12:23:42.000Z</published>
    <updated>2018-12-21T12:23:05.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-语意学-The-Semantics-of-Data"><a href="#Data-语意学-The-Semantics-of-Data" class="headerlink" title="Data 语意学 (The Semantics of Data)"></a>Data 语意学 (The Semantics of Data)</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> :</span> <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">X</span><span class="params">()</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> :</span> <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">X</span><span class="params">()</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Y, <span class="function"><span class="keyword">public</span> <span class="title">Z</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><code>Y</code> 和 <code>Z</code> 的大小与机器（字长）有关，也和编译器有关，具体受以下三个因素的影响：</p><ul><li>语言本身所造成的额外负担（overhea）</li><li>编译器对于特殊情况所提供的优化处理</li><li>Alignment 的限制</li></ul><p><code>class A</code> 的大小由下列几点决定：</p><ul><li>被大家共享的唯一一个 <code>class X</code> 实例，大小为 1 <code>byte</code>。</li><li><code>Base class Y</code> 和 <code>Base class Y</code> 的大小，减去“因 virtual base class X 而配置” 的大小，结果式 4 <code>bytes</code>。</li><li><code>class A</code> 自己的大小：0 <code>byte</code>。</li><li><code>class A</code> 的 alignment 数量（如果有的化）。<br>结果为 12 <code>bytes</code></li></ul><p>”特别对 empty virual base class 做了处理“ 的编译器，class X 实例的那 1 <code>byte</code> 将被拿掉，class A 的大小将是 8 <code>bytes</code>。</p><p>继承得到的数据的存放顺序，C++标准没有强制定义其间的排列顺序。</p><h2 id="Data-Member-的绑定-The-Binding-of-a-Data-Member"><a href="#Data-Member-的绑定-The-Binding-of-a-Data-Member" class="headerlink" title="Data Member 的绑定 (The Binding of a Data Member)"></a>Data Member 的绑定 (The Binding of a Data Member)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 对于函数本体的分析将延迟，直至 class 声明的右大括号出现才开始。</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">float</span> x;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 分析在这里进行</span></span><br></pre></td></tr></table></figure><p>member function 的 argument list 会在第一次遭遇时被适当地决议完成。extern 和 nested type names 之间的非直觉绑定操作还是会发生。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">( length val )</span> </span>&#123; _val = val; &#125;<span class="comment">// length 为 int</span></span><br><span class="line">    <span class="function">length <span class="title">mumble</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">float</span> length;</span><br><span class="line">    length _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>采用防御性程序风格改进后<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">float</span> length;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mumble</span><span class="params">( length val )</span> </span>&#123; _val = val; &#125;<span class="comment">// length 为 float</span></span><br><span class="line">    <span class="function">length <span class="title">mumble</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    length _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>请总是把 “nested type 声明” 放在 class 的起始处。</strong> </p><h2 id="Data-Member-的布局-Data-Member-Layout"><a href="#Data-Member-的布局-Data-Member-Layout" class="headerlink" title="Data Member 的布局 (Data Member Layout)"></a>Data Member 的布局 (Data Member Layout)</h2><p>C++ Standard 要求，在同一个 access section（也就是 private。public，protected 等区段）中，members 的排列只需符合“较晚出现的 members 在 class object 中有较高的地址”这一条件即可。</p><p>判断哪个 section 先出现的 template function：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">class_type</span>, <span class="title">class</span> <span class="title">data_type1</span>, <span class="title">class</span> <span class="title">data_type2</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">char</span>* <span class="title">access_order</span>( </span></span><br><span class="line"><span class="class"><span class="title">data_type1</span> <span class="title">class_type</span>:</span>:*mem1, </span><br><span class="line">data_type2 class_type::*mem2 )</span><br><span class="line">&#123;</span><br><span class="line">    assert (mem1 != mem2);</span><br><span class="line">    <span class="keyword">return</span> mem1 &lt; mem2 </span><br><span class="line">    ? <span class="string">"member 1 occurs first"</span> </span><br><span class="line">    : <span class="string">"member 1 occurs first"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用：<code>access_order( &amp;Point3d::z, &amp;Point3d::y );</code></p><h2 id="Data-Member-的存取"><a href="#Data-Member-的存取" class="headerlink" title="Data Member 的存取"></a>Data Member 的存取</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point origin;</span><br><span class="line">Point *pt = &amp;origin;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin.x = <span class="number">0.0</span>;</span><br><span class="line">pt-&gt;x = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure><p>通过 <code>origin</code> 存取，和通过 <code>pt</code> 存取的差异将在本节得出答案。</p><h3 id="Static-Data-Member"><a href="#Static-Data-Member" class="headerlink" title="Static Data Member"></a>Static Data Member</h3><p>每个 static member 的存取许可，以及与 class 的关联，并不会招致任何空间上或执行时间上的额外负担，不论是在个别的 class objects 还是在 static data member 本身。</p><h3 id="Nonstatic-Data-Member"><a href="#Nonstatic-Data-Member" class="headerlink" title="Nonstatic Data Member"></a>Nonstatic Data Member</h3><p>Nonstatic Data Member 直接存放在每一个 class object 之中。除非经由显式的（explicit）或隐式的（implicit）class object，否则没有办法直接存取它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Point <span class="number">3</span>d</span><br><span class="line">Point <span class="number">3</span>d::translate( <span class="keyword">const</span> Point3d &amp;pt)&#123;</span><br><span class="line">    x += pt.x;</span><br><span class="line">    y += pt.y;</span><br><span class="line">    z += pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表面上所看到的对于 <code>x</code>,<code>y</code>,<code>z</code> 的直接存取，事实上是经由一个“implicit class object”（由 <code>this</code> 指针表达）完成的。事实上这个函数的参数是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Point <span class="number">3</span>d</span><br><span class="line">Point <span class="number">3</span>d::translate( Point3d *<span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">const</span> Point3d &amp;pt)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;x += pt.x;</span><br><span class="line">    <span class="keyword">this</span>-&gt;y += pt.y;</span><br><span class="line">    <span class="keyword">this</span>-&gt;z += pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>欲对一个 nonstatic data member 进行存取操作，编译器需要把 class object 的起始地址加上 data member 的偏移位置（offset）。<br><code>origin._y = 0.0;</code> 会转化为 <code>&amp;origin + (&amp;Point3d::_y - 1);</code>。<br>请注意其中的 <code>-1</code>操作。指向 data member 的指针，其 offset 值总是被加上 1，这样可以使编译系统区分出“一个指向 data member 的指针，用以指出 class 的第一个 member” 和 “一个指向 data members 的指针，没有指出任何 member” 两种情况。</p><p>每一个 nonstatic data member 的偏移位置（offset）在编译时期即可获知，甚至如果 member 属于一个 base class subobject（派生自单一或多重继承串链）也是一样的。存取一个 nonstatic data member ，其效率和存取一个 C struct member 或 一个 nonderived class 的 member 是一样的。</p><h4 id="Nonstatic-Data-Member-在虚拟继承中"><a href="#Nonstatic-Data-Member-在虚拟继承中" class="headerlink" title="Nonstatic Data Member 在虚拟继承中"></a>Nonstatic Data Member 在虚拟继承中</h4><p>虚拟继承将为“经由 base class subobject 存取 class member“ 导入一层新的间接性：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point3d *pt3d;</span><br><span class="line">pt3d-&gt;_x = <span class="number">0.0</span>;</span><br></pre></td></tr></table></figure></p><p>其执行效率在 <code>_x</code> 是一个 struct member、一个 class member、单一继承、多重继承的情况下都完全相同。但如果 <code>_x</code> 是一个 virtual base class 的 member ，存取速度会稍慢一点。</p><p><code>origin._y = 0.0;</code> 会转化为 <code>&amp;origin + (&amp;Point3d::_y - 1);</code><br>当 <code>Point3d</code> 是一个 derived class，而其继承结构中有一个 virtual base class，并且被存取的 member（如本例的 <code>x</code> ）是一个从该 virtual base class 继承而来的 member 时，就会有重大的差异。<br>这时候我们不能说 <code>pt</code> 必然指向哪一种 class type（因此，我们也就不知道编译时期这个 member 真正的 offset 位置），所以这个存取操作必须延迟至执行期，经由一个额外的间接导引，才能够解决。但如果使用 <code>origin</code> ，就不会有这些问题，members 的 offset 位置在编译时期就固定了。</p><h2 id="“继承”-与-Data-Member"><a href="#“继承”-与-Data-Member" class="headerlink" title="“继承” 与 Data Member"></a>“继承” 与 Data Member</h2><p>derived class members 和 base class(es) members 的排列顺序，则并未在 C++ Standard 中强制指定；理论上编译器可以自由安排。在大多数编译器上头，base class members 总是先出现，但属于 virtual base class 的除外（一般而言，任何一条通则一旦碰上 virtual base class 就没辙了，这里亦不例外）。</p><h3 id="只要继承不要多态-Inheritance-without-Polymorphism"><a href="#只要继承不要多态-Inheritance-without-Polymorphism" class="headerlink" title="只要继承不要多态 (Inheritance without Polymorphism)"></a>只要继承不要多态 (Inheritance without Polymorphism)</h3><p>一般而言，具体继承（concrete inheritance）相对虚拟继承（virtual inheritance）并不会增加空间或存取时间上的额外负担。</p><p><strong>C++语言保证“出现在 derived class 中的 base class subobject 有其完整原样性”。</strong><br>因为要保证 bitwise 拷贝的正确性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">char</span> c1;</span><br><span class="line"><span class="keyword">char</span> c2;</span><br><span class="line"><span class="keyword">char</span> c3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>val</code> 占用 4 <code>bytes</code>；</li><li><code>c1</code>、<code>c2</code>和<code>c3</code> 各占用 1 <code>bytes</code>；</li><li>alignment（调整到 word 边界）需要 1 <code>byte</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete1</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">char</span> c1;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete2</span> :</span> <span class="keyword">public</span> Concrete1 &#123;</span><br><span class="line"><span class="keyword">char</span> c2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Concrete3</span> :</span> <span class="keyword">public</span> Concrete2 &#123;</span><br><span class="line"><span class="keyword">char</span> c3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Concrete1</code> 占用 8 <code>bytes</code>，包括填补用的 3 <code>bytes</code>。</li><li><code>Concrete2</code> 占用 12 <code>bytes</code>，填补 3 <code>bytes</code>。</li><li><code>Concrete3</code> 占用 16 <code>bytes</code>，填补 3 <code>bytes</code>。</li></ul><h3 id="加上多态-Adding-Polymorphism"><a href="#加上多态-Adding-Polymorphism" class="headerlink" title="加上多态 (Adding Polymorphism)"></a>加上多态 (Adding Polymorphism)</h3><p>Polymorphism 带来空间和存取时间上的额外负担</p><ul><li>导入一个 virtual table，用来存取它所声明的每一个 virtual functions 的地址。这个 table 的元素个数一般而言是被声明的 virtual functions 的个数，再加上一个或两个 slots（用以支持 runtime tyoe identifition）。</li><li>在每一个 class object 中导入一个 <code>vptr</code>，提供执行器的链接，使每一个 object 能够找到相应的 virtual table。</li><li>加强 constructor，使它能够为 <code>vptr</code> 设定初值，让它指向 class 所对应的 virtual table。这可能意味着在 derived class 和每一个 base class 的 constructor 中，重新设定 <code>vptr</code> 的值。其情况视编译器优化的积极性而定。</li><li>加强 destructor，使它能够抹消“指向 class 之相关 virtual table” 的 <code>vptr</code>。<code>vptr</code> 很可能已经在 derived class destructor 中被设定为 derived class 的 virtual table 的地址。destructor 的调用的顺序上反向的：从 derived class 到 base class，一个积极的优化编译器可以压抑那些大量的制定操作。</li></ul><p><code>vptr</code> 放在前端，代价是丧失了 C 语言兼容性。</p><h3 id="多重继承-Multiple-Inheritance"><a href="#多重继承-Multiple-Inheritance" class="headerlink" title="多重继承 (Multiple Inheritance)"></a>多重继承 (Multiple Inheritance)</h3><p>……</p><h3 id="虚拟继承-Virtual-Inheritance"><a href="#虚拟继承-Virtual-Inheritance" class="headerlink" title="虚拟继承 (Virtual Inheritance)"></a>虚拟继承 (Virtual Inheritance)</h3><p>虚拟继承的两个问题</p><ul><li>每一个对象必须针对其每一个 virtual base class 背负一个额外的指针，然而理想上我们希望 class object 有固定负担，不因为其 virtual base classes 的个数而有所变化。</li><li>由于虚拟继承串链的加长，导致间接存取层次的增加。我们希望有固定的存取时间，不因为虚拟派生的深度而改变。</li></ul><p>第一个问题两种解决办法：</p><ul><li>Microsoft 编译器引入的 virtual base class table。</li><li>在 virtual function table 中放置 virtual base class 的 offset（不是地址），在 Sun 编译器中，virtual function table 可经由正值或负值来索引，如果是正值索引到 virtual function ，如果是负值索引到 virtual base class offset。</li></ul><p>第二个问题，它们经由拷贝操作取得所有的 nested  virtual base class 指针，放到的 derived class object 之中。</p><h2 id="对象成员的效率-Object-Member-Efficiency"><a href="#对象成员的效率-Object-Member-Efficiency" class="headerlink" title="对象成员的效率 (Object Member Efficiency)"></a>对象成员的效率 (Object Member Efficiency)</h2><p>聚合（aggregtion）<br>封装（encapsulation）<br>继承（inheritance）</p><p><strong>不断加强抽象化程度后，数据的存取效率</strong></p><table><thead><tr><th></th><th>优化</th><th>未优化</th></tr></thead><tbody><tr><td>个别的局部变量</td><td>0.80</td><td>1.42</td></tr><tr><td></td><td></td><td></td></tr><tr><td>局部数组</td><td></td><td></td></tr><tr><td>CC</td><td>0.80</td><td>2.55</td></tr><tr><td>NCC</td><td>0.80</td><td>1.42</td></tr><tr><td></td><td></td><td></td></tr><tr><td>struct 之中有 public 成员</td><td>0.80</td><td>1.42</td></tr><tr><td></td><td></td><td></td></tr><tr><td>class 之中有 inline Get 函数</td><td></td><td></td></tr><tr><td>CC</td><td>0.80</td><td>2.56</td></tr><tr><td>NCC</td><td>0.80</td><td>3.10</td></tr><tr><td></td><td></td><td></td></tr><tr><td>class 之中有 inline Get &amp; Set 函数</td><td></td><td></td></tr><tr><td>CC</td><td>0.80</td><td>1.74</td></tr><tr><td>NCC</td><td>0.80</td><td>2.87</td></tr></tbody></table><p>如果把优化开关打开，“封装”就不会带来执行器的效率成本，使用 inline 存取函数亦然。</p><p>为什么在 CC 之下存取数组，几乎比 NCC 慢两倍？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// CC assembler output</span><br><span class="line"># 13 pB[ x ] = pA[ x ] - pB[ x ];</span><br><span class="line">add $25, $sp, 20</span><br><span class="line">1.s $f4, 0($25)</span><br><span class="line">addu $24, $sp, 8</span><br><span class="line">1.s $f6, 8($24)</span><br><span class="line">sub.s $f8, $f4, $f6</span><br><span class="line">s.s $f8, 0($24)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// NCC assembler output</span><br><span class="line"># 13 pB[ x ] = pA[ x ] - pB[ x ];</span><br><span class="line">1.s $f4, 20($25)</span><br><span class="line">1.s $f6, 16($24)</span><br><span class="line">sub.s $f8, $f4, $f6</span><br><span class="line">s.s $f8, 0($24)</span><br></pre></td></tr></table></figure><ul><li><code>1.s</code> 加载一个单精度浮点数</li><li><code>s.s</code> 存储一个单精度浮点数</li><li><code>sub.s</code> 将两个单精度浮点数相减</li></ul><p><strong>在继承模型之下的数据存取</strong></p><table><thead><tr><th></th><th>优化</th><th>未优化</th></tr></thead><tbody><tr><td>单一继承</td><td></td><td></td></tr><tr><td>直接存取</td><td>0.80</td><td>1.42</td></tr><tr><td>使用 inline 函数</td><td></td><td></td></tr><tr><td>CC</td><td>0.80</td><td>2.55</td></tr><tr><td>NCC</td><td>0.80</td><td>3.10</td></tr><tr><td></td><td></td><td></td></tr><tr><td>虚拟继承（单层）</td><td></td><td></td></tr><tr><td>直接存取</td><td>1.60</td><td>1.94</td></tr><tr><td>使用 inline 函数</td><td></td><td></td></tr><tr><td>CC</td><td>1.60</td><td>2.75</td></tr><tr><td>NCC</td><td>1.60</td><td>3.30</td></tr><tr><td></td><td></td><td></td></tr><tr><td>虚拟继承（双层）</td><td></td><td></td></tr><tr><td>直接存取</td><td></td><td></td></tr><tr><td>CC</td><td>2.25</td><td>2.74</td></tr><tr><td>NCC</td><td>3.04</td><td>3.68</td></tr><tr><td>使用 inline 函数</td><td></td><td></td></tr><tr><td>CC</td><td>2.25</td><td>3.22</td></tr><tr><td>NCC</td><td>2.50</td><td>3.81</td></tr></tbody></table><h2 id="指向-Data-Member-的指针-Pointer-to-Data-Members"><a href="#指向-Data-Member-的指针-Pointer-to-Data-Members" class="headerlink" title="指向 Data Member 的指针 (Pointer to Data Members)"></a>指向 Data Member 的指针 (Pointer to Data Members)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~Point3d();</span><br><span class="line">    <span class="keyword">static</span> Point3d origin;</span><br><span class="line">    <span class="keyword">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br><span class="line">&amp;Point3d::z <span class="comment">// 得到 z 在 class object 中的 offset</span></span><br></pre></td></tr></table></figure><p>输出 offset<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Point3d::x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Point3d::y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;Point3d::z);</span><br></pre></td></tr></table></figure></p><p>早期一些编译器 <code>&amp;Point3d::z</code> 这个操作的值为 <code>z</code> 的 offset + 1。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> Point3d::*p1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> Point3d::*p2 = &amp;Point3d:x;</span><br><span class="line"><span class="comment">// Point3d::* 的意思是 "指向 Point3d data member" 的指针类型</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p1 == p2) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" p1 &amp; p2 contain the same value -- "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" they must address the same member!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 offset 加 1，方便区分 <code>NULL</code> 和第一个 data member。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span>&#123;</span> <span class="keyword">int</span> val1; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span>&#123;</span> <span class="keyword">int</span> val2; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base1, Base2&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">( <span class="keyword">int</span> Derived::*dmp, Derived *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pd-&gt;*dmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">( Derived *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// bmp 为 1</span></span><br><span class="line">    <span class="keyword">int</span> Base2::*bmp = &amp;Base2::val2;</span><br><span class="line"><span class="comment">// bmp == 1</span></span><br><span class="line"><span class="comment">// 但在 Derived 中， val2 == 5</span></span><br><span class="line">    func1(bmp,pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经由编译器内部转换</span></span><br><span class="line">func1( bmp + <span class="keyword">sizeof</span>( Base1 ), pd );</span><br></pre></td></tr></table></figure><p>一般而言，我们不能够保证 <code>bmp</code> 不是 0，因此必须注意这一点：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func1( bmp ? bmp + <span class="keyword">sizeof</span>( Base1 ) : <span class="number">0</span>, pd );</span><br></pre></td></tr></table></figure></p><p><strong>我的测试程序：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span>&#123;</span> <span class="keyword">int</span> val1; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span>&#123;</span> <span class="keyword">int</span> val2; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base1, Base2&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">( <span class="keyword">int</span> Derived::*dmp, Derived *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,dmp);</span><br><span class="line">    <span class="keyword">return</span> pd-&gt;*dmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">( Derived *pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Base2::*bmp = &amp;Base2::val2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,bmp);</span><br><span class="line">    <span class="keyword">return</span> func1(bmp,pd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived xx;</span><br><span class="line"></span><br><span class="line">    xx.val1 = <span class="number">11</span>;</span><br><span class="line">    xx.val2 = <span class="number">22</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; func2(&amp;xx) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="“指向-Data-Member-的指针”-的效率问题"><a href="#“指向-Data-Member-的指针”-的效率问题" class="headerlink" title="“指向 Data Member 的指针” 的效率问题"></a>“指向 Data Member 的指针” 的效率问题</h3><p><strong>存取 Nonstatic Data Member</strong></p><table><thead><tr><th></th><th>优化</th><th>未优化</th></tr></thead><tbody><tr><td>直接存取</td><td>0.80</td><td>1.42</td></tr><tr><td>指针指向已绑定的 Member</td><td>0.80</td><td>3.04</td></tr><tr><td>指针指向 Data Member</td><td></td><td></td></tr><tr><td>CC</td><td>0.80</td><td>5.34</td></tr><tr><td>NCC</td><td>4.04</td><td>5.34</td></tr></tbody></table><p><strong>“指向 Data Member 的指针”存取方式</strong></p><table><thead><tr><th></th><th>优化</th><th>未优化</th></tr></thead><tbody><tr><td>没有继承</td><td>0.80</td><td>5.34</td></tr><tr><td>单一继承（三层）</td><td>0.80</td><td>5.34</td></tr><tr><td>虚拟继承（单层）</td><td>1.60</td><td>5.44</td></tr><tr><td>虚拟继承（双层）</td><td>2.14</td><td>5.51</td></tr></tbody></table><p>在两个编译器中，每次存取 <code>Point::x</code>，像这样： <code>pB.*bx</code> 会被转换为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;pB-&gt;__vbcPoint + ( bx - <span class="number">1</span> )</span><br></pre></td></tr></table></figure></p><p>而不是转换为最直接的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;pB + ( bx - <span class="number">1</span> )</span><br></pre></td></tr></table></figure></p><p>额外的间接性会降低“把所有的处理都搬移到寄存器中执行”的优化能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Data-语意学-The-Semantics-of-Data&quot;&gt;&lt;a href=&quot;#Data-语意学-The-Semantics-of-Data&quot; class=&quot;headerlink&quot; title=&quot;Data 语意学 (The Semantics of Data)
      
    
    </summary>
    
      <category term="泛 - 书摘" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E4%B9%A6%E6%91%98/"/>
    
    
      <category term="Cpp" scheme="https://blog.pazyx.xyz/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」Effective C++ 读书笔记（三）</title>
    <link href="https://blog.pazyx.xyz/2018/12/19/effective-cpp03/"/>
    <id>https://blog.pazyx.xyz/2018/12/19/effective-cpp03/</id>
    <published>2018-12-18T16:02:25.000Z</published>
    <updated>2018-12-18T16:02:58.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h1><p>这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）。</p><h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><h2 id="条款-13：以对象管理资源"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Investment* pInv = creteInvestment();<span class="comment">// 调用 factory 函数</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> pInv;<span class="comment">// 释放 pInv 所指对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>...</code> 可能存在过早的 <code>return</code> 语句，或抛出某些异常，<code>delete</code> 语句将不会被执行。类似的 <code>goto</code> 语句或循环中的 <code>continue</code> 和 <code>break</code>。</p><p>使用智能指针，利用栈中对象的析构函数自动对其 <code>delete</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; pInv(createInvestment());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>获得资源后立刻放进管理对象（managing object）</strong></li><li><strong>管理对象（managing object）运用析构函数确保资源被释放</strong></li></ul><p>常使用的 RAII classes ：<code>tr1::shared_ptr</code> 和 <code>auto_ptr</code> 。</p><h2 id="条款-14：在资源管理类中小心-copying-行为"><a href="#条款-14：在资源管理类中小心-copying-行为" class="headerlink" title="条款 14：在资源管理类中小心 copying 行为"></a>条款 14：在资源管理类中小心 <em>copying</em> 行为</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">explicit Lock(Mutex* pm) : mutexPtr(pm)</span><br><span class="line">&#123;</span><br><span class="line">lock(muterPtr);</span><br><span class="line">&#125;</span><br><span class="line">~Lock()</span><br><span class="line">&#123;</span><br><span class="line">        unlock(mutexPtr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Mutex *mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function">Lock <span class="title">ml1</span><span class="params">(&amp;m)</span></span>;</span><br><span class="line"><span class="function">Lock <span class="title">ml2</span><span class="params">(ml1)</span></span>;</span><br></pre></td></tr></table></figure><p>RAII classes 应被禁止复制或采用“引用计数法（reference-count）”。</p><h3 id="禁止复制"><a href="#禁止复制" class="headerlink" title="禁止复制"></a>禁止复制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>:</span> <span class="keyword">private</span> Uncopyable</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“引用计数法（reference-count）"><a href="#“引用计数法（reference-count）" class="headerlink" title="“引用计数法（reference-count）"></a>“引用计数法（reference-count）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">explicit Lock(Mutex* pm) : mutexPtr(pm, unlock)</span><br><span class="line">&#123;</span><br><span class="line">lock(muterPtr.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>进行“深度拷贝”，复制底部资源</li><li>转移底部资源的拥有权，如：<code>auto_ptr</code></li></ul><p><code>Coping</code> 函数包括 <code>copy</code> 构造函数和 <code>copy assignment</code>操作符。</p><h2 id="条款-15：在资源管理类中提供对原始资源的访问"><a href="#条款-15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15：在资源管理类中提供对原始资源的访问"></a>条款 15：在资源管理类中提供对原始资源的访问</h2><p>每个 RAII class 应该提供一个 “取得其所管理之资源” 的方法。<br>对原始资源的访问可能经由显式转换或隐式转换。显式转换比较安全，但隐式转换对客户比较方便。</p><h2 id="条款-16：成对使用-new-和-delete-时要采取相同形式"><a href="#条款-16：成对使用-new-和-delete-时要采取相同形式" class="headerlink" title="条款 16：成对使用 new 和 delete 时要采取相同形式"></a>条款 16：成对使用 new 和 delete 时要采取相同形式</h2><p>使用 <code>new</code> 要严格搭配 <code>delete</code>，如使用 <code>delete[]</code> 为未定义的行为，可能多次调用析构函数。<br>使用 <code>new[]</code> 要严格搭配 <code>delete[]</code>。<br>谨慎对数组类型 <code>typedef</code> 。 </p><h2 id="条款-17：以独立语句将-newed-对象置入智能指针"><a href="#条款-17：以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款 17：以独立语句将 newed 对象置入智能指针"></a>条款 17：以独立语句将 newed 对象置入智能指针</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line">void processWidget(std::tr1::shared_ptr&lt;Widget&gt;, priority());</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br><span class="line"><span class="comment">// 进入函数前做了以下三件事</span></span><br><span class="line"><span class="comment">// 执行 "new Widget"</span></span><br><span class="line"><span class="comment">// 调用 tr1::shared_ptr 构造函数</span></span><br><span class="line"><span class="comment">// 调用 priority()</span></span><br></pre></td></tr></table></figure><p>编译器对这三件事的完成次序上弹性很大。<br>如在 <code>priority()</code> 抛出了异常，<code>new Widget</code> 返回的指针将可能遗失，因为它尚未被置入 <code>std::tr1::shared_ptr</code> 内。</p><p>避免这类问题只需分离语句，控制执行顺序。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw(<span class="keyword">new</span> Widget);</span><br><span class="line">processWidget(pw, priority);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注意！&quot;&gt;&lt;a href=&quot;#注意！&quot; class=&quot;headerlink&quot; title=&quot;注意！&quot;&gt;&lt;/a&gt;注意！&lt;/h1&gt;&lt;p&gt;这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）
      
    
    </summary>
    
      <category term="泛 - 笔记" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://blog.pazyx.xyz/tags/Cpp/"/>
    
      <category term="读书" scheme="https://blog.pazyx.xyz/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="笔记" scheme="https://blog.pazyx.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective C++" scheme="https://blog.pazyx.xyz/tags/Effective-C/"/>
    
      <category term="智能指针" scheme="https://blog.pazyx.xyz/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>「书摘」自控力</title>
    <link href="https://blog.pazyx.xyz/2018/12/12/books-1/"/>
    <id>https://blog.pazyx.xyz/2018/12/12/books-1/</id>
    <published>2018-12-11T23:31:20.000Z</published>
    <updated>2018-12-11T23:30:48.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？"><a href="#我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？" class="headerlink" title="我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？"></a>我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？</h1><ul><li>研究表明，自诩意志坚定的人反而最容易在诱惑面前失控。比如，自信能抵制诱惑的戒烟者最容易在4个月后故态复萌，过于乐观的节食者最不容易减肥成功。这是为什么呢？因为他们无法预测自己在何时何地、会由于何种原因失控。</li><li>每个人都在以某种方式抵制诱惑、癖好、干扰和拖延。这不是个体的弱点或个人的不足，而是普遍的经验，是人所共有的状态。</li><li>“说不”属于意志力的一部分，而且是不可或缺的一部分。</li><li>牢记自己真正想要的是什么</li><li>前额皮质并不是挤成一团的灰质，而是分成了三个区域，分管“我要做”“我不要”和“我想要”三种力量。</li><li>如果没有了欲望，人们就会变得沮丧；如果没有了恐惧，人们就没法保护自己、远离伤害。</li><li>在意志力挑战中获胜的关键，在于学会利用原始本能，而不是反抗这些本能。</li><li>注意力分散的人更容易向诱惑屈服。</li><li>如果你想有更强的自控力，就得有更多的自我意识。</li><li>只要她能意识到自己在做什么，就有可能停下来。</li><li>观察自己究竟是怎样屈服于冲动的。</li><li>神经学家发现，如果你经常让大脑冥想，它不仅会变得擅长冥想，还会提升你的自控力，提升你集中注意力、管理压力、克制冲动和认识自我的能力。一段时间之后，你的大脑就会变成调试良好的意志力机器。</li><li>不仅要关注自己能否将注意力集中到呼吸上，还要注意观察，这种训练在其他时候是否影响了你的选择。</li><li>在冥想训练里做的事正是他在生活中也要面对的——把自己的注意力收回，专注于最初的目标。（在冥想训练中，目标就是专注呼吸。）</li></ul><h1 id="意志力的本能：人生来就能抵制奶酪蛋糕的诱惑"><a href="#意志力的本能：人生来就能抵制奶酪蛋糕的诱惑" class="headerlink" title="意志力的本能：人生来就能抵制奶酪蛋糕的诱惑"></a>意志力的本能：人生来就能抵制奶酪蛋糕的诱惑</h1><ul><li>自控力不仅和心理有关，更和生理有关。只有在大脑和身体同时作用的瞬间，你才有力量克服冲动。</li><li>应激反应是一种管理能量的本能，这种本能决定了你将如何利用有限的体力和脑力。</li><li>我们总觉得诱惑和麻烦来自外部世界，比如危险的甜甜圈、罪恶的香烟、充满诱惑的网络。但自控力告诉我们，问题出在我们自己身上，是我们的思想、欲望、情绪和冲动出了问题。</li><li>“三思而后行”反应和应激反应有一处关键的区别：前者的起因是你意识到了内在的冲突，而不是外在的威胁。</li><li>最有效的做法就是先让自己放慢速度，而不是给自己加速（比如应激反应）。“三思而后行”反应就是让你慢下来。当你意识到内在冲突的时候，大脑和身体会做出反应，帮助你放慢速度、抑制冲动。</li><li>当人们感到压力时，交感神经系统会控制身体。这种生理学现象让你能够战斗或者逃跑。心率升高，心率变异度就会降低。此时，由于伴随应激反应产生的焦虑或愤怒，心率会被迫保持在较高的水平上。相反，当人们成功自控的时候，副交感神经系统会发挥主要作用，缓解压力，控制冲动行为。心率降低，心率变异度便会升高。此时，人们能更好地集中注意力并保持平静。</li><li>心率变异度较高的人能更好地集中注意力、避免及时行乐的想法、更好地应对压力。</li><li>有很多因素会影响到意志力储备，比如你吃什么（以植物为原材料的、未经加工的食物有助于提高心率变异度，垃圾食品则会降低心率变异度）或是住在哪里（糟糕的空气质量会降低心率变异度）。任何给你的身心带来压力的东西都会影响自控力的生理基础，甚至会摧毁你的意志力。焦虑、愤怒、抑郁和孤独都与较低的心率变异度和较差的自控力有关。慢性疼痛和慢性疾病则会消耗身体和大脑的意志力储备。</li><li>将呼吸频率降低到每分钟4-6次，也就是每次呼吸用10-15秒时间，比平常呼吸要慢一些。只要你有足够的耐心，加上必要的练习，这一点不难办到。放慢呼吸能激活前额皮质、提高心率变异度，有助于你的身心从压力状态调整到自控力状态。这样训练几分钟之后，你就会感到平静、有控制感，能够克制欲望、迎接挑战。</li><li>滥用药物或患有创伤后应激障碍症的成年人，每天进行20分钟放慢呼吸的练习，就能提高心率变异度，降低欲望和抑郁程度。</li><li>锻炼能提高心率变异度的基准线，从而改善自控力的生理基础。</li><li>改善心情、缓解压力的最有效的锻炼是每次5分钟，而不是每次几小时。</li><li>任何能让你离开椅子的活动，都能提高你的意志力储备。</li><li>如果你觉得锻炼太累了，或是没有时间锻炼，那么不妨将锻炼当做恢复体能和意志力的方法。</li><li>长期睡眠不足让你更容易感到压力、萌生欲望、受到诱惑。你还会很难控制情绪、集中注意力，或是无力应付“我想要”的意志力挑战。</li><li>如果睡眠不足的人补上一个好觉，他的前额皮质就会恢复如初。实际上，他的大脑和休息良好的人的大脑会完全一样。</li><li>如果你明知道自己能获得更多的睡眠，却没法早点入睡，那就不要想睡觉这件事，想一想你到底对什么说了“我想要”。这个意志力法则同样适用于你想逃避或拖延的事——当你不知道自己想做什么的时候，你或许需要知道自己不想做什么。</li><li>自控需要大量能量，很多科学家都认为，长时间的自控就像慢性压力一样，会削弱免疫系统的功能，增大患病的概率。</li><li>正如适度的压力是有意义的健康生活不可缺少的一部分，适当的自控也是必需的。但是正如慢性压力会影响健康一样，试图控制所有的思想、情绪和行为也是一剂毒药，会给你带去过重的生理负担。</li><li>为了能够保持健康、维持幸福生活，你需要放弃对意志力的完美控制。</li><li>从压力和自控力中恢复的最佳途径就是放松。放松，即便只放松几分钟，都能激活副交感神经系统，舒缓交感神经系统，从而提高心率变异度。它还能把身体调整到修复和自愈状态、提高免疫功能、降低压力荷尔蒙分泌。</li><li>能提高意志力的“放松”是真正意义上的身心休整。哈佛医学院心脏病专家赫伯特·本森（Herbert Benson）称之为“生理学放松反应”。你的心率和呼吸速度会放缓，血压会降低，肌肉会放松。你的大脑不会去规划未来，也不会去分析过去。<br>想要激发这种放松反应，你需要躺下来，用枕头垫着膝盖，腿稍稍抬起（或者，你可以选择任何一个你觉得舒服的姿势）。闭上眼睛，做几次深呼吸，感觉你的腹部有起伏。如果你觉得身体某处很紧张，你可以有意识地挤压或收缩肌肉，然后就不要再去管它了。比如，如果你发现手掌和手指很紧张，那么就攥一下拳头，然后张开手掌。如果你发现前额和下巴很紧张，那么就挤挤眼、皱皱眉，然后张大嘴巴，放松整个面部。保持这种状态5-10分钟，试着享受这种除了呼吸什么都不用想的状态。如果你担心会睡着，那就先设定好闹钟。</li><li>意志力是一种不断进化的能力，是每个人都有的本能。它详细地记录了身体和大脑的状态。</li><li>意志力会受到多方面的影响，比如睡眠不足、饮食不良、久坐不动和各种消耗能量的事情，或是身心长期处于压力状态之下。</li><li>从长远的角度看，没有什么比压力更消耗意志力了。压力和自控的生理学基础是互相排斥的。</li><li>压力让你关注即时的、短期的目标和结果，自控力则需要你的大脑有更广阔的视野。</li><li>学会如何更好地管理压力，是提高意志力的重要组成部分。</li><li>儿童多动症的概率急剧攀升很可能和这种睡眠习惯有关，因为儿童往往受成人睡眠习惯的影响，而且儿童需要更多的睡眠。</li><li>我们的坏习惯（比如过度饮食和睡眠不足）不仅反映了我们缺乏自控力，还消耗了我们的体力，带来了更多的压力，偷走了我们的自控力。</li><li>当我们面对的意志力挑战过于强大时，我们很容易给自己下这样的结论——我是个软弱、懒惰、毫无意志力的废物。但通常的情形是，我们的大脑和身体并未处于自控状态。当我们处在慢性压力中时，迎接意志力挑战的是最冲动的自己。想要赢得意志力挑战，我们需要调整到正确的身心状态，用能量去自控，而不是自卫。这就意味着，我们需要从压力中恢复过来，保证有能量做最好的自己。</li><li>意志力是种生理本能，它和压力一样，通过不断进化来保护我们不受自身伤害。</li></ul><h1 id="累到无力抵抗：为什么自控力和肌肉一样有极限？"><a href="#累到无力抵抗：为什么自控力和肌肉一样有极限？" class="headerlink" title="累到无力抵抗：为什么自控力和肌肉一样有极限？"></a>累到无力抵抗：为什么自控力和肌肉一样有极限？</h1><ul><li>似乎我们只有一定量的意志力，一旦你将它消耗殆尽，你在诱惑面前就会毫无防备力，至少会处于下风。</li><li>人们早晨的意志力最强，然后意志力随着时间的推移逐渐减弱。</li><li>时间过长，注意力训练就不仅会分散注意力，还会耗尽身体的能量。控制情绪不仅会导致情绪失控，还会促使人们购买他们本不需要的东西。抵抗甜食的诱惑不仅会让人更想吃巧克力，还会导致拖延症。</li><li>资源不足时，大脑会选择满足当下的需求；资源充足时，大脑则会转向选择长期的投资。</li><li>更好的方法是保证你的身体有足够的食物供应，这样能给你更持久的能量。大多数心理学家和营养学家推荐低血糖饮食，因为它能让你的血糖稳定。低血糖食品包括瘦肉蛋白、坚果和豆类、粗纤维谷类和麦片、大多数的水果和蔬菜。</li><li>这些研究中训练的“肌肉”不是为了让你在规定期限前完成任务、用左手开门或不说脏话，而是让你养成习惯、关注自己正在做的事情、选择更难的而不是最简单的事。通过每一次意志力练习，大脑开始习惯于三思而后行。</li><li>我们总是在意志力真正耗尽之前就感到无法坚持了。从某种程度上说，我们应该感谢大脑帮助我们保存能量。正如大脑担心体能枯竭时会告诉肌肉放慢速度一样，大脑也会对大量消耗前额皮质中能量的活动喊“停”。这并不意味着我们用光了意志力，我们只是需要积攒使用意志力的动力罢了。</li><li>知道我们的意志力比想象中多得多，这确实是件令人开心的事。或许我们也可以像运动员一样，挺过意志力消耗殆尽的感觉，冲过意志力挑战的终点。</li></ul><h1 id="容忍罪恶：为何善行之后会有恶行？"><a href="#容忍罪恶：为何善行之后会有恶行？" class="headerlink" title="容忍罪恶：为何善行之后会有恶行？"></a>容忍罪恶：为何善行之后会有恶行？</h1><ul><li>心理学家一直认为，当你表达一种态度时，你更可能按这种准则行事。毕竟，谁愿意做伪君子？但普林斯顿的心理学家揭示了一个例外，这和我们对表里如一的渴望背道而驰。当说到孰是孰非时，我们都能毫不费力地作出符合道德标准的选择。我们只想让自己感觉良好，而这就为自己的胡作非为开了绿灯。</li><li>明确驳斥性别歧视和种族歧视言论的学生，觉得自己已经获得了道德许可证。他们已经向自己证明了，他们没有性别歧视或种族歧视。这就让他们在心理学家所谓的“道德许可”（moral licensing）面前不堪一击。当你做善事的时候，你会感觉良好。这就意味着，你更可能相信自己的冲动。而冲动常常会允许你做坏事。</li><li>“道德许可”不仅会批准我们做坏事，也会让我们错失做善事的机会。</li><li>如果你去锻炼了就说自己很“好”，没去锻炼就说自己很“坏”，那么你很可能因为今天去锻炼了，明天就不去了。如果你去处理了一个重要项目就说自己很“好”，拖延着不去处理就说自己很“坏”，那么你很可能因为早上取得了进步，下午就变懒散了。简单说来，只要我们的思想中存在正反两方，好的行为就总是允许我们做一点坏事。</li><li>任何让你对自己的美德感到满意的事，即便只是想想你做过的善事，都会允许我们冲动行事。</li><li>“道德许可”最糟糕的部分并不是它可疑的逻辑，而是它会诱使我们做出背离自己最大利益的事。</li><li>不要把支持目标实现的行为误认为是目标本身。不是说你做了一件和你目标一致的事情，你就不会再面临危险了。注意观察一下，你是否因为认为某些积极的行为值得称赞，就忘了自己实际的目标是什么。</li><li>大部分人认为，取得进步会刺激我们获得更大的成功。但心理学家知道，我们总是把进步当做放松的借口。</li><li>芝加哥大学商学院研究生院的教授阿耶莱特·费什巴赫（Ayelet Fishbach）和耶鲁大学管理学教授拉维·多尔（Ravi Dhar）已经证明了，在完成某个目标过程中取得的进步，会刺激人们做出妨碍完成目标的行为</li><li>应该想着“我做这件事是因为我想要……”</li><li>有时候，大脑会对能完成目标的可能性感到兴奋，它错把可能性当成真正完成了目标。</li><li>对未来的乐观主义精神，不仅会影响我们自己的决定，还会影响我们究竟会不会按自己所说的去做。心理学家已经证明了，我们错误地认为自己明天会比今天有更多的空闲时间。</li><li>人们是为理想世界作出预估，却在现实世界生活了两周。</li><li>当你想改变某种行为的时候，试着减少行为的变化性，而不是减少那种行为。</li><li>你明知道应该做一件事情却拖延不做时，不要问自己“我是想今天做还是明天做？”，而要问自己“我是不是想承担永远拖延下去的恶果？”</li><li>研究表明，选择健康主食的人，通常会在饮料、配菜和甜点上纵容自己。</li><li>托儿所会让晚接孩子的父母交罚款，但这种制度实际上增加了晚接孩子的概率。家长可以购买晚接孩子的权利，以此来消除自己的罪恶感。</li><li>从本质上看，道德许可就是一种身份危机。我们之所以会奖励自己的良好行为，是因为我们内心深处认为，真正的自己想做坏事。从这点来看，每次自控都是一种惩罚，只有放纵自我才是奖励。但我们为什么一定要这样看待自己呢？想要走出“道德许可”的陷阱，我们就要知道，那个想变好的自己才是真正的自己，想按核心价值观生活的自己。</li><li>在追求自控的过程中，我们不应该把所有的意志力挑战都放在道德标准的框架中。我们总是轻易地认为，自己做过的善行，或是仅仅考虑要去做的善行，给了我们道德上的许可。如果只按照“正确”和“错误”来判断做过的事，而不是牢记我们真正想要的东西，就会带来与目标相抵触的冲动，并允许我们做出妨碍自己的行为。想要做到始终如一，我们就需要认同目标本身，而不是我们做善事时的光环。</li><li>明天和今天毫无区别。当你想改变行为的时候，试着减少行为的变化性，而不是减少某种行为。</li><li>取消许可，牢记理由。下一回，当你发现自己在用曾经的善行为放纵辩护的时候，停下来想一想你做“好”事的原因，而不是你应不应该得到奖励。</li></ul><h1 id="大脑的弥天大谎：为什么我们误把渴望当幸福"><a href="#大脑的弥天大谎：为什么我们误把渴望当幸福" class="headerlink" title="大脑的弥天大谎：为什么我们误把渴望当幸福"></a>大脑的弥天大谎：为什么我们误把渴望当幸福</h1><ul><li>多巴胺会告诉大脑其他的部分它们需要注意什么，怎样才能让贪婪的我们得手。大量的多巴胺并不能产生快乐的感觉，那种感觉更像是一种激励。我们会觉得警醒、清醒、着迷。我们发现了如何才能得到快乐，而且愿意为了获得这种感觉付出努力。</li><li>这些设备就这样俘获了我们，让我们不断要求更多。在我们所处的时代里，奖励的承诺可以用我们上网时的行为来打比方——我们搜索，再搜索，搜索更多的。我们点击鼠标，就像笼子里的小白鼠想再感受一次电击一样。我们追寻着难以捉摸的奖励，直到最终觉得满意。</li><li>手机、互联网和其他社交媒体可能是无意中激活了我们的奖励系统，但电脑和电子游戏的设计者是有意识地控制了人们的奖励系统，让玩家上钩。“升级”和“获胜”随时可能出现，游戏就这样激发了人们的兴趣。这也是人们很难戒掉游戏的原因。</li><li>2005年，28岁的韩国锅炉修理工李承生在连续50个小时奋战“星际争霸”之后死于心血管衰竭。他不吃不睡，只想继续玩游戏。听到这件事的时候，我们很难不联想到奥尔兹和米尔纳实验中力竭而亡的小白鼠。</li><li>多巴胺在我们上瘾时会发挥某些作用。最令我们吃惊的是它在帕金森患者治疗过程中发挥的作用。帕金森症是一种常见的神经退化性疾病，病因是脑细胞中缺少多巴胺。多巴胺在刺激行为中起的作用主要表现在：减缓或减少运动、抑郁以及间歇性紧张症。标准的帕金森治疗方式是同时服用两种药物：左旋多巴和多巴胺受体激动剂。前者可以帮助大脑产生多巴胺，后者能刺激大脑中的多巴胺腺体，模仿多巴胺的行为。当病人刚开始接受药物治疗时，大脑中多巴胺的含量会比往常多。这就减轻了帕金森的主要症状，但同时带来了难以预料的新问题。</li><li>当多巴胺给我们的大脑安排寻找奖励的任务时，我们就展现了自己最敢于冒险、最冲动、最失控的一面。</li><li>更重要的是，如果奖励迟迟没有到来的话，奖励的承诺（和一想到要停下来就不断增长的焦虑）足以让我们一直上瘾。如果你是实验室里的小白鼠，你就会一次次地去按杠杆，直到力竭而亡或被饿死。如果你是人类，你就会掏空钱包、填满肚子——这还是好的。如果严重的话，你会发现自己患上了强迫症。</li><li>当奖励的承诺释放多巴胺的时候，你更容易受到其他形式的诱惑。</li><li>大量分泌的多巴胺会放大“及时行乐”的快感，让你不再关心长期的后果。</li><li>如果你咬了一口店里新推出的肉桂卷，你就会发现自己又往购物车里多放了几件东西。即便你抵挡住了样品的诱惑，你也会因为大脑释放了更多的多巴胺而去寻找一些东西，以满足你奖励的承诺。</li><li>大脑的奖励系统对新鲜感和多样性也会有反应。你的多巴胺神经元会对熟悉的奖励反应较少</li><li>虽然我们所处的世界总让我们产生欲望，但我们只要用心观察，就能看透一些东西。知道那是怎么一回事并不能完全消除你的欲望，但它能让你至少有机会抗争一下，锻炼一下“我不要”力量。</li><li>我们的奖励系统面对可能获得的大奖会更加兴奋。它会促使我们去做任何可能获奖的事。这就是为什么人们宁愿买乐透彩票，也不愿意把钱存到银行里</li><li>我的学生通过使用音乐、时尚杂志和电视，让自己在做通常会推迟的任务时，产生更多多巴胺，帮助他们找到了解决办法，比如带上可怕的文书工作走进自己喜欢的咖啡厅，边喝热巧克力边完成工作，或是极富创意地买一堆刮刮乐彩票，把它们放在你想拖延的项目周围。还有一些人想象自己努力工作后取得的最佳结果，让未来的奖励显得更加真实。如果有什么事让你觉得很不愉快，所以你总是拖延着不去做，你能不能把它和能让多巴胺神经元燃烧的事联系在一起，从而促使自己去做呢？</li><li>如果我们能够停下来观察一下，自己在有所渴望的时候，大脑和身体中究竟发生了什么事情，我们就会发现，奖励的承诺带给我们的压力和快乐几乎不分上下。渴望并不是总能让我们感觉良好。有时候，它会让我们觉得自己堕落了。这是因为，多巴胺的首要功能是让我们追求快乐，而不是让我们快乐。它并不介意给我们来点压力，即便这会让我们在追求快乐的时候觉得不快乐。</li><li>大部分人会更关注对快乐的承诺，而不关注多巴胺刺激欲望时感觉到的不快乐。</li><li>我们误把渴望的感觉当做了快乐的保证。</li><li>我们误以为的快乐源泉，其实正是痛苦的根源。</li><li>当我们的奖励系统平静下来时，我们并不会感到满足，而更可能表现得冷漠。这就是为什么很多帕金森病人会觉得抑郁，而不是安宁，因为他们的大脑无法产生足够的多巴胺。</li><li>我们需要奖励的承诺，让我们保持对生活的兴趣，并继续生活下去。如果我们幸运的话，奖励系统会继续这样为我们服务下去。同时，我们也希望它不要和我们作对。我们所处的世界充满了科学技术、广告和各种各样的机会，我们总是产生欲望，却很少得到满足。如果我们想拥有自控力，就需要区分让我们的生活有意义的真实奖励，和让我们分散精力、上瘾的虚假奖励。学会区分这两种奖励，也许是我们能做到的最好的事了。</li><li>欲望没有绝对的好坏之分，重要的是欲望将我们引向哪个方向，以及我们是否足够明智，知道什么时候该听从欲望的声音。</li></ul><h1 id="“那又如何”：情绪低落为何会使人屈服于诱惑？"><a href="#“那又如何”：情绪低落为何会使人屈服于诱惑？" class="headerlink" title="“那又如何”：情绪低落为何会使人屈服于诱惑？"></a>“那又如何”：情绪低落为何会使人屈服于诱惑？</h1><ul><li>在研究压力、焦虑、罪恶感对自控力的影响时，我们发现，情绪低落会使人屈服，而且经常是以令人吃惊的方式屈服。令人恐惧的吸烟警示会让烟民更渴望香烟，经济危机会让人更想购物，晚间新闻会让人吃得更多。</li><li>当你感到压力时，你的大脑就会指引着你，让你去做它认为能带给你快乐的事情。</li><li>神经科学家证明了，压力包括愤怒、悲伤、自我怀疑、焦虑等消极情绪，会使你的大脑进入寻找奖励的状态。只要你的大脑和奖励的承诺联系起来，你就会渴望得到那个“奖励”。</li><li>奖励的承诺和缓解压力的承诺会导致各种各样不合逻辑的行为。比如，一项经济学研究发现，那些对自己的经济状况表示担忧的女性，会通过购物来排解内心的焦虑和压抑。</li><li>有效和无效的策略最主要的区别是什么？真正能缓解压力的不是释放多巴胺或依赖奖励的承诺，而是增加大脑中改善情绪的化学物质，如血清素、γ-氨基丁酸和让人感觉良好的催产素。这些物质还会让大脑不再对压力产生反应，减少身体里的压力荷尔蒙，产生有治愈效果的放松反应。</li><li>根据“恐惧管理”理论，当人类想到自己的死亡时，很自然会觉得害怕。我们可以暂时避开危险，但终究逃不过宿命。每当我们想起自己不可能永生时（比如，看晚间新闻的时候，每29秒我们就会有一次这样的想法），大脑就会产生恐惧的反应。我们并非总能意识到这一点，因为焦虑可能还没有浮出水面，还没有产生强烈的不适感，或者我们并不知道这是为什么。即使我们意识不到这种恐惧，它还是会让我们立即作出回应，对抗自己的无力感。我们会去寻找保护伞，寻找任何能让自己觉得安全、有力量、得到安慰的东西</li><li>研究发现，当我们意识到自己不会永生时，我们会更容易屈服于各种诱惑，就像是在奖励和减压的承诺里寻找希望和安全感一样。</li><li>一项调查发现，新闻中的死亡报道会让观众对豪华轿车、劳力士手表等彰显身份地位的东西产生更积极的回应。这并不是说，我们认为一块劳力士手表就能让自己不被导弹打中，而是这些商品提升了我们的自我形象，让我们感到充满力量。对很多人来说，购物是让自己更乐观、更有掌控感的快速途径。这就是美国人为什么在“9·11”事件后如此愿意接受小布什总统的提议：“我和我夫人鼓励美国人购物。”</li><li>“恐惧管理”的方法能让我们不去想那个不可避免的死亡。但当我们在诱惑中寻找慰藉的时候，我们是在不自觉地加速迈向坟墓的脚步。</li><li>有时候，“恐惧管理”带来的不是诱惑，而是拖延。我们最想拖延的很多事情，都和死亡有或多或少的关联，比如预约看医生，按处方开药，遵医嘱服药，保管法律文件和写遗嘱，存钱养老，甚至是扔掉自己绝不会用到的东西和不合身的衣服。</li><li>远离那些会让你产生恐惧的电视新闻、访谈节目、杂志或网页。</li><li>毫无意外，头天晚上喝了太多酒的人第二天早上会感到痛苦，会觉得头疼、恶心、疲倦。但他们的痛苦不仅仅源于宿醉。很多人还感到罪恶和羞愧。这才是真正让人感到困扰的。当被试者因为前一晚饮酒过量而情绪低落时，他们更可能在当天晚上或以后喝更多的酒。罪恶感驱使他们再度饮酒。</li><li>屈服会让你对自己失望，会让你想做一些改善心情的事。那么，最廉价、最快捷的改善心情的方法是什么？往往是做导致你情绪低落的事。</li><li>关键是，导致更多堕落的行为并不是第一次的放弃，而是第一次放弃后产生的羞耻感、罪恶感、失控感和绝望感。一旦你陷入了这样的循环，似乎除了继续做下去，就没有别的出路了。当你（又一次）责备自己（又一次）屈服于诱惑的时候，往往会带来更多意志力的失效，造成更多的痛苦。但是，你寻求安慰的东西并不能中断这个循环，它只会给你带来更深切的罪恶感。</li><li>我们可能会想，罪恶感会促使我们改正错误，但其实这正是“情绪低落让我们屈服于诱惑”的另一个表现方式。</li><li>众多研究显示，自我批评会降低积极性和自控力，而且也是最容易导致抑郁的因素。它不仅耗尽了“我要做”的力量，还耗尽了“我想要”的力量。相反，自我同情则会提升积极性和自控力，比如，在压力和挫折面前支持自己、对自己好一些。</li><li>出人意料的是，增强责任感的不是罪恶感，而是自我谅解。研究人员发现，在个人挫折面前，持自我同情态度的人比持自我批评的态度的人更愿意承担责任。他们也更愿意接受别人的反馈和建议，更可能从这种经历中学到东西。</li><li>自我谅解能帮助人们从错误中恢复过来，因为它能消除人们想到失败时的羞愧和痛苦。</li><li>如果你觉得遇到挫折意味着你将一事无成、只会把事情搞糟，那么反思这个挫折只会让你在痛苦中更讨厌自己。你最紧迫的目标是安抚这种感觉，而不是吸取教训。</li><li>你只是个凡人。每个人都会遇到意志力挑战，每个人都有失去自控的时候。这只是人性的组成部分，挫折并不意味着你本身有问题。想一想这些说法是不是真的。你能想象你尊敬、关心的其他人也经历过同样的抗争和挫折吗？这个视角会让自我批评和自我怀疑的声音变得不那么尖锐。</li><li>压力会引起欲望，让我们的大脑更容易受到诱惑。如果有东西提醒我们不能永生，就会让我们从食物、购物或香烟中寻找慰藉。那么罪恶感和自我批评呢？它们会让你立刻想到“那又如何，我还不如再放纵一下自己呢”。</li><li>发誓改变会让我们充满希望。我们喜欢想象改变后的生活，幻想改变后的自己。研究显示，节食计划会让人感觉更有力量，运动计划会让人觉得自己更高大。（当然，这些幻想不一定会实现。）</li><li>不幸的是，就像奖励的承诺和缓解压力的承诺一样，改变的承诺也很少能朝我们希望的方向发展。不切实际的乐观可能给我们一时的快乐，但接下来我们就会感到失落。</li><li>当我们第一次面对挫折时，失望就会取代最初决定改变时的良好感觉。没能达到预期目标会再度引发曾经的罪恶感、抑郁和自我怀疑，而承诺改变的情绪慰藉作用也消失了。这时，大多数人会彻底放弃努力。只有当我们感觉失控，需要再次拥有希望的时候，我们才会再次发誓作出改变。于是，这个循环又开始了。</li><li>我们需要相信，改变是可能做到的。如果失去了希望，我们就会听天由命了。但是，我们必须避免常见的意志力陷阱，即用“改变的承诺”而不是“改变”来改善我们的心情。否则，这种看似意志力的东西就会把我们变成按压杠杆的小白鼠，觉得这个东西能让我们获得奖励。</li><li>乐观给我们动力，但少许的悲观能帮我们走向成功。研究发现，如果能预测自己什么时候、会如何受到诱惑和违背承诺，你就更有可能拥有坚定的决心。</li><li>为了避免压力导致的意志力失效，我们需要找到能让我们真正快乐的东西，而不是虚假的奖励承诺，也不是空洞的改变承诺。我们需要允许自己去做真正让自己快乐的事，远离那些与我们生活无关的压力根源。当我们遭遇挫折时（这种情况是难以避免的），我们需要原谅曾经的失败，不要把它们作为屈服或放弃的借口。想要增强自控力，自我同情比自我打击有效得多。</li></ul><h1 id="出售未来：及时享乐的经济学"><a href="#出售未来：及时享乐的经济学" class="headerlink" title="出售未来：及时享乐的经济学"></a>出售未来：及时享乐的经济学</h1><ul><li>如果我们处在最佳状态，人类控制冲动的能力让其他物种自惭形秽。但通常情况下，我们想象力丰富的大脑不会作出最有战略性的决定，而是让我们表现得像是失去了理性。这是因为，前额皮质最擅长的不是自控。它会为错误的决定寻找借口，向我们承诺明天会更好。你可以肯定，那些黑猩猩不会对自己说：“我现在要吃2颗葡萄，因为我还有下一次可以等着吃6颗葡萄。”但人类总有各种各样的花招，让自己相信抵抗诱惑是明天的事情。因此，拥有巨大前额皮质的我们，会一再屈服于即刻的满足感。</li><li>为了迅速得到瞬间的快感，他们忘记了自己真正想要的东西。</li><li>经济学家称之为“延迟折扣”。也就是说，等待奖励的时间越长，奖励对你来说价值越低。很小的延迟就能大幅降低你感知到的价值。</li><li>当诱惑真实存在时，我们的大脑就进入了“搜寻奖励”模式，确保我们不会错过任何奖励。</li><li>当我们和诱惑正面交锋的时候，我们只愿意选择短期的、即时的奖励，这种欲望是无可抵挡的。这就带来了“有限意志力”。也就是说，到我们真的需要自控力之前，我们一直拥有自控力。</li><li>我们在权衡“即时奖励”和“未来奖励”时，大脑处理选项的方式相当不一样。“即时奖励”会激活更古老、更原始的奖励系统，刺激相应的多巴胺产生欲望。“未来奖励”则不太能激活这个奖励系统。</li><li>对那些想延迟快感的人来说，这是个好消息。只要你能创造一点距离，就会让拒绝变得容易起来。</li><li>当他对自己的欲望直截了当地说“不”时，那句“好，但要等10分钟”减少了一部分的恐惧和压力，让他等起来更轻松。几次之后，他就能转移注意力，忘掉吸烟的冲动了。</li><li><p>当你觉得自己无法做到“不会有下一次”的时候，不妨用“10分钟延迟法则”来增强你的自控力。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 当你受到诱惑要做与长期利益相悖的事时，请想象一下，这个选择就意味着，你为了即时的满足感放弃了更好的长期奖励。</span><br><span class="line">2. 想象你已经得到了长期的奖励。想象未来的你正在享受自控的成果。</span><br><span class="line">3. 然后扪心自问：你愿意放弃它，来换取正在诱惑你的短暂快感吗？</span><br></pre></td></tr></table></figure></li><li><p>大脑会把未来的自己当成别人，这种习惯对自控力影响极大。研究发现，当你想到未来的自己时，大脑中越是想不到自己，你就越可能对未来的自己说“去你的”，也就越可能对即时的满足感说“好”。</p></li><li>当我们思考未来时，我们能预测到未来的自己和想象中有什么不同。未来的奖励似乎并不那么有诱惑力，所以我们选择了即时的满足感。我们无法预测自己会怎么受到诱惑、怎么被分散注意力，所以我们无法坚定自己的目标。如果我们想作出更明智的决定，就要更好地理解和支持未来的自己。我们还需要记住，为现在的行为承担后果的，看似是未来的自己，实际上还是我们自己。未来的自己会对我们现在的付出感激不尽。</li></ul><h1 id="传染：为什么意志力会传染？"><a href="#传染：为什么意志力会传染？" class="headerlink" title="传染：为什么意志力会传染？"></a>传染：为什么意志力会传染？</h1><ul><li>意志力薄弱可能会传染，但你仍然可以获得自控力。</li><li>我们有模仿别人行动的本能，这就意味着，当你看到别人去拿零食、饮料或信用卡的时候，你自己也会无意识地模仿他们的行为。同时，你也会失去自己的意志力。</li><li>当我们想象别人想要什么的时候，他们的欲望就会引发我们的欲望，他们的食欲也会引发我们的食欲。</li><li>有时候，我们感染的不是某种具体的目标，比如吃零食、花钱、诱惑陌生人，而是和我们的冲动一致的、更普遍的目标。</li><li>人们感染的目标是做自己想做的事，而不是自己应该做的事。</li><li>为什么在关系密切的人中间，行为会传染得这么严重呢？我们可以用免疫系统作个类比。只有当免疫系统发现那些人“和我们不同”时，它才会拒绝他们的目标和行为。毕竟，我们体内的免疫系统不会攻击自身的细胞。只要它能辨别出那是自己的东西，它就不会作出任何反应。</li><li>当我们想到我们喜爱、尊重的人和感觉相似的人时，我们的大脑会像对待自己一样对待他们，而不会把他们视为“别人”。</li><li>当他们认识到自己的行为与信仰不符时，鼓励他们去制订改变行为的计划。相信好的基督徒应该减肥和锻炼身体，这是强有力的“社会认同”，远比检测出高胆固醇后医生的严厉警告来得有效。</li><li>如果我们想让别人更有意志力，就要让他们相信自控是个社会规范。</li><li>2010年《内科医学档案》中的一份报告指出，有37%的人在被临床诊断为肥胖后，不仅认为自己并不胖，还相信自己变胖的风险很低。</li><li>在说到“社会认同”的时候，我们认为别人做的事比别人实际做的更重要。比如，大学生对身边同学普遍作弊的情况估计过高。要想知道一个学生有没有作弊，要看他是否相信别人也在作弊，而不是看作弊的惩罚是否严厉，也不是看他是否认为自己会被抓。当他们相信自己的同学作了弊时，原本诚实的班级也会变成所有学生都在考试中发短信、传答案的班级。（是的，我曾抓到一个学生抄别人答案。）</li><li>如果我们认为别人还在做我们试图改掉的不良行为，那么“社会认同”就会妨碍我们作出改变。</li><li>自豪和羞愧依赖大脑皮层的情绪区，而不是用来作逻辑分析的前额皮层。社会情感可能进一步帮助我们作出选择，让我们在自己的群体里站稳脚跟。</li><li>实验研究发现，表现出内疚感会减少心率的变化，降低意志力的生理储备。反之，自豪感会保持甚至增加这种储备。</li><li>为了让自豪感发挥作用，我们必须认为别人都在监视自己，或我们有机会向别人报告自己的成功。</li><li>让自己坚定决心的有效策略是——公开你的意志力挑战</li><li>研究显示，人一旦被踢出群体，意志力就会耗竭。举个例子，当人们被社会拒绝时，他们就很难抵制新鲜出炉的曲奇饼干，面对具有挑战性的任务会很快放弃，在需要精神集中的实验里也更容易分心。</li><li>研究也显示，少数族群越是受到歧视，自我控制能力就越差。这只是提醒少数族群，歧视会耗尽他们的意志力。只要我们觉得被排斥或被冒犯，我们就有可能屈服于自己最糟糕的冲动。</li><li>值得注意的是，我们的大脑会把别人的目标、信念和行为整合到自己的决策中。当我们跟别人在一起时，或者只是简单地想到他们时，在我们的脑海里，别人就会成为另一个“自我”，并且和“自我”比赛自控。反之亦然：我们的行为也影响了其他无数人，我们做的每个选择对别人来说也是一种鼓舞或诱惑。</li></ul><h1 id="别读这章：“我不要”力量的局限性"><a href="#别读这章：“我不要”力量的局限性" class="headerlink" title="别读这章：“我不要”力量的局限性"></a>别读这章：“我不要”力量的局限性</h1><ul><li>没法不去想白熊，这或许不是最糟糕的意志力失效的案例。但正如我们所见，越是不让我们想一件事，我们就会越去想它。对焦虑、沮丧、节食、上瘾的最新调查证实，把“我不要”的力量用在涉及思想、情感的内心世界，它就会失效。当深入内心世界时，我们会发现，我们需要给自控一个全新的定义，给放弃自控留出一点空间来。</li><li>当人们试图摆脱某种想法时，它却像回飞镖一样“嗖”地飞回来了。</li><li>压抑人的本能时，就会产生这种讽刺性反弹效应。</li><li>韦格纳认为，这和大脑如何处理“不要去想”这个指令有关。大脑把这个指令分为两部分，分别由两个不同系统去执行。大脑的一部分负责将人的注意力从被禁止的想法那里引开，就像韦格纳第一个实验中那位设法不去想白熊的女士一样，“我试着去想白熊以外的其他所有东西……嘿，看看这面棕色的墙”。韦格纳将这个过程称为“操作”。“操作”依靠大脑的自控系统来完成。和所有需要付出努力的自我控制一样，这需要耗费大量的精力和能量。大脑的另一部分则负责寻找证据，证明你没有去想、去感觉、去做你不该去想、去感觉、去做的事，就像那位年轻的女士观察到的：“我想呀想呀想……每当我试着不去想白熊的时候，我其实总是想着它。”韦格纳将这个过程称为“监控”。“监控”和“操作”不同，它自动运行，无须耗费大量精力。“监控”与大脑的自动危险检测系统的联系更紧密。自动自控！这听起来可能很棒，但如果你认识到了“操作”与“监控”的配合有多重要，你就不会这么想了。无论基于什么原因，只要“操作”减弱了，“监控”就会成为自控的噩梦。</li><li>疲惫的“操作”和精力充沛的“监控”造成了大脑的不平衡，这会带来问题。当“监控”寻找被禁的内容时，它会让人不断想起要寻找的目标。神经学家指出，大脑的潜意识不断想到被禁止的内容。这么做的结果是，你会想到、感觉到或去做自己正在努力避免的事。</li><li>无论你想摆脱哪种恐惧或欲望，它们最后都会变得更让人信服，更引人注目。</li><li>怎么才能找到摆脱这种困境的方法呢？韦格纳提出了一种对抗讽刺性反弹的方法。这个方法本身就很有讽刺意味——这个方法就是放弃自控。当人们不再试图控制那些不希望出现的想法和情绪时，它们也就不会再来烦你了。</li><li>结果证明，这种方法对消除许多不好的内心感受都有用，它的适用范围大得令人吃惊。去想自己所想，追随自己的感觉（你不必相信它是真的，不要觉得必须采取行动），这是治疗焦虑、抑郁、嗜食和各种上瘾症状的有效方法。我们通过这些证据可以看到，放弃控制内心感受，反而能让我们更好地控制外在行为。</li><li>如果不和焦虑对抗，焦虑就会自然离去。</li><li>忠于你的感受，但别相信你所有的想法</li><li>直面自身欲望，但不要付诸行动。</li><li>当冲动占据你的头脑时，花至少一分钟去感觉自己的身体。你的冲动是什么样的？是热的还是冷的？身体有没有感到不舒服？心率、呼吸或内脏有什么变化？保持这个状态至少一分钟。看看这些感觉在强度或特性上有什么变化。</li><li>驾驭冲动不只适用于戒除癖好，还能帮助你掌控有害的冲动。</li><li>对内接受自我，对外控制行动。</li><li>抑制欲望的反面不是自我放纵。</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><ul><li>我们天生就有自控的能力，即便有时我们不太会运用这种能力。它们帮我们找到失败的原因，为我们指出可行的解决方法。它们甚至告诉我们，做人意味着什么。</li><li>在未来的人生道路上，请保持科学家的心态。尝试新鲜事物，收集自己的数据，根据证据作出判断。对出人意料的想法保持开放的心态，从失败和成功中汲取经验教训。坚持有效的方法，和他人分享你了解的知识。面对复杂的人性和现代社会的诱惑，我们最好能做到这几点。但是，如果我们能保持好奇心和自我同情，那对付它们就绰绰有余了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？&quot;&gt;&lt;a href=&quot;#我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？&quot; class=&quot;headerlink&quot; title=&quot;我要做，我不要，我想要：什么是意志力？为什么意志力至关重要？&quot;&gt;
      
    
    </summary>
    
      <category term="泛 - 书摘" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E4%B9%A6%E6%91%98/"/>
    
    
      <category term="自控力" scheme="https://blog.pazyx.xyz/tags/%E8%87%AA%E6%8E%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>吃草 - 打铁</title>
    <link href="https://blog.pazyx.xyz/2018/11/06/2018_icpc_qingdao_regional/"/>
    <id>https://blog.pazyx.xyz/2018/11/06/2018_icpc_qingdao_regional/</id>
    <published>2018-11-05T16:00:24.000Z</published>
    <updated>2018-11-06T00:19:27.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-2018-ACM-ICPC-Asia-Qingdao-Regional-Contest"><a href="#The-2018-ACM-ICPC-Asia-Qingdao-Regional-Contest" class="headerlink" title="The 2018 ACM-ICPC Asia Qingdao Regional Contest"></a><center>The 2018 ACM-ICPC Asia Qingdao Regional Contest</center></h1><center><a href="http://acm.zju.edu.cn/contest-materials/qd2018/qd2018_problems.pdf" target="_blank" rel="noopener">试题</a> | <a href="http://acm.upc.edu.cn/rank/" target="_blank" rel="noopener">终榜</a></center><p><br></p><p><img src="/2018/11/06/2018_icpc_qingdao_regional/IMG_1515.JPG" alt=""></p><p><br></p><h1 id="三题残酷打铁"><a href="#三题残酷打铁" class="headerlink" title="三题残酷打铁"></a><center>三题残酷打铁</center></h1><h2 id="Problem-C-Flippy-Sequence"><a href="#Problem-C-Flippy-Sequence" class="headerlink" title="Problem C. Flippy Sequence"></a>Problem C. Flippy Sequence</h2><p><img src="/2018/11/06/2018_icpc_qingdao_regional/Problem C. Flippy Sequence_0.png" alt=""></p><p><img src="/2018/11/06/2018_icpc_qingdao_regional/Problem C. Flippy Sequence_1.png" alt=""></p><h2 id="Problem-J-Books"><a href="#Problem-J-Books" class="headerlink" title="Problem J. Books"></a>Problem J. Books</h2><p><img src="/2018/11/06/2018_icpc_qingdao_regional/Problem J. Books.png" alt=""></p><h2 id="Problem-M-Function-and-Function"><a href="#Problem-M-Function-and-Function" class="headerlink" title="Problem M. Function and Function"></a>Problem M. Function and Function</h2><p><img src="/2018/11/06/2018_icpc_qingdao_regional/Problem M. Function and Function.png" alt=""></p><p><br></p><h1 id="铁牌区的友谊"><a href="#铁牌区的友谊" class="headerlink" title="铁牌区的友谊"></a><center>铁牌区的友谊</center></h1><p><img src="/2018/11/06/2018_icpc_qingdao_regional/IMG_1542.jpg" alt=""></p><center>燃烧我的判题机(BURN MY OJ) 🤝 猛吃草(VnEpCxmR)</center><p><br></p><h1 id="《打铁归来》"><a href="#《打铁归来》" class="headerlink" title=" 《打铁归来》 "></a><center> 《打铁归来》 </center></h1><p>由著名波普艺术家赵砚潇拍摄的大电影《打铁归来》将在近日登陆 <a href="https://www.youtube.com/channel/UCJzVbUq9UE_OjHpWymygPSg?view_as=subscriber/" target="_blank" rel="noopener">YouTube</a>，敬请期待。</p><p><br><br><br></p><p><center><font size="20">“输入理想程序，输出快乐人生。”</font></center><br><br></p><p><center><font size="20">谢谢大家！</font></center><br><br><br><br></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;The-2018-ACM-ICPC-Asia-Qingdao-Regional-Contest&quot;&gt;&lt;a href=&quot;#The-2018-ACM-ICPC-Asia-Qingdao-Regional-Contest&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="泛 - 纪念" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E7%BA%AA%E5%BF%B5/"/>
    
    
      <category term="ACM" scheme="https://blog.pazyx.xyz/tags/ACM/"/>
    
      <category term="纪念" scheme="https://blog.pazyx.xyz/tags/%E7%BA%AA%E5%BF%B5/"/>
    
      <category term="ICPC" scheme="https://blog.pazyx.xyz/tags/ICPC/"/>
    
      <category term="青岛" scheme="https://blog.pazyx.xyz/tags/%E9%9D%92%E5%B2%9B/"/>
    
  </entry>
  
  <entry>
    <title>「记」0x03 二零一八年十月二十九日凌晨人民喝不到冰镇可乐</title>
    <link href="https://blog.pazyx.xyz/2018/10/29/weekly_3/"/>
    <id>https://blog.pazyx.xyz/2018/10/29/weekly_3/</id>
    <published>2018-10-28T16:13:47.000Z</published>
    <updated>2018-10-28T16:20:48.817Z</updated>
    
    <content type="html"><![CDATA[<p>二零一八年十月我因为半夜出去买可乐已经刷了四次晚归，然而五次就要记过…</p><p>我们没有办法，只能痛苦的入睡…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二零一八年十月我因为半夜出去买可乐已经刷了四次晚归，然而五次就要记过…&lt;/p&gt;
&lt;p&gt;我们没有办法，只能痛苦的入睡…&lt;/p&gt;

      
    
    </summary>
    
      <category term="泛 - 记" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%B0/"/>
    
    
      <category term="可乐" scheme="https://blog.pazyx.xyz/tags/%E5%8F%AF%E4%B9%90/"/>
    
      <category term="自由" scheme="https://blog.pazyx.xyz/tags/%E8%87%AA%E7%94%B1/"/>
    
      <category term="记" scheme="https://blog.pazyx.xyz/tags/%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营解题总结（第二周）//ToDo</title>
    <link href="https://blog.pazyx.xyz/2018/08/12/algor_club_code_2/"/>
    <id>https://blog.pazyx.xyz/2018/08/12/algor_club_code_2/</id>
    <published>2018-08-11T16:30:49.000Z</published>
    <updated>2018-12-13T13:52:31.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意-amp-代码实现"><a href="#题目大意-amp-代码实现" class="headerlink" title="题目大意 &amp; 代码实现"></a>题目大意 &amp; 代码实现</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>给出n个整数，将它们从小到大排序后输出。</p><ul><li>对于前30%的数据，n ≤ 100，给出的n个整数的绝对值不超过10；</li><li>对于前60%的数据，n ≤ 5000，给出的n个整数的绝对值不超过10^9；</li><li>对于另20%的数据，n ≤ 500000，给出的n个整数的绝对值不超过10^5；</li><li>对于100%的数据，n ≤ 500000，给出的n个整数的绝对值不超过10^9。</li></ul><p>时间：2 sec<br>空间：256 MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        a.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(),a.end());</span><br><span class="line">    <span class="comment">//a = getAnswer(n, a);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, a[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>有n个正整数排成一排，你要将这些数分成m份（同一份中的数字都是连续的，不能隔开），同时数字之和最大的那一份的数字之和尽量小。</p><ul><li>对于50%的数据，n ≤ 100，给出的n个正整数不超过10；</li><li>对于100%的数据，m ≤ n ≤ 300000，给出的n个正整数不超过1000000。</li></ul><p>时间：4 sec<br>空间：512 MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> d, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>( a[i] &gt; d )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        sum += a[i];</span><br><span class="line">        <span class="keyword">if</span>( sum &gt; d ) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            i--;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt; m)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所给数组分成连续的m份，使得数字之和最大的那一份的数字之和最小</span></span><br><span class="line"><span class="comment">// n：数组大小</span></span><br><span class="line"><span class="comment">// m：题中的m</span></span><br><span class="line"><span class="comment">// a：所给数组，大小为n</span></span><br><span class="line"><span class="comment">// 返回值：最优方案中，数字之和最大的那一份的数字之和</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        r += a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( l &lt;= r ) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid, n, m, a))</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getAnswer(n, m, a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="大转盘"><a href="#大转盘" class="headerlink" title="大转盘"></a>大转盘</h2><p>邓老师有一个大转盘，被平分成了 2^n 份。<br>邓老师还有一个长度为 2^n 的数组 a（下标从 0 开始），其中的每个元素都是 0 或 1。于是邓老师就可以选择大转盘上的一个位置，将 a[0] 填入其中，然后按顺时针顺序依次将 a[1],a[2],…,a[2^n-1] 填入。<br>对于大转盘上的一个指定位置，邓老师可以从它开始，取出顺时针方向的 n 个位置，并将它们按原顺序拼接起来，得到一个长度为 n 的 01 串，也就是一个 n 位二进制数。我们把这个二进制数称作从这个位置开始的幸运数。<br>显然地，大转盘上共有 2^n 个位置可以获得幸运数，而巧合的是 n 位二进制数恰好也有 2^n 个，所以邓老师希望这些所有的幸运数包含了所有的 n 位二进制数。<br>请输出一个数组 a，使其满足邓老师的要求。（如果有多解，输出任一即可）</p><p>本题包含 16 个测试点。对于第 i 个测试点（1&lt;=i&lt;=16），满足 n=i。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> allOne;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; vis[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">string</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">twoPow</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i][u])&#123;</span><br><span class="line">            <span class="keyword">int</span> v = ((u &lt;&lt; <span class="number">1</span>) | i) &amp; allOne;</span><br><span class="line">            vis[i][u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            dfs(v);</span><br><span class="line">            ans.push_back(<span class="string">'0'</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本函数求解大转盘上的数，你需要把大转盘上的数按顺时针顺序返回</span></span><br><span class="line"><span class="comment">// n：对应转盘大小，意义与题目描述一致，具体见题目描述。</span></span><br><span class="line"><span class="comment">// 返回值：将大转盘上的数按顺时针顺序放到一个string中并返回</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    allOne = twoPow(n - <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">    ans = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i )</span><br><span class="line">        vis[i].resize(twoPow(n - <span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; getAnswer(n) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="象棋"><a href="#象棋" class="headerlink" title="象棋"></a>象棋</h2><p>你有足够多的象棋“车”，在一个n×n的棋盘上你能放多少个“车”呢？注意，所给棋盘上有些位置不能放任何东西。同时，某一行（列）最多只能存在一个“车”。</p><ul><li>对于30%的数据，n ≤ 5；</li><li>对于60%的数据，n ≤ 20；</li><li>对于100%的数据，n ≤ 500。</li></ul><p>时间：2 sec<br>空间：256 MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span> * <span class="number">2</span>, M = N * N;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, to;</span><br><span class="line">&#125; e[M];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt, ihead[N], mc[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    e[cnt].next = ihead[x];</span><br><span class="line">    e[cnt].to = y;</span><br><span class="line">    ihead[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = ihead[x]; i; i = e[i].next )&#123;</span><br><span class="line">        <span class="keyword">int</span> y = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[y])&#123;</span><br><span class="line">            vis[y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(mc[y] == <span class="number">0</span> || dfs(mc[y]))&#123;</span><br><span class="line">                <span class="comment">//3</span></span><br><span class="line">                mc[x] = y;</span><br><span class="line">                mc[y] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求解棋盘上最多能放多少个“车”</span></span><br><span class="line"><span class="comment">// n：棋盘的大小为n×n的</span></span><br><span class="line"><span class="comment">// board：所给棋盘，对于某个位置上的数：若值为1表示可以放“车”；若值为0表示不能放“车”</span></span><br><span class="line"><span class="comment">// 返回值：能放“车”的最大个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++)&#123;</span><br><span class="line">        ihead[i] = <span class="number">0</span>;</span><br><span class="line">        mc[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="comment">//1</span></span><br><span class="line">            <span class="keyword">if</span>(board[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">                add(i,j+n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!mc[i])&#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (n * <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(dfs(i))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; e;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            t.push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">        e.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getAnswer(n, e));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列计数"><a href="#序列计数" class="headerlink" title="序列计数"></a>序列计数</h2><p>给定一个n个整数的序列以及一个非负整数d，请你输出这个序列中有多少个连续子序列（长度大于1），满足该子序列的最大值最小值之差不大于d。</p><ul><li>对于60%的数据，n ≤ 5000；</li><li>对于100%的数据，n ≤ 300000。</li><li>保证所有整数的绝对值不超过10^9，d不超过2×10^9。</li></ul><p>时间：10 sec<br>空间：512 MB</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cmath&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300005</span>;</span><br><span class="line"><span class="keyword">int</span> n,d,max_value[N],min_value[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;<span class="comment">//中点</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = solve(l,mid)+solve(mid+<span class="number">1</span>,r);<span class="comment">//分治求出左右两半的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= r; i++)&#123;</span><br><span class="line">        min_value[i] = (i == mid + <span class="number">1</span>) ? a[i] : min(min_value[i - <span class="number">1</span>], a[i]);</span><br><span class="line">        max_value[i] = (i == mid + <span class="number">1</span>) ? a[i] : max(max_value[i - <span class="number">1</span>], a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mn = <span class="number">0</span>, mx = <span class="number">0</span>, pos = r;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = mid; i &gt;= l &amp;&amp; pos &gt; mid; i--)&#123;</span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line">        mn = (i==mid)?a[i]:min(mn,a[i]);</span><br><span class="line">        mx = (i==mid)?a[i]:max(mx,a[i]);</span><br><span class="line">        <span class="keyword">for</span>(; pos &gt; mid &amp;&amp; max(mx,max_value[pos]) - min(mn,min_value[pos]) &gt; d; pos--);</span><br><span class="line">        ans += pos - mid;<span class="comment">//更新答案</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出有多少个a数组中的连续子序列（长度大于1），满足该子序列的最大值最小值之差不大于d</span></span><br><span class="line"><span class="comment">// n：a数组的长度</span></span><br><span class="line"><span class="comment">// d：所给d</span></span><br><span class="line"><span class="comment">// a：数组a，长度为n</span></span><br><span class="line"><span class="comment">// 返回值：满足条件的连续子序列的个数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> d, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    ::n = n;</span><br><span class="line">    ::d = d;</span><br><span class="line">    ::a = a;</span><br><span class="line">    <span class="keyword">return</span> solve(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;d);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.resize(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getAnswer(n, d, a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小交换"><a href="#最小交换" class="headerlink" title="最小交换"></a>最小交换</h2><p>给定一个 1 到 n 的排列（即一个序列，其中 [1,n] 之间的正整数每个都出现了恰好 1 次）。<br>你可以花 1 元钱交换两个相邻的数。<br>现在，你希望把它们升序排序。求你完成这个目标最少需要花费多少元钱。</p><ul><li>对于 20% 的数据，保证 n&lt;=7。</li><li>对于 60% 的数据，保证 n&lt;=1,000。</li><li>对于 100% 的数据，保证 n&lt;=200,000。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq, seqTemp;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(l, mid);</span><br><span class="line">    mergeSort(mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> p = l, q = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q &gt; r || p &lt;= mid &amp;&amp; seq[p] &lt;= seq[q])</span><br><span class="line">            seqTemp[i] = seq[p++];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            seqTemp[i] = seq[q++];</span><br><span class="line">            cnt += (mid - p + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">        seq[i] = seqTemp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数的功能是计算答案（即最少花费的金钱）</span></span><br><span class="line"><span class="comment">// n：表示序列长度</span></span><br><span class="line"><span class="comment">// a：存储整个序列 a</span></span><br><span class="line"><span class="comment">// 返回值：最少花费的金钱（需要注意，返回值的类型为 64 位有符号整数）</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    seq = a;</span><br><span class="line">    seqTemp.resize(n);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    mergeSort(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    a.clear();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        a.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = getAnswer(n, a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="楼尔邦德"><a href="#楼尔邦德" class="headerlink" title="楼尔邦德"></a>楼尔邦德</h2><p>给定包含 n 个数的序列 A。<br>再给出 Q 个询问，每个询问包含一个数 x，询问的是序列 A 中不小于 x 的最小整数是多少（无解输出-1）。</p><ul><li>对于 50% 的数据，保证 n&lt;=2000。</li><li>对于 100% 的数据，保证 n&lt;=300,000。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">// #include &lt;iostream&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本函数传入数组 a 及所有询问，你需要求解所有询问并一并返回</span></span><br><span class="line"><span class="comment">// n：序列 a 的长度</span></span><br><span class="line"><span class="comment">// a：存储了序列 a</span></span><br><span class="line"><span class="comment">// Q：询问个数</span></span><br><span class="line"><span class="comment">// query：依次存储了所有询问的参数 x</span></span><br><span class="line"><span class="comment">// 返回值：一个 vector&lt;int&gt;，依次存放各询问的答案</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAnswer(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> Q, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; query) &#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    ans.clear();</span><br><span class="line">    sort(a.begin(), a.end());</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> key = query[i];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">-1</span>,r = n,mid;</span><br><span class="line">        <span class="keyword">while</span>(l+<span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid] &lt; key)</span><br><span class="line">                l = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> pos = r;</span><br><span class="line">        <span class="keyword">if</span>(pos &gt;= n)</span><br><span class="line">            ans.push_back(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ans.push_back(a[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, Q, tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, query;</span><br><span class="line">    a.clear();</span><br><span class="line">    query.clear();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        a.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tmp);</span><br><span class="line">        query.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = getAnswer(n, a, Q, query);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Q; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>给定一张 n 个点的无向带权图，节点的编号从 1 至 n，求从 S 到 T 的最短路径长度。</p><p>本题共设置 12 个测试点。</p><ul><li>对于前 10 个测试点，保证 n&lt;=2500，m&lt;=6200，对于每条边有 w&lt;=1000。这部分数据有梯度。</li><li>对于所有的 12 个测试点，保证 n&lt;=100,000，m&lt;=250,000。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;set&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">100050</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next, weight;</span><br><span class="line">    edge(<span class="keyword">int</span> ne,<span class="keyword">int</span> we):next(ne),weight(we)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; P;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt;G[MAX_N];   <span class="comment">//邻接表表示的图</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MAX_N];</span><br><span class="line"><span class="comment">//int path[MAX_N];</span></span><br><span class="line"><span class="keyword">bool</span> collected[MAX_N];  <span class="comment">//标记每个顶点是否被收录</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(collected,<span class="number">0</span>,<span class="keyword">sizeof</span>(collected));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;P, less&lt;P&gt; &gt; min_heap;  </span><br><span class="line">    <span class="comment">//用 set 来伪实现一个小根堆，并具有映射二叉堆的功能。</span></span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    min_heap.insert(make_pair(<span class="number">0</span>, start));</span><br><span class="line">    collected[start] = <span class="literal">true</span>;   </span><br><span class="line">    <span class="keyword">while</span>(min_heap.size())&#123;    </span><br><span class="line">    <span class="comment">//如果堆为空，说明所有点都已被收录，结束该算法</span></span><br><span class="line">        <span class="keyword">auto</span> iter = min_heap.begin();</span><br><span class="line">        <span class="keyword">int</span> v = iter-&gt;second;</span><br><span class="line">        min_heap.erase(*iter);</span><br><span class="line">        collected[v] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[v].size(); i++)&#123;</span><br><span class="line">            edge e = G[v][i];</span><br><span class="line">            <span class="keyword">if</span>(!collected[e.next] </span><br><span class="line">            &amp;&amp; dist[e.next] &gt; dist[v] + e.weight)</span><br><span class="line">            &#123;</span><br><span class="line">                min_heap.erase(make_pair(dist[e.next], e.next));    </span><br><span class="line">                dist[e.next] = dist[v] + e.weight;</span><br><span class="line">                <span class="comment">//path[e.next] = v;</span></span><br><span class="line">                min_heap.insert(make_pair(dist[e.next], e.next));   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数用于计算答案（最短路）</span></span><br><span class="line"><span class="comment">// n：节点数目</span></span><br><span class="line"><span class="comment">// m：双向边数目</span></span><br><span class="line"><span class="comment">// U,V,W：分别存放各边的两端点、边权</span></span><br><span class="line"><span class="comment">// s,t：分别表示起点、重点</span></span><br><span class="line"><span class="comment">// 返回值：答案（即从 s 到 t 的最短路径长度）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; U, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; W, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        G[U[i]].push_back(edge(V[i],W[i]));</span><br><span class="line">        G[V[i]].push_back(edge(U[i],W[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(s);</span><br><span class="line">    <span class="keyword">return</span> dist[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; U, V, W;</span><br><span class="line">    U.clear();</span><br><span class="line">    V.clear();</span><br><span class="line">    W.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        U.push_back(u);</span><br><span class="line">        V.push_back(v);</span><br><span class="line">        W.push_back(w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, shortestPath(n, m, U, V, W, s, t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><h2 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h2><p>涉及题目：</p><ul><li>分组</li><li>序列计数</li><li>楼尔邦德</li></ul><h2 id="Dijkstra-的局限"><a href="#Dijkstra-的局限" class="headerlink" title="Dijkstra 的局限"></a>Dijkstra 的局限</h2><p>之前只认为，Dijkstra 算法不可以处理带有负值圈的图。实际上 Dijkstra 在处理有复值边权的图时很可能不正确。</p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 -&gt; 2 w = 1</span><br><span class="line">1 -&gt; 3 w = 2</span><br><span class="line">2 -&gt; 4 w = 1</span><br><span class="line">3 -&gt; 2 w = -2</span><br></pre></td></tr></table></figure></p><p>正确答案为 1，Dijkstra 给出的答案为 2 。</p><h2 id="一些算法"><a href="#一些算法" class="headerlink" title="一些算法"></a>一些算法</h2><ul><li>二分图最大匹配</li><li>求欧拉回路</li><li>归并排序求逆序对</li></ul><h1 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h1><h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><p>手动实现</p><ul><li>冒泡排序</li><li>插入排序</li><li>选择排序</li><li>快速排序</li></ul><h2 id="最小交换-1"><a href="#最小交换-1" class="headerlink" title="最小交换"></a>最小交换</h2><p>使用树状数组优化求逆序对的暴力算法，达到与归并排序相同的复杂度。</p><h2 id="总结欧拉回路算法"><a href="#总结欧拉回路算法" class="headerlink" title="总结欧拉回路算法"></a>总结欧拉回路算法</h2><ul><li><a href="https://www.jisuanke.com/minicourse/740/37823" target="_blank" rel="noopener">欧拉回路 计蒜客</a></li></ul><h2 id="总结匈牙利算法"><a href="#总结匈牙利算法" class="headerlink" title="总结匈牙利算法"></a>总结匈牙利算法</h2><ul><li><a href="https://www.jisuanke.com/minicourse/741/37831" target="_blank" rel="noopener">匈牙利算法 计蒜客</a></li></ul><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><p>学习使用 <code>std::lower_bound</code> ，注意边界。</p><h2 id="实现-Bellman-Ford-算法"><a href="#实现-Bellman-Ford-算法" class="headerlink" title="实现 Bellman-Ford 算法"></a>实现 Bellman-Ford 算法</h2><p>伪代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始化 mind 数组</span><br><span class="line">mind[0] : 0</span><br><span class="line">for round 1 to n</span><br><span class="line">枚举所有边 (u,v,len)</span><br><span class="line">mind[v] : min(min[v],mind[u]+len)</span><br><span class="line">if 本轮中没有点被更新</span><br><span class="line">break;</span><br><span class="line">if round == n+1</span><br><span class="line">无解</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目大意-amp-代码实现&quot;&gt;&lt;a href=&quot;#题目大意-amp-代码实现&quot; class=&quot;headerlink&quot; title=&quot;题目大意 &amp;amp; 代码实现&quot;&gt;&lt;/a&gt;题目大意 &amp;amp; 代码实现&lt;/h1&gt;&lt;h2 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot;
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Dijkstra" scheme="https://blog.pazyx.xyz/tags/Dijkstra/"/>
    
      <category term="ToDo" scheme="https://blog.pazyx.xyz/tags/ToDo/"/>
    
      <category term="二分" scheme="https://blog.pazyx.xyz/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="匈牙利算法" scheme="https://blog.pazyx.xyz/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://blog.pazyx.xyz/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="https://blog.pazyx.xyz/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="欧拉回路" scheme="https://blog.pazyx.xyz/tags/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
    
      <category term="Bellman-Ford" scheme="https://blog.pazyx.xyz/tags/Bellman-Ford/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营解题总结（第一周）//ToDo</title>
    <link href="https://blog.pazyx.xyz/2018/08/04/algor_club_code_1/"/>
    <id>https://blog.pazyx.xyz/2018/08/04/algor_club_code_1/</id>
    <published>2018-08-03T18:30:49.000Z</published>
    <updated>2018-08-03T18:31:58.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目大意-amp-代码实现"><a href="#题目大意-amp-代码实现" class="headerlink" title="题目大意 &amp; 代码实现"></a>题目大意 &amp; 代码实现</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>简单的栈实现，我使用数组实现，可以使用 <code>vector</code> 代替数组。日常可以直接使用 STL 库中的 <code>stack</code> 类，但其无法进行 “call by rank” 的访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">int</span> mtop = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">string</span> mstack[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压入栈顶</span></span><br><span class="line"><span class="comment">// name：被压入的人的姓名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">    mtop++;</span><br><span class="line">    mstack[mtop] = name;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出栈顶</span></span><br><span class="line"><span class="comment">// 返回值：被弹出人的姓名</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mtop &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">        mtop--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mstack[mtop+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 询问栈中某个位置上的人的姓名（栈底位置为1，向栈顶方向的位置依次递增）</span></span><br><span class="line"><span class="comment">// pos：询问的位置</span></span><br><span class="line"><span class="comment">// 返回值：pos位置上人的姓名</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="keyword">return</span> mstack[pos<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (; n--; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line">            push(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, pop().c_str());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pos);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, query(pos).c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>简单的队列实现，这个队列问题很大，就是元素出队后的空间无法回收，造成无法持续使用，占用空间大的问题。题目要求较低。应该使用链表或循环数组实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"><span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> mque[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾入队</span></span><br><span class="line"><span class="comment">// name：入队人的姓名</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="built_in">string</span> name)</span> </span>&#123;</span><br><span class="line">    mque[h] = name;</span><br><span class="line">    h++;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队首出队</span></span><br><span class="line"><span class="comment">// 返回值：队首的姓名</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q++;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="keyword">return</span> mque[q<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 询问队列中某个位置上的人的姓名（队首位置为1，往后位置依次递增）</span></span><br><span class="line"><span class="comment">// pos：询问的位置</span></span><br><span class="line"><span class="comment">// 返回值：pos位置上人的姓名</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mque[q+pos<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">for</span> (; n--; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, name);</span><br><span class="line">            enqueue(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dequeue().c_str());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pos);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, query(pos).c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>实现并维护二叉搜索树，并输出其前序和后序遍历。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;string.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    node* l;</span><br><span class="line">    node* r;</span><br><span class="line">    node():val(<span class="number">0</span>),l(<span class="literal">nullptr</span>),r(<span class="literal">nullptr</span>)&#123;&#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">node* root = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v, node*&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">        x = <span class="keyword">new</span> node();</span><br><span class="line">        <span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line">        x-&gt;l = <span class="literal">nullptr</span>;</span><br><span class="line">        x-&gt;r = <span class="literal">nullptr</span>;</span><br><span class="line">        x-&gt;val = v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= x-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(v,x-&gt;l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; x-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(v,x-&gt;r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dlr</span><span class="params">( node* x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)&#123;</span><br><span class="line">        ans.push_back(x-&gt;val);</span><br><span class="line">        dlr(x-&gt;l,ans);</span><br><span class="line">        dlr(x-&gt;r,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lrd</span><span class="params">( node* x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)&#123;</span><br><span class="line">        lrd(x-&gt;l,ans);</span><br><span class="line">        lrd(x-&gt;r,ans);</span><br><span class="line">        ans.push_back(x-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAnswer(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(sequence.size()); ++i)</span><br><span class="line">        insert(sequence[i],root);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    dlr(root,ans);</span><br><span class="line">    lrd(root,ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        sequence.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = getAnswer(n, sequence);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; ans.size() &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[n + i], <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数字盒子"><a href="#数字盒子" class="headerlink" title="数字盒子"></a>数字盒子</h2><p>Hash Map 实现，由于我的问题，没有去实现，使用了STL库中的 <code>map</code> 类，周末会补充 Hash Map 的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;map&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行操作时会调用这个函数</span></span><br><span class="line"><span class="comment">// op：对应该次操作的 op（具体请见题目描述）</span></span><br><span class="line"><span class="comment">// x：对应该次操作的 x（具体请见题目描述）</span></span><br><span class="line"><span class="comment">// 返回值：如果输出为"Succeeded"，则这个函数返回 1，否则返回 0</span></span><br><span class="line"><span class="built_in">map</span>&lt;ll,<span class="keyword">bool</span>&gt; Map;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> op, ll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[x])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Map[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Map[x])&#123;</span><br><span class="line">            Map[x] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Map[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Q, op;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Q);</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%lld"</span>, &amp;op, &amp;x);</span><br><span class="line">        <span class="built_in">puts</span>(check(op, x) ? <span class="string">"Succeeded"</span> : <span class="string">"Failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重编码"><a href="#重编码" class="headerlink" title="重编码"></a>重编码</h2><p>哈夫曼编码问题，合并森林。<br>与 <a href="/2018/01/24/poj-3253-fence-repair/">POJ 3253 Fence Repair</a> 相似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;queue&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是求解整个问题的函数</span></span><br><span class="line"><span class="comment">// w：题目描述中的 w（所有）</span></span><br><span class="line"><span class="comment">// n：题目描述中的 n</span></span><br><span class="line"><span class="comment">// 返回值：答案</span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;ll, <span class="built_in">vector</span>&lt;ll&gt;, greater&lt;ll&gt; &gt; q; </span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;ll&gt; w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;    <span class="comment">//把n块木板的长度入队</span></span><br><span class="line">        q.push(w[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.size() &gt; <span class="number">1</span>)&#123;            <span class="comment">//如果还没有合成一块木板就继续合并</span></span><br><span class="line">        ll minOne,minTwo;</span><br><span class="line">        minOne = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        minTwo = q.top();</span><br><span class="line">        q.pop();                        <span class="comment">//从队头拿出两个最短的木板</span></span><br><span class="line">        sum += (minOne + minTwo);       <span class="comment">//加上这次合并的开销</span></span><br><span class="line">        q.push(minOne+minTwo);   <span class="comment">//将合并后的木板入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x);</span><br><span class="line">        w.push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getAnswer(n, w));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成绩排序"><a href="#成绩排序" class="headerlink" title="成绩排序"></a>成绩排序</h2><p>排序并输出逆序对数目，使用冒泡排序在每次交换记数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是进行排序的函数</span></span><br><span class="line"><span class="comment">// n：题目描述中的 n</span></span><br><span class="line"><span class="comment">// A：各同学的算法训练营成绩</span></span><br><span class="line"><span class="comment">// DS：各同学的数据结构训练营成绩</span></span><br><span class="line"><span class="comment">// 返回值：将要输出的数字依次加入到返回值的数组中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> algorithm,dataStruct;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    student()&#123;&#125;</span><br><span class="line">    student(<span class="keyword">int</span> i,<span class="keyword">int</span> a,<span class="keyword">int</span> d):id(i),algorithm(a),dataStruct(d),score(a+d)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (student a,student b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score &lt; b.score)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a.score == b.score)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.algorithm &lt; b.algorithm)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;student&gt; &amp;a,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = size<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;          <span class="comment">//记录在一趟排序中是否有交换</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                student temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">                <span class="comment">//swap(a[j],a[j+1]);</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAnswer(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; DS) &#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;student&gt; temp;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        temp.push_back(student(i+<span class="number">1</span>,A[i],DS[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = BubbleSort(temp,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        ans.push_back(temp[i].id);</span><br><span class="line">        ans.push_back(temp[i].score);</span><br><span class="line">        ans.push_back(temp[i].algorithm);</span><br><span class="line">        ans.push_back(temp[i].dataStruct);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(cnt);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, DS;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, ds;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;ds);</span><br><span class="line">        A.push_back(a);</span><br><span class="line">        DS.push_back(ds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = getAnswer(n, A, DS);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d %d\n"</span>, ans[cnt], ans[cnt + <span class="number">1</span>], ans[cnt + <span class="number">2</span>], ans[cnt + <span class="number">3</span>]);</span><br><span class="line">        cnt += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[cnt]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="等式"><a href="#等式" class="headerlink" title="等式"></a>等式</h2><p>来源：<em>NOI 2015 day1 T1 程序自动分析</em><br>简单并查集题目，主意一下检查应该留到最后检查即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现开始 =================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 请在这里定义你需要的全局变量 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定n个变量以及m个约束，判定是否能找出一种赋值方案满足这m个约束条件</span></span><br><span class="line"><span class="comment">// n：如题意</span></span><br><span class="line"><span class="comment">// m：如题意</span></span><br><span class="line"><span class="comment">// A：大小为m的数组，表示m条约束中的a</span></span><br><span class="line"><span class="comment">// B：大小为m的数组，表示m条约束中的b</span></span><br><span class="line"><span class="comment">// E：大小为m的数组，表示m条约束中的e</span></span><br><span class="line"><span class="comment">// 返回值：若能找出一种方案，返回"Yes"；否则返回"No"（不包括引号）。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">500005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">500004</span>; i++)&#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre[x] == x)&#123;</span><br><span class="line">    <span class="comment">//x 节点就是根节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre[x] = get(pre[x]);</span><br><span class="line">    <span class="comment">//返回父节点的根节点，并另当前节点父节点直接为根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x = get(x);</span><br><span class="line">    y = get(y);</span><br><span class="line">    <span class="keyword">if</span>(x != y)&#123;<span class="comment">// 不住同一个集合</span></span><br><span class="line">        pre[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; E)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 请在这里设计你的算法 */</span></span><br><span class="line">    </span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; zero;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(E[i])&#123;</span><br><span class="line">            merge(A[i],B[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            zero.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; zero.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(get(A[zero[i]]) == get(B[zero[i]]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"No"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Yes"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T); T--; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A, B, E;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, e;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;e);</span><br><span class="line">            A.push_back(a);</span><br><span class="line">            B.push_back(b);</span><br><span class="line">            E.push_back(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, getAnswer(n, m, A, B, E).c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="道路升级"><a href="#道路升级" class="headerlink" title="道路升级"></a>道路升级</h2><p>最大生成树问题，与最小生成树一样。<br>使用 Kruskal 算法解决，需要简单实现一下并查集。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">//#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">200050</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">400050</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> edge &amp;a)</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> w &gt; a.w; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; e[MAX_M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAX_N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)&#123;</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = get(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAnswer(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; U, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; V) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        e[i].u = U[i];</span><br><span class="line">        e[i].v = V[i];</span><br><span class="line">        e[i].w = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(e,e+m);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = get(e[i].u), y = get(e[i].v);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x != y)&#123;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">            re.push_back(e[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(re.begin(), re.end());</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ================= 代码实现结束 =================</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; U, V;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;u, &amp;v);</span><br><span class="line">        U.push_back(u);</span><br><span class="line">        V.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans = getAnswer(n, m, U, V);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="keyword">int</span>(ans.size()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">int</span>(ans.size()); ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h1><h2 id="输入输出挂"><a href="#输入输出挂" class="headerlink" title="输入输出挂"></a>输入输出挂</h2><p>输入输出挂是真的快！</p><p>简单的数字输入输出挂，完整的见 -&gt; <a href="https://blog.csdn.net/f_zyj/article/details/51473493" target="_blank" rel="noopener">这里</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Scan</span><span class="params">()</span> </span>&#123;    <span class="comment">//输入外挂</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">if</span>((ch = getchar()) == <span class="string">'-'</span>) flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) res = ch - <span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>((ch = getchar()) &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        res = res * <span class="number">10</span> + (ch - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> flag ? -res : res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Out</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;    <span class="comment">//输出外挂</span></span><br><span class="line">    <span class="keyword">if</span>(a &lt; <span class="number">0</span>) &#123; <span class="built_in">putchar</span>(<span class="string">'-'</span>); a = -a; &#125;</span><br><span class="line">    <span class="keyword">if</span>(a &gt;= <span class="number">10</span>) Out(a / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(a % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="输入输出分离"><a href="#输入输出分离" class="headerlink" title="输入输出分离"></a>输入输出分离</h2><p>助教给的解题模板真舒服，可以不用考虑输出问题，专心实现算法～～～<br>代码可读性也提高不少，但竞赛中打的时间也许会增加一些，复杂度也会增加一些。</p><h2 id="哈夫曼编码-amp-POJ-3253"><a href="#哈夫曼编码-amp-POJ-3253" class="headerlink" title="哈夫曼编码 &amp; POJ 3253"></a>哈夫曼编码 &amp; POJ 3253</h2><p>哈夫曼编码就是贪心～<br>在《挑战程序设计竞赛(第2版) 》中讲解的 POJ 3253 现在一看真是醍醐灌顶～～～</p><h2 id="学到一些算法实现"><a href="#学到一些算法实现" class="headerlink" title="学到一些算法实现"></a>学到一些算法实现</h2><ul><li>二叉树</li><li>Kruskal 算法</li><li>哈夫曼编码的 \(O(n)\) 实现</li></ul><h2 id="题目中数据范围分析技巧"><a href="#题目中数据范围分析技巧" class="headerlink" title="题目中数据范围分析技巧"></a>题目中数据范围分析技巧</h2><p>计算机每秒运算 \(10^8\)</p><ul><li>\(n = 10^6\) -&gt; \(O(n)\)</li><li>\(n = 5  \times 10^5\) -&gt; \(O(n log n)\)</li><li>\(n = 10^4\) -&gt; \(O(n^2)\)</li></ul><hr><h1 id="ToDo"><a href="#ToDo" class="headerlink" title="ToDo"></a>ToDo</h1><h2 id="Hash-Map-的实现"><a href="#Hash-Map-的实现" class="headerlink" title="Hash Map 的实现"></a>Hash Map 的实现</h2><p>…</p><h2 id="哈夫曼编码的-O-n-实现"><a href="#哈夫曼编码的-O-n-实现" class="headerlink" title="哈夫曼编码的 \(O(n)\) 实现"></a>哈夫曼编码的 \(O(n)\) 实现</h2><p>使用栈和队列优化</p><h2 id="成绩排序-优化"><a href="#成绩排序-优化" class="headerlink" title="成绩排序 优化"></a>成绩排序 优化</h2><p>\(O(n^2)\) -&gt; \(O(n log n)\)</p><p>排序 -&gt; 快排排序、归并排序<br>求逆序对 -&gt; 归并排序、树状数组辅助统计</p><h2 id="重编码-gt-【NOI2015】荷马史诗"><a href="#重编码-gt-【NOI2015】荷马史诗" class="headerlink" title="重编码 -&gt;【NOI2015】荷马史诗"></a>重编码 -&gt;【NOI2015】荷马史诗</h2><p>不同进制下的哈夫曼编码。<br><a href="http://uoj.ac/problem/130" target="_blank" rel="noopener">【NOI2015】荷马史诗</a></p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/sdfgdbvc/article/details/51490791" target="_blank" rel="noopener">输入输出外挂</a></li><li><a href="https://blog.csdn.net/f_zyj/article/details/51473493" target="_blank" rel="noopener">输入输出外挂总结</a></li><li><a href="https://blog.csdn.net/yang_teng_/article/details/53493125" target="_blank" rel="noopener">二叉树的C++简单实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目大意-amp-代码实现&quot;&gt;&lt;a href=&quot;#题目大意-amp-代码实现&quot; class=&quot;headerlink&quot; title=&quot;题目大意 &amp;amp; 代码实现&quot;&gt;&lt;/a&gt;题目大意 &amp;amp; 代码实现&lt;/h1&gt;&lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; c
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="栈" scheme="https://blog.pazyx.xyz/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://blog.pazyx.xyz/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="并查集" scheme="https://blog.pazyx.xyz/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="二叉树" scheme="https://blog.pazyx.xyz/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="哈夫曼编码" scheme="https://blog.pazyx.xyz/tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    
      <category term="Kruskal" scheme="https://blog.pazyx.xyz/tags/Kruskal/"/>
    
      <category term="Hash Map" scheme="https://blog.pazyx.xyz/tags/Hash-Map/"/>
    
      <category term="输入输出挂" scheme="https://blog.pazyx.xyz/tags/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8C%82/"/>
    
      <category term="ToDo" scheme="https://blog.pazyx.xyz/tags/ToDo/"/>
    
  </entry>
  
  <entry>
    <title>求质数表3——高级筛法</title>
    <link href="https://blog.pazyx.xyz/2018/07/26/isprimes-3/"/>
    <id>https://blog.pazyx.xyz/2018/07/26/isprimes-3/</id>
    <published>2018-07-26T11:36:26.000Z</published>
    <updated>2018-07-26T11:37:44.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="增量式筛法"><a href="#增量式筛法" class="headerlink" title="增量式筛法"></a>增量式筛法</h1><p>之前的筛法都需要事先指定一个N，然后求N以内的质数，但没办法求N以上的质数。我们想要一种算法不用事先指定N一直求下去，如试除法就是增量式运行的。 增量式算法可以在简易欧拉筛进行改进的。<br><img src="/2018/07/26/isprimes-3/1.jpg" alt=""><br>简易欧拉筛限制它不能增量式运行的问题是在于它的空间。比如增量式运行筛选到 11 时你需要划掉 121 ，这样你就需要维持 N^2 的空间，这样就很成问题，想象如果 N 到1亿时，那空间将是不可接受的。<br><img src="/2018/07/26/isprimes-3/2.jpg" alt=""><br>我们将不再枚举p和f，而是依次检查每个数，检查到一个数时划去下一个数，并再下一个数处做标记。比如我们检查到 10 ，我们通过某种方式计算出它的下一个要被划掉的数为 15 ，我们划掉 15 并在 15 处做标记，保证检查到 15 时我们可以轻松的算出 25 。由 <a href="https://en.wikipedia.org/wiki/Bertrand%27s_postulate" target="_blank" rel="noopener">Bertrand’s postulate</a> 这个数学结论得出相邻两个质数相差不会超过两倍，所以我们只需将数组维持在当前检查的数的两倍即可。这样空间复杂度就将为了 O(N) 。 这个标记需要干什么，它需要帮助我们在拿到一个数时迅速找出它的p和f。我们用一个数组保存当前被检查的数的最小质因子在质数表的位置即可。这样比如我们在拿到 15 时，我们找到它的最小质因子p为 3 ，15/3 算出 f 为 5，我们就可以用 f 乘下一个质数去找到 25 划掉它并继续传递标记了。标记从每个偶数处（因为第一个素数为 2 ）产生的，到列末尾消失（p 最大增长到 f 的最小质因子）。 </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/DtN2WPpppf/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/DtN2WPpppf/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bengalloun</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nPrimes = <span class="number">0</span>;</span><br><span class="line">    flag[<span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        flag[i * <span class="number">2</span> - <span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">//假设它为质数</span></span><br><span class="line">        flag[i * <span class="number">2</span>] = <span class="literal">false</span>;    <span class="comment">//偶数一定为合数</span></span><br><span class="line">        lpfindex[i * <span class="number">2</span>] = <span class="number">0</span>;    <span class="comment">//建立列首标记</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag[i])&#123;</span><br><span class="line">            primes[nPrimes++] = i;  <span class="comment">//如果还没被筛掉加入质数表</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;      <span class="comment">//如果是合数</span></span><br><span class="line">            <span class="keyword">int</span> u = lpfindex[i];</span><br><span class="line">            <span class="keyword">int</span> p = primes[u];  </span><br><span class="line">            <span class="keyword">int</span> f = i / p;      <span class="comment">//计算p和f</span></span><br><span class="line">            <span class="keyword">if</span>(f % p != <span class="number">0</span>)&#123;     <span class="comment">//如果没有到列尾就传递标记</span></span><br><span class="line">                <span class="keyword">int</span> j = primes[u + <span class="number">1</span>] * f;</span><br><span class="line">                flag[j] = <span class="literal">false</span>;</span><br><span class="line">                lpfindex[j] = u + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>与思想与简易欧拉筛相同，依然为O(N)。因为要为增量式运行做准备实际要比简易欧拉筛多花一倍的时间。 </p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>flag和lpfindex数组都为O(N)的复杂度。总体空间复杂度为O(N)。</p><hr><h1 id="分段式筛法"><a href="#分段式筛法" class="headerlink" title="分段式筛法"></a>分段式筛法</h1><p>对于现代计算机运算速度越来越快，时间复杂度可能问题不大，但空间复杂度是个问题。分段式筛法就是要解决这个问题。<br>分段式筛法是在埃式筛法的基础上改进的，</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>Ubuntu Pastebin : <a href="https://paste.ubuntu.com/p/HzTG6HrbV2/" target="_blank" rel="noopener">https://paste.ubuntu.com/p/HzTG6HrbV2/</a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">segmented_eratosthenes</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sqrtN = (<span class="keyword">int</span>) <span class="built_in">sqrt</span>(N);</span><br><span class="line">    <span class="keyword">int</span> n = eratosthenes(sqrtN);</span><br><span class="line">    <span class="keyword">int</span> nPrimes = n;</span><br><span class="line"><span class="comment">// 使用埃式筛法求出前 √N 内的质数。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> L = sqrtN;<span class="comment">// 分段求，L 为每段长度，取 √N</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> start = sqrtN + <span class="number">1</span>; start &lt;= N; start += L)&#123;</span><br><span class="line">        <span class="keyword">if</span>(start + L &gt; N) L = N - start + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(flag, <span class="literal">true</span>, L * <span class="keyword">sizeof</span>(<span class="keyword">bool</span>));</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = primes[u];</span><br><span class="line">            <span class="keyword">if</span>(p * p &gt;= start + L) <span class="keyword">break</span>; <span class="comment">// 枚举本段上限以内的质数</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = (p - start % p) % p; i &lt; L; i += p)&#123;</span><br><span class="line">                flag[i] = <span class="literal">false</span>;<span class="comment">// 划掉本段中能被 p 整除的数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag[i]) primes[nPrimes++] = start + i; </span><br><span class="line">            <span class="comment">// 找到本段中没有被划掉的数并将其收集到质数表中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nPrimes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="L-的取法"><a href="#L-的取法" class="headerlink" title="L 的取法"></a>L 的取法</h2><h3 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h3><p>\(\sqrt{N}\) 以内质数表占用了 \(O(\sqrt{N})\) 的空间。<br>flag 数组占用 \(O(L)\) 的空间。<br>若 \(L &gt; \sqrt{N}\) 空间复杂度将提高。</p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p>若 \(L &lt; \sqrt{N}\)，当 p 接近 \(\sqrt{N}\) 时，删除 p 的倍数就容易“扑空”。</p><p>所以 \(L = \sqrt{N}\) 时刚好。</p><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>本质上是埃式筛法，所以时间复杂度为 \(O(NloglogN)\)。<br>内存占用小，避免了缓存不命中，实际上比埃式筛法要快。</p><h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>\(O(\sqrt{N})\)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;增量式筛法&quot;&gt;&lt;a href=&quot;#增量式筛法&quot; class=&quot;headerlink&quot; title=&quot;增量式筛法&quot;&gt;&lt;/a&gt;增量式筛法&lt;/h1&gt;&lt;p&gt;之前的筛法都需要事先指定一个N，然后求N以内的质数，但没办法求N以上的质数。我们想要一种算法不用事先指定N一直求下去
      
    
    </summary>
    
      <category term="算法" scheme="https://blog.pazyx.xyz/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://blog.pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="质数" scheme="https://blog.pazyx.xyz/tags/%E8%B4%A8%E6%95%B0/"/>
    
      <category term="求质数表" scheme="https://blog.pazyx.xyz/tags/%E6%B1%82%E8%B4%A8%E6%95%B0%E8%A1%A8/"/>
    
      <category term="优化" scheme="https://blog.pazyx.xyz/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="增量式筛法" scheme="https://blog.pazyx.xyz/tags/%E5%A2%9E%E9%87%8F%E5%BC%8F%E7%AD%9B%E6%B3%95/"/>
    
      <category term="分段式筛法" scheme="https://blog.pazyx.xyz/tags/%E5%88%86%E6%AE%B5%E5%BC%8F%E7%AD%9B%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>「记」0x02 幻觉</title>
    <link href="https://blog.pazyx.xyz/2018/07/24/weekly_2/"/>
    <id>https://blog.pazyx.xyz/2018/07/24/weekly_2/</id>
    <published>2018-07-24T08:39:47.000Z</published>
    <updated>2018-10-28T16:07:30.240Z</updated>
    
    <content type="html"><![CDATA[<p>最近有些小凉～电脑系统出了问题，博客数据没做好备份差点丢失，早上刚刚得到消息我的大学英语二挂了～55分很是难过～好在其他都还不错，奖学金再去与我无缘～</p><p>其实我刚上大学时觉得挂科也没什么，因为我从来不是好学生，偏科也十几年了。但我不能容忍的是让一堆只会考试的人拿了钱，我觉得这对我是一种侮辱，我下学期必将拿一次一等奖学金，之后随意～</p><p>我要学英语了，我觉得这对我很重要，如果英语搞定那后面的事情真是无法想象～ 事实上我高三就这么想了，结果高考英语考了 44 分，很醉。。。</p><p>高中啊，我不学英语是有原因的，因为我觉得其他的还能提高，而且更为高效～我干掉了最难的物理，之后一路还算顺风顺水，没吃什么苦也上了学。遗憾的是现在世道不一样了，我急需英语，我需要看英文的技术书籍，我需要看ACM题，但这些不是最重要的，最重要的是我现在学英语如果成了，我将无所不能～没有什么比这个重要的了，如果成了我相信大学后面几年一定顺风顺水。。。</p><p>我现在有很大的幻觉，我感觉我只需要半年，我看了一些知乎上的经验通常时间跨度都挺长的，那些都是笨蛋我只需要半年！</p><p>后面的事情还多啊，时间太少。数学建模的好东西都没搞定，特别是写论文用的排版语言，暑假还要学。ACM还要刷很多题，暑假还要看邓老师的算法课。我还计划总结一下C++的基础问题，开学当助教不能误人子弟啊。开学还有数学建模竞赛和ACM的网络赛～再参加一下蓝桥杯。大二的课程还是有些难度的，Java虽然我之前学过但还是需要写很多代码去熟练，学Java就伴随着还要看设计模式，汇编语言虽然自己也写过，但还是好难啊。。。还有那个阴差阳错选上的单片机，真是无力吐槽，还是虽然，虽然我是写过单片机的程序，但还是好难啊。。。</p><p>最后扯个淡，最近我想拍个大电影，真的～哪天我闲了就去拍，上传到YouTube上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有些小凉～电脑系统出了问题，博客数据没做好备份差点丢失，早上刚刚得到消息我的大学英语二挂了～55分很是难过～好在其他都还不错，奖学金再去与我无缘～&lt;/p&gt;
&lt;p&gt;其实我刚上大学时觉得挂科也没什么，因为我从来不是好学生，偏科也十几年了。但我不能容忍的是让一堆只会考试的人拿
      
    
    </summary>
    
      <category term="泛 - 记" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%B0/"/>
    
    
      <category term="英语" scheme="https://blog.pazyx.xyz/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="大电影" scheme="https://blog.pazyx.xyz/tags/%E5%A4%A7%E7%94%B5%E5%BD%B1/"/>
    
      <category term="记" scheme="https://blog.pazyx.xyz/tags/%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>「书摘」深度探索 C++ 对象模型（二）</title>
    <link href="https://blog.pazyx.xyz/2018/07/23/inside_cpp_obj_model_2/"/>
    <id>https://blog.pazyx.xyz/2018/07/23/inside_cpp_obj_model_2/</id>
    <published>2018-07-23T05:08:42.000Z</published>
    <updated>2018-07-23T05:42:53.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数语义学"><a href="#构造函数语义学" class="headerlink" title="构造函数语义学"></a>构造函数语义学</h1><p><strong>英文术语表</strong></p><table><thead><tr><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>implicit</td><td>暗中的、隐式的（通常意指并非在程序源代码中出现的）</td></tr><tr><td>explicit</td><td>显式的（通常意指程序源代码中所出现的）</td></tr><tr><td>trivial</td><td>没用的</td></tr><tr><td>nontrivial</td><td>有用的</td></tr><tr><td>memberwise</td><td>对每个 member 施以……</td></tr><tr><td>bitwise</td><td>对每个 bit 施以……</td></tr><tr><td>semantics</td><td>语意</td></tr></tbody></table><p>关于 C++ ，最常听到的一个抱怨就是，编译器背着程序员做了太多事情。</p><p>关键词 <strong>explicit</strong> 之所以被导入这个语言，就是为了给程序员提供一种方法，使他们能够制止 “单一参数的 constructor“ 被当作一个 conversion 运算符。</p><p>“Schwarz Error” -&gt; <a href="/2018/06/29/cin-return/">basic_ios 如何穿上它的 bool</a></p><p>Conversion 运算符的引入应该是明智的，而其测试应该是严酷的，并且中程序一出现不寻常活动的第一个症候时，就发出疑问。</p><h2 id="Default-Constructor-的构造操作"><a href="#Default-Constructor-的构造操作" class="headerlink" title="Default Constructor 的构造操作"></a>Default Constructor 的构造操作</h2><p>程序的需要、编译器的需要。程序如果有需要，那是程序员的责任。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> val; Foo *pnext; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo bar;</span><br><span class="line">    <span class="keyword">if</span> ( bar.val || bar.pnext )</span><br><span class="line">    <span class="comment">// ... do something</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C++ Standard [ISO-C++95] Section 12.1 :<br>对于 class X，如果没用任何 user-declared constructor，那么会有一个 default constructor 被隐式的（ implicitly ）声明出来……一个被隐式声明出来的 default constructor 将是一个 trivial constructor……</p></blockquote><h3 id="“带有-Default-Constructor”-的-Member-Class-Object"><a href="#“带有-Default-Constructor”-的-Member-Class-Object" class="headerlink" title="“带有 Default Constructor” 的 Member Class Object"></a>“带有 Default Constructor” 的 Member Class Object</h3><p>如果一个 class 没有任何 constructor，但它内含一个 member object，而后者有 default constructor，那么这个 class 的 implicit default constructor 就是 “nontrivial” ，编译器需要为改 class 合成出一个 default constructor。<strong>不过这个合成操作只有中 constructor 真正需要被调用时才会发生。</strong></p><p>编译器如何避免合成出多个 default constructor ？<strong>把合成的 default constructor、copy constructor、destructor、assignment copy operator 都以 inline 的方式完成。</strong>如果函数太复杂，不适合做成 inline，就会合成出一个 explicit non-inline static 实例（4.5节有详细说明）</p><p>编译器会扩张已存在的 constructors，在其中安插一些代码，使得 user code 被执行之前，先调用必要的 default constructors。</p><p>C++ 语言要求以 “member objects 在 class 中的声明顺序” 来调用各个 constructors。</p><h3 id="“带有-Default-Constructor”-的-Base-Class"><a href="#“带有-Default-Constructor”-的-Base-Class" class="headerlink" title="“带有 Default Constructor” 的 Base Class"></a>“带有 Default Constructor” 的 Base Class</h3><p>如果一个没有任何 constructor 的 class 派生自一个 “带有 Default Constructor” 的 base class，那么这个 derived class 的 default constructor 会被视为 nontrivial，并因此需要被合成出来。<strong>它将调用上一层 base classes 的 default constructor（根据它们的声明顺序）。对一个后继派生的 class 而言，这个合成的 constructor 和一个 “被显式提供的 default constructor” 没有什么差异。</strong></p><h3 id="“带有-Virtual-Function”-的-Class"><a href="#“带有-Virtual-Function”-的-Class" class="headerlink" title="“带有 Virtual Function” 的 Class"></a>“带有 Virtual Function” 的 Class</h3><p>当 class 声明（或继承）一个 virtual function ，需要合成 nontrivial 的 default constructor。</p><p>“带有 Virtual Function” 的 class 的 default constructor 会有两个扩张行动在编译期间发生：</p><ul><li>一个 virtual function table（在 cfront 中被称为 vtbl ）会被编译器产生出来，内放 class 的  virtual functions 地址。</li><li>在每一个 class object 中，一个额外的 pointer member（也就是 vptr ）会被编译器合成出来，内含相关之 class vtbl 的地址。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// widget.flip() 的转变</span></span><br><span class="line">( *widget.vptr[<span class="number">1</span>] )( &amp;widget )</span><br><span class="line"><span class="comment">// *1 表示 filp() 在 virtual table 中的固定索引</span></span><br><span class="line"><span class="comment">// * &amp;widget 代表要交给“被调用的某个 flip() 函数实例”的this指针</span></span><br></pre></td></tr></table></figure><p>编译器必须为每一个 “带有 Virtual Function” 的 class 的 object 的 vptr 设定初值，放纵适当的 virual table 地址。对于这个 class 所定义的每一个 constructor，编译器会安插一些代码来做这样的事情。 </p><h3 id="“带有-Virtual-Base-Class”-的-Class"><a href="#“带有-Virtual-Base-Class”-的-Class" class="headerlink" title="“带有 Virtual Base Class” 的 Class"></a>“带有 Virtual Base Class” 的 Class</h3><p>class 派生自一个继承串链，其中有一个或更多的 virtual base classes，需要合成 nontrivial 的 default constructor。</p><p>Virtual base class 的实现法在不同的编译器之间有极大的差异。然而，每一种实现法的共同点在于必须使 virtual base class 在其每一个 derived class object 中的位置，能够于执行期准备妥当。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> i; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> pubilc virual X &#123; <span class="keyword">public</span>: <span class="keyword">int</span> j; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> pubilc virual X &#123; <span class="keyword">public</span>: <span class="keyword">double</span> d; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123; <span class="keyword">public</span>: <span class="keyword">int</span> k &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无法在编译时期决定（resolve）出 pa-&gt;X::i 的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( <span class="keyword">const</span> A* pa)</span> </span>&#123; pa-&gt;i = <span class="number">1024</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo( <span class="keyword">new</span> A );</span><br><span class="line">    foo( <span class="keyword">new</span> C );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于下面的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( <span class="keyword">const</span> A* pa)</span> </span>&#123; pa-&gt;__vbcX-&gt;i = <span class="number">1024</span>; &#125;</span><br><span class="line"><span class="comment">// __vbcX 表示编译器产生的指针，指向 virtual base class X。</span></span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有 4 种情况，会造成“编译器必须为未声明 constructor 的 classes 合成一个 default constructor”。</p><ul><li>没有任何 constructor 的 class 内含一个有 default constructor 的 member object</li><li>没有任何 constructor 的 class 派生自一个 “带有 Default Constructor” 的 base class</li><li>当 class 声明（或继承）一个 virtual function</li><li>class 派生自一个继承串链，其中有一个或更多的 virtual base classes</li></ul><p><strong>C++ Standard 把那些合成物称为 implicit nontrivial default constructors。</strong></p><p>C++ 新手两个常见误解：</p><ol><li>任何 class 如果没有定义 default constructor，就会被合成出一个来。</li><li>编译器合成出来的 default constructor 会显式设定 “class 内每一个 data member 的默认值”。</li></ol><h2 id="Copy-Constructor-的构造操作"><a href="#Copy-Constructor-的构造操作" class="headerlink" title="Copy Constructor 的构造操作"></a>Copy Constructor 的构造操作</h2><p>有三种情况，会以一个 object 的内容作为另一个 class object 的初值。<br><code>class X { ... };</code></p><ul><li><code>X xx = x</code></li><li>作为参数交给某个函数 <code>foo( xx );</code></li><li>作为函数返回值 <code>return xx;</code></li></ul><h3 id="Default-Memberwise-Initialization"><a href="#Default-Memberwise-Initialization" class="headerlink" title="Default Memberwise Initialization"></a>Default Memberwise Initialization</h3><p>Default constructors 和 copy constructors 在<strong>必要</strong>的时候<strong>才</strong>由编译器产生出来。<br>对于 copy constructors 必要的时候是指该 class 不展现 bitwise copy semantics 时。</p><p>C++ Standard 把 copy constructors 区分为 trivial 和 nontrivial 两种。只有 nontrivial 的实例被合成于程序之中。</p><h3 id="Bitwise-Copy-Semantics（位逐次拷贝）"><a href="#Bitwise-Copy-Semantics（位逐次拷贝）" class="headerlink" title="Bitwise Copy Semantics（位逐次拷贝）"></a>Bitwise Copy Semantics（位逐次拷贝）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下声明展现了 bitwise copy semantics</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitwise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Bitwise(<span class="keyword">int</span> a);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下声明未展现出 bitwise copy semantics</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBitwise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">string</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NonBitwise(v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于后者，编译器必须合成出一个 copy constructor，<strong>以便调用 member class string object 的 copy constructor</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 伪码</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">NonBitwise</span><span class="params">(<span class="keyword">const</span> NonBitwise&amp; nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b.<span class="built_in">string</span>::<span class="built_in">string</span>(nb.b);</span><br><span class="line">    a = nb.a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="不要-Bitwise-Copy-Semantics-！"><a href="#不要-Bitwise-Copy-Semantics-！" class="headerlink" title="不要 Bitwise Copy Semantics ！"></a>不要 Bitwise Copy Semantics ！</h3><p>class 不展现出 ”bitwise copy semantics“ 的 4 种情况：</p><ul><li>当 class 内含一个 member object 而后者的 class 声明有一个 copy constructos 时（不论时被显式声明或是被合成而得）。</li><li>当 class 继承自一个 base class 而后者存在一个 copy constructor 时（不论时被显式声明或是被合成而得）。</li><li>当 class 声明了一个或多个 virtual functions 时。</li><li>当 class 派生自一个继承串链，其中有一个或多个 virtual base classes 时。</li></ul><h3 id="重新设定-Virtual-Table-的指针"><a href="#重新设定-Virtual-Table-的指针" class="headerlink" title="重新设定 Virtual Table 的指针"></a>重新设定 Virtual Table 的指针</h3><p>当 class 声明了一个或多个 virtual functions 时，编译期间会有两个程序扩张操作：</p><ul><li>增加一个 virtual function table( vtbl )，内含每一个有作用的 virtual function 的地址。</li><li>一个指向 virtual function table 的指针（ vptr ），安插在每一个 class object 内。</li></ul><h3 id="处理-Virtual-Base-Class-Subobject"><a href="#处理-Virtual-Base-Class-Subobject" class="headerlink" title="处理 Virtual Base Class Subobject"></a>处理 Virtual Base Class Subobject</h3><p>如果一个 class 以另一个 object 作为初值，而后者有一个 virtual base class subobject，那么也会使 “bitwise copy semantics” 失效。</p><p>每一个编译器对于虚拟继承的支持承诺，都代表必须让“derived class object 中 virtual base class subobject 位置” 在执行期就准备妥当。维护“位置的完整性”是编译器的责任。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B ba;</span><br><span class="line">B bb = ba;</span><br><span class="line"><span class="comment">// 这种情况使用 bitwise 就够了</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C ca;</span><br><span class="line">B bb = ca;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译器需要合成一个 copy constructor，安插一些代码以设定 virtual base class pointer/offser 的初值（或只是简单地确定它没有被抹消），对每一个 memberwise 执行必要的初始化操作，以及执行其他的内存相关工作。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="程序转化语意学（Program-Transformation-Semantics）"><a href="#程序转化语意学（Program-Transformation-Semantics）" class="headerlink" title="程序转化语意学（Program Transformation Semantics）"></a>程序转化语意学（Program Transformation Semantics）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"X.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个假设：</p><ul><li>每次 <code>foo()</code> 被调用，就传回 <code>xx</code> 的值。</li><li>如果 <code>class X</code> 定义了一个 copy constructor，那么当 <code>foo()</code> 被调用时，保证该 copy constructor 也会被调用。</li></ul><ul><li>第一个假设的真实性，必须视 <code>class X</code> 如何定义而定。</li><li>第二个假设的真实性，虽然也部分地必须视 <code>class X</code> 如何定义而定，但最主要的还是视你的 C++ 编译器所提供的进取性优化层级（degree of aggressive optimization）而定。</li></ul><h3 id="显式的初始化操作（Explicit-Initialization）"><a href="#显式的初始化操作（Explicit-Initialization）" class="headerlink" title="显式的初始化操作（Explicit Initialization）"></a>显式的初始化操作（Explicit Initialization）</h3><p>在严谨的 C++ 用词中，“定义” 是指 “占用内存” 的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">x1</span><span class="params">( x0 )</span></span>;</span><br><span class="line">X x2 = x0;</span><br><span class="line">X x3 = X( x0 );</span><br></pre></td></tr></table></figure><p>转化为 -&gt; </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X x1;</span><br><span class="line">X x2;</span><br><span class="line">X x3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器安插 X copy construction 的调用操作</span></span><br><span class="line">X1.X::X( x0 );</span><br><span class="line">X2.X::X( x0 );</span><br><span class="line">X3.X::X( x0 );</span><br></pre></td></tr></table></figure><h3 id="参数的初始化（Argument-Initialization）"><a href="#参数的初始化（Argument-Initialization）" class="headerlink" title="参数的初始化（Argument Initialization）"></a>参数的初始化（Argument Initialization）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">( X x0 )</span></span>;</span><br><span class="line"></span><br><span class="line">X xx;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">foo( xx );</span><br></pre></td></tr></table></figure><p><strong>第一种编译器实现的转化代码</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X __temp0;</span><br><span class="line"></span><br><span class="line">__temp0.X::X( xx );</span><br><span class="line">foo( __temp0 );</span><br></pre></td></tr></table></figure></p><p>要求局部实例（local instance）x0 以 memberwise 的方式将 xx 当做初值。导入临时性 object，并调用 copy constructor 将它初始化，然后将此临时性 object 交给函数。但这里 <code>foo()</code> 函数声明将改变为 <code>void foo( X&amp; x0 )</code>。在函数执行完成后 <code>class X</code> 的 destrucor 将会被调用，对付那个临时性的 object 。</p><p><strong>第二种编译器实现</strong><br>以 “拷贝建构”（copy construct）的方式把实际参数直接建构在其应该的位置上。</p><h3 id="返回值的初始化（Return-Value-Initialization）"><a href="#返回值的初始化（Return-Value-Initialization）" class="headerlink" title="返回值的初始化（Return Value Initialization）"></a>返回值的初始化（Return Value Initialization）</h3><h4 id="cfront-中的双阶段转化"><a href="#cfront-中的双阶段转化" class="headerlink" title="cfront 中的双阶段转化"></a>cfront 中的双阶段转化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X xx;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">( X&amp; __result )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    </span><br><span class="line">    xx.X::X();</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    __result.X::X(xx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>X xx = bar();</code> 的操作将被转化为 <code>X xx; bar( xx );</code>。</p><p><code>bar().memfunc();</code> 可能被转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X __temp0;</span><br><span class="line">( bar( __temp0 ), __temp0 ).memfunc();</span><br></pre></td></tr></table></figure></p><h3 id="在使用者层面做优化（Optimization-at-the-User-Level）"><a href="#在使用者层面做优化（Optimization-at-the-User-Level）" class="headerlink" title="在使用者层面做优化（Optimization at the User Level）"></a>在使用者层面做优化（Optimization at the User Level）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">( <span class="keyword">const</span> T &amp;y, <span class="keyword">const</span> T &amp;z )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bar()</code> 函数会要求 <code>xx</code> 被 “memberwise” 地拷贝到编译器所产生的 <code>__result</code> 之中。<br><em>Jonathan Shopiro</em> 提出定义另一个 constructor，可以直接计算 <code>xx</code> 的值。<br>上面的代码转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">( <span class="keyword">const</span> T &amp;y, <span class="keyword">const</span> T &amp;z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> X( y,z );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译器会将其转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">( X &amp;__result, <span class="keyword">const</span> T &amp;y, <span class="keyword">const</span> T &amp;z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__result.X::X( y,z );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>__result</code> 被直接计算出来，而不是经由 copy constructor 拷贝而得！</p><h3 id="在编译器层面做优化（Optimization-at-the-Compiler-Level）"><a href="#在编译器层面做优化（Optimization-at-the-Compiler-Level）" class="headerlink" title="在编译器层面做优化（Optimization at the Compiler Level）"></a>在编译器层面做优化（Optimization at the Compiler Level）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">X xx;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化为 -&gt;<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">( X&amp; __result )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __result.X::X();</span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种优化，有时候被称为 Named Return Value ( NRV ) 优化。NRV 优化如今被视为标准 C++ 编译器的一个义不容辞的优化操作。</p><p>// 本书对 NRV 的优化性能测试有一些错误，这部分不做摘录。</p><p>NRV 优化的争议：</p><ul><li>优化由编译器完成，而它是否真的被完成，并不是十分清楚。</li><li>一旦函数变得比较复杂，优化也会变得比较难以实施。</li><li>程序员不能够安全地规划自己的 copy constructor 的副作用。</li></ul><p>一般而言，面对 “以一个 class object 作为另一个 class object 的初值” 的情形，语言允许编译器有大量的自由发挥空间。</p><h3 id="Copy-Constructor：要还是不要？"><a href="#Copy-Constructor：要还是不要？" class="headerlink" title="Copy Constructor：要还是不要？"></a>Copy Constructor：要还是不要？</h3><p>class 的 default copy constructor 被视为 trivial 的情况下不声明 explicit copy constructor 既快速又安全。在需要 NRV 优化时，可以考虑实现 copy constructor，可以使用 <code>memcpy()</code> 来拷贝提高效率。</p><p>不管使用 <code>memcpy()</code> 还是 <code>memset()</code>，都只有在“classes 不含任何由编译器产生的那部 members ” 时才能有效运行。</p><h2 id="成员们的初始化队伍（Member-Initialization-List）"><a href="#成员们的初始化队伍（Member-Initialization-List）" class="headerlink" title="成员们的初始化队伍（Member Initialization List）"></a>成员们的初始化队伍（Member Initialization List）</h2><p>必须使用 member initialization list 的情况</p><ul><li>当初始化一个 reference member 时；</li><li>当初始化一个 const member 时；</li><li>当调用一个 base class 的 constructor，而它拥有一组参数时；</li><li>当调用一个 member class 的 constructor，而它拥有一组参数时。</li></ul><p>编译器会一一操作 initialization list，以适当顺序中 constructor 之内安插初始化操作，并且<strong>在任何 explicit user code 之前</strong>。</p><p>在 initialization list 中使用 member function 使用是合法的，这是因为和此 object 相关的 this 指针已经被建构妥当。</p><p>如果在 initialization list 中调用 derived class member function ，其返回值被当做 base class constructor 的一个参数。那不一定是个好主意，因为 derived class member function 可能要用到的 derived class member 在 base class 的 constructor 之后才被初始化。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/autosar/archive/2011/10/09/2204181.html" target="_blank" rel="noopener">关于NRV优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造函数语义学&quot;&gt;&lt;a href=&quot;#构造函数语义学&quot; class=&quot;headerlink&quot; title=&quot;构造函数语义学&quot;&gt;&lt;/a&gt;构造函数语义学&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;英文术语表&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;t
      
    
    </summary>
    
      <category term="泛 - 书摘" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E4%B9%A6%E6%91%98/"/>
    
    
      <category term="Cpp" scheme="https://blog.pazyx.xyz/tags/Cpp/"/>
    
      <category term="构造函数" scheme="https://blog.pazyx.xyz/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="编译器优化" scheme="https://blog.pazyx.xyz/tags/%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96/"/>
    
      <category term="拷贝构造函数" scheme="https://blog.pazyx.xyz/tags/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="缺省构造函数" scheme="https://blog.pazyx.xyz/tags/%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="Virtual Class" scheme="https://blog.pazyx.xyz/tags/Virtual-Class/"/>
    
      <category term="Virtual Base Class" scheme="https://blog.pazyx.xyz/tags/Virtual-Base-Class/"/>
    
      <category term="NRV优化" scheme="https://blog.pazyx.xyz/tags/NRV%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>macOS 灾难</title>
    <link href="https://blog.pazyx.xyz/2018/07/21/mac_os_disaster/"/>
    <id>https://blog.pazyx.xyz/2018/07/21/mac_os_disaster/</id>
    <published>2018-07-21T10:52:18.000Z</published>
    <updated>2018-07-21T14:19:51.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="macOS-10-14-beta3"><a href="#macOS-10-14-beta3" class="headerlink" title=" macOS 10.14 beta3 "></a><center> macOS 10.14 beta3 </center></h1><h4 id="灾难性的数据丢失事故，博客数据险些全部丢失！"><a href="#灾难性的数据丢失事故，博客数据险些全部丢失！" class="headerlink" title=" 灾难性的数据丢失事故，博客数据险些全部丢失！ "></a><center> 灾难性的数据丢失事故，博客数据险些全部丢失！ </center></h4><h4 id="2018-7-21-凌晨"><a href="#2018-7-21-凌晨" class="headerlink" title=" 2018.7.21 凌晨 "></a><center> 2018.7.21 凌晨 </center></h4><p><img src="/2018/07/21/mac_os_disaster/disaster.png" alt=""></p><p>博客数据在废纸篓里找到了，历劫度人。。。<br>调整一下<strong>继续～</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;macOS-10-14-beta3&quot;&gt;&lt;a href=&quot;#macOS-10-14-beta3&quot; class=&quot;headerlink&quot; title=&quot; macOS 10.14 beta3 &quot;&gt;&lt;/a&gt;&lt;center&gt; macOS 10.14 beta3 &lt;/cent
      
    
    </summary>
    
      <category term="泛 - 纪念" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E7%BA%AA%E5%BF%B5/"/>
    
    
      <category term="灾难" scheme="https://blog.pazyx.xyz/tags/%E7%81%BE%E9%9A%BE/"/>
    
      <category term="MacOS" scheme="https://blog.pazyx.xyz/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 指南</title>
    <link href="https://blog.pazyx.xyz/2018/07/15/markdown_guide/"/>
    <id>https://blog.pazyx.xyz/2018/07/15/markdown_guide/</id>
    <published>2018-07-14T16:53:18.000Z</published>
    <updated>2018-07-21T12:03:16.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-是什么？"><a href="#Markdown-是什么？" class="headerlink" title="Markdown 是什么？"></a>Markdown 是什么？</h1><blockquote><p><strong>Markdown</strong> 是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML ）文档”。</p></blockquote><p><strong>注意！</strong>Markdown是标记语言，而不是样式表。<strong>它只是在标注说明文本中每一块是什么。</strong>比如标题、引用、代码。最终它显示的是什么样子的取决于你浏览它的工具，如果转成 HTML 那就由浏览器决定，你想改变它的样式就需要添加 CSS（层叠样式表）。</p><h1 id="我为什么学-Markdown？"><a href="#我为什么学-Markdown？" class="headerlink" title="我为什么学 Markdown？"></a>我为什么学 Markdown？</h1><p>主要是博客写作需要用到，用 Markdown 写作最大的好处是自由，你的文本是独立的。如果你使用WordPress 自带的编辑器写作，它的可移植性是很低的，导出 XML 文件后转换成其他格式后很多地方都需要手动调整。还有就是项目中 Readme 文件一般用 Markdown 写，你写作时不需要任何鼠标操作。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure><h2 id="文本基础样式"><a href="#文本基础样式" class="headerlink" title="文本基础样式"></a>文本基础样式</h2><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**加粗**</span></span><br></pre></td></tr></table></figure><p><strong>效果：**</strong>加粗**</p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**斜体**</span></span><br></pre></td></tr></table></figure><p><strong>效果：*</strong>斜体*</p><h3 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">***斜体加粗**</span>*</span><br></pre></td></tr></table></figure><p><strong>效果：***</strong>斜体加粗***</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除~~</span><br></pre></td></tr></table></figure><p><strong>效果：</strong><del>删除</del></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 引用的内容</span></span><br><span class="line">&gt;&gt; 引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 引用的内容</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><blockquote><p>引用的内容</p><blockquote><p>引用的内容</p><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><blockquote><p>引用的内容</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><p>可以多级嵌套引用</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="strong">*****</span></span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><hr><hr><hr><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">超链接名</span>](<span class="link">超链接地址 "超链接title"</span>)</span><br><span class="line">title可缺省</span><br><span class="line"><span class="strong">**效果：**</span></span><br><span class="line">[<span class="string">Home</span>](<span class="link">https//pazyx.xyz "pazyx"</span>)</span><br></pre></td></tr></table></figure><p><strong>效果：</strong><br><a href="https//pazyx.xyz" title="pazyx">Home</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片alt</span>](<span class="link">图片地址 ''图片title''</span>)</span><br><span class="line">title可缺省</span><br><span class="line"><span class="strong">**效果：**</span></span><br><span class="line">![<span class="string">logo</span>](<span class="link">/markdown_basic/logo.png ''blogLogo''</span>)</span><br></pre></td></tr></table></figure><p><strong>效果：</strong><br><img src="/2018/07/15/markdown_guide/markdown_basic/logo.png" alt="logo" title="&#39;blogLogo&#39;"><br>图片地址可以是相对地址也可以是超链接</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>列表内容</span><br><span class="line"><span class="bullet">+ </span>列表内容</span><br><span class="line"><span class="bullet">* </span>列表内容</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.列表内容</span><br><span class="line">2.列表内容</span><br><span class="line">3.列表内容</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p>1.列表内容<br>2.列表内容<br>3.列表内容</p><h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>一级列表内容</span><br><span class="line">  - 二级列表内容</span><br><span class="line"><span class="code">    - 三级列表内容</span></span><br><span class="line"><span class="code">      - 四级列表内容</span></span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><ul><li>一级列表内容<ul><li>二级列表内容<ul><li>三级列表内容<ul><li>四级列表内容</li></ul></li></ul></li></ul></li></ul><p>两级之间差两个空格即可</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|表头|表头|表头|</span><br><span class="line">| - | :-: | :- |</span><br><span class="line">|内容|内容|内容|</span><br><span class="line">|内容|内容|内容|</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><table><thead><tr><th>表头</th><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>内容</td><td>内容</td><td>内容</td></tr><tr><td>内容</td><td>内容</td><td>内容</td></tr></tbody></table><p>默认为左对齐，在 “-” 右边加上 “:” 为右对齐，在 “-” 两侧同时加上 “:” 为居中对齐。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">行内 `code` 行内</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><p>行内 <code>code</code> 行内</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\<span class="code">`\`</span>\`cpp</span><br><span class="line"><span class="section">#include &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="code">    std::cout &lt;&lt; "Hello World." &lt;&lt; endl;</span></span><br><span class="line"><span class="code">    return 0;</span></span><br><span class="line">&#125;</span><br><span class="line">\<span class="code">`\`</span>\`</span><br></pre></td></tr></table></figure><p><strong>效果：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">markdown基本语法</a></li><li><a href="https://www.jianshu.com/p/2df05f279331" target="_blank" rel="noopener">Markdown插入表格语法</a></li><li><a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="noopener">Markdown维基百科</a></li><li><a href="http://www.markdown.cn" target="_blank" rel="noopener">Markdown中文官网</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown-是什么？&quot;&gt;&lt;a href=&quot;#Markdown-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Markdown 是什么？&quot;&gt;&lt;/a&gt;Markdown 是什么？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Markd
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Markdown" scheme="https://blog.pazyx.xyz/tags/Markdown/"/>
    
      <category term="标记语言" scheme="https://blog.pazyx.xyz/tags/%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/"/>
    
      <category term="写作工具" scheme="https://blog.pazyx.xyz/tags/%E5%86%99%E4%BD%9C%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>数学建模——动态规划</title>
    <link href="https://blog.pazyx.xyz/2018/07/14/mathematical_modeling_dp/"/>
    <id>https://blog.pazyx.xyz/2018/07/14/mathematical_modeling_dp/</id>
    <published>2018-07-14T10:13:18.000Z</published>
    <updated>2018-07-26T11:16:41.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前在学算法时接触过不少动态规划的题目，但最近实践周在上数学建模的课，发现自己在动态规划算法上欠缺很多。步骤不规范、思路不清晰、数学推导欠缺，大多数时候我都是靠直觉推状态转移方程的。这篇我希望从数学建模的角度重新总结一下动态规划（算法中的动态规划也会继续更新，最近将更新状压DP）。<br>算法竞赛和数学建模竞赛中动态规划，在数据和方程的表示上有很大不同。<br>算法竞赛中一般以数组单元的形式表示一个状态并用其推导状态转移方程，并且不对指标函数与最优值函数的单独推导。其形式更接近伪代码，方便将模型快速转换为代码。<br>数学建模竞赛中步骤相当严谨很多，各个方程相互独立，各个方程也更注重数学的严谨性。</p><hr><h1 id="标准步骤"><a href="#标准步骤" class="headerlink" title="标准步骤"></a>标准步骤</h1><ul><li>阶段</li><li>状态变量（无后效性） \(s_k\)</li><li>决策变量  \(x_k\)</li><li>状态转移方程  \(s_{k+1} = T_k(s_k,x_k)\)</li><li>指标函数  \(V_{k,n} = V_{k,n}(s_k,x_k,s_{k+1},…,s_{n+1},k = 1,2,…,n\)</li><li>最优值函数  \[f_k(s_k) = \max_{\{x_k,…,x_n\}} V_{k,n}\]</li><li>边界条件</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>一个简单的完全背包问题，其算法我在<a href="/2018/03/01/cp-bp/">动态规划B2——完全背包</a>给出。</p><p>有一个容量为 V 的背包和 N 种物品。每种物品的价值为 \(W_k\) 体积为 \(C_k\) ，每种物品有无限件，问最大背包价值。</p><h3 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h3><p>N 种物品按编号排序，视为 N 个阶段。</p><h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p>\(s_k\) 第 k 阶段初可装载的质量</p><h3 id="决策变量"><a href="#决策变量" class="headerlink" title="决策变量"></a>决策变量</h3><p>装入第k种物品的数量：\(x_i\)</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>\[s_{k+1} = s_k - C_kx_k\] </p><h3 id="指标函数"><a href="#指标函数" class="headerlink" title="指标函数"></a>指标函数</h3><p>装入的第 k 种物品到第 N 种物品总价值：\(v_k\) </p><h3 id="最优值函数"><a href="#最优值函数" class="headerlink" title="最优值函数"></a>最优值函数</h3><p>\[f_k(s_k) = \max_{0≤x_k≤[s_k/a_k]} \{C_kx_k + f_k(s_{k+1})\ \ (k = 1…n)\]</p><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><ul><li>\(s_1 = V\)</li><li>\(f_{n+1}(s_{n+1}) = 0\)</li></ul><h3 id="与算法竞赛中的动态规划对比"><a href="#与算法竞赛中的动态规划对比" class="headerlink" title="与算法竞赛中的动态规划对比"></a>与算法竞赛中的动态规划对比</h3><ul><li>算法竞赛<br>\[F[i, v] = max \{ F[i − 1, v − kC_i] + kW_i \ \  0 ≤ kC_i ≤ v \} \]</li><li>数学建模竞赛<br>$$<br>\begin{cases}<br>f_k(s_k) = \max_{0≤x_k≤[s_k/a_k]} \{C_kx_k + f_k(s_{k+1})\} &amp;\text{(k = 1…n)} \\<br>f_{n+1}(s_{n+1}) = 0<br>\end{cases}<br>$$</li></ul><hr><h1 id="连续型动态规划"><a href="#连续型动态规划" class="headerlink" title="连续型动态规划"></a>连续型动态规划</h1><p>在大多数算法竞赛的题目中，决策点都是离散的。而在数学建模竞赛中可能出现连续型的动态规划问题，这种题目写出具体算法相当困难，多大需要笔算。</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p>100 台某种机器可在高低两种不同的负荷下进行生产，设机器在高负荷下生产的产量函数为 g = 9x ，其中 x 为投入生产的机器数量，季度完好率为 a = 0.65 。在低负荷下生产的产量函数为 h = 4y ，其中 y 为投入生产的机器数量,季度完好率为 b = 0.95 。</p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><ul><li>把4个季度看成是4个阶段，用k表示。</li><li>状态变量\(s_k\)：表示第k季度初拥有的完好机器数量。(\(s_1\) = 100)</li><li>决策变量\(x_k\)：表示第k季度分配高负荷下生产的机器数量，于是\(s_k-x_k\)为该季度分配在低负荷下生产的机器数量。\(s_k\),\(x_k\)为连续变量，其小数部分表示一台机器正常工作时间所占的比例。允许决策集合:\(D_k(s_k) = \{ x_k \ \ |\ \ 0≤x_k≤s_k \}\)</li><li>状态转移方程：\[s_{k+1} = ax_k + b( s_k - x_k ) = 0.65x_k + (s_k - x_k ) \ \ (k = 1,2,3,4) \]</li><li>指标函数：\(v_k\) 表示第 k 季度的产量 \(v_k = 9x_k + 4(s_k+x_k)\)</li><li>最优值函数：<br>$$<br>\begin{cases}<br>f_k(s_k) = \max_{0≤x_k≤s_k} \{ v_k + f_{k+1}(s_{k+1}) \} = \max_{0≤x_k≤s_k} \{ 9x_k + 4(s_k-x_k) + f_{k+1}(s_{k+1}) \}\\<br>f_5(s_5) = 0<br>\end{cases}<br>$$</li></ul><h3 id="解"><a href="#解" class="headerlink" title="解"></a>解</h3><p><strong>当 k = 4 时</strong></p><p>$$<br>\begin{align}<br>f_4(s_4)&amp; = \max_{0≤x_4≤s_4} \{ 9x_4 + 4(s_4-x_4) + f_5(s_5) \} \\<br>&amp; = \max_{0≤x_4≤s_4} \{ 9x_4 + 4(s_4-x_4) \} \\<br>&amp; = \max_{0≤x_4≤s_4} \{ 5x_4 + 4s_4 \}<br>\end{align}<br>$$<br>\[x^*_4 = s_4 ,f_4(s_4) = 9s_4\]</p><p><strong>当 k = 3 时</strong></p><p>$$<br>\begin{align}<br>f_3(s_3)&amp; = \max_{0≤x_3≤s_3} \{ 9x_3 + 4(s_3-x_3) + f_4(s_4) \} \\<br>&amp; = \max_{0≤x_3≤s_3} \{ 9x_3 + 4(s_3-x_3)+9[0.65x_3+0.95(s_3-x_3)] \} \\<br>&amp; = \max_{0≤x_3≤s_3} \{ 2.3x_3 + 12.55s_3 \}<br>\end{align}<br>$$<br>\[x^*_3 = s_3 ,f_3(s_3) = 14.85s_3\]</p><p><strong>当 k = 2 时</strong></p><p>$$<br>\begin{align}<br>f_2(s_2)&amp; = \max_{0≤x_2≤s_2} \{ 9x_2 + 4(s_2-x_2) + f_3(s_3) \} \\<br>&amp; = \max_{0≤x_2≤s_2} \{ 9x_2 + 4(s_2-x_2)+14.85[0.65x_2+0.95(s_2-x_2)] \} \\<br>&amp; = \max_{0≤x_2≤s_2} \{ 0.545x_2 + 18.1075s_3 \}<br>\end{align}<br>$$<br>\[x^*_2 = s_2 ,f_2(s_2) = 18.6525s_2\]</p><p><strong>当 k = 1 时</strong></p><p>$$<br>\begin{align}<br>f_1(s_1)&amp; = \max_{0≤x_1≤s_1} \{ 9x_1 + 4(s_1-x_1) + f_2(s_2) \} \\<br>&amp; = \max_{0≤x_1≤s_1} \{ 9x_1 + 4(s_1-x_1)+18.6525[0.65x_1+0.95(s_1-x_1)] \} \\<br>&amp; = \max_{0≤x_1≤s_1} \{ -0.596x_1 + 21.72s_1 \}<br>\end{align}<br>$$</p><p>\[ x^*_1 = 0 , s_1 = 100 , y^*_1 = s_1 - x^*_1 = 100 , f_1(s_1) = 21.72s_1 = 2172 \]</p><p><strong>反推</strong></p><p>$$<br>\begin{cases}<br>s_2 &amp; = 0.65x_1 + 0.95(s_1 - x_1) = 95; x_2^* = s_2 = 95,y_2^* = 0 \\<br>s_3 &amp; = 0.65x_2 + 0.95(s_2 - x_2) = 61.75,取整得61,x_3^* = s_3 = 61,y_3^* = 0 \\<br>s_4 &amp; = 0.65x_3 + 0.95(s_3 - x_3) = 39.65,取整得39,x_4^* = s_4 = 39,y_4^* = 0<br>\end{cases}<br>$$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;之前在学算法时接触过不少动态规划的题目，但最近实践周在上数学建模的课，发现自己在动态规划算法上欠缺很多。步骤不规范、思路不清晰、数学推导欠缺
      
    
    </summary>
    
      <category term="数学" scheme="https://blog.pazyx.xyz/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="动态规划" scheme="https://blog.pazyx.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="完全背包" scheme="https://blog.pazyx.xyz/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    
      <category term="数学建模" scheme="https://blog.pazyx.xyz/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="连续型动态规划" scheme="https://blog.pazyx.xyz/tags/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>POJ 3254 Corn Fields（状压DP）</title>
    <link href="https://blog.pazyx.xyz/2018/07/07/poj-3254-corn-fields/"/>
    <id>https://blog.pazyx.xyz/2018/07/07/poj-3254-corn-fields/</id>
    <published>2018-07-06T19:22:10.000Z</published>
    <updated>2018-07-13T13:55:29.480Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目链接：<a href="http://poj.org/problem?id=3254" target="_blank" rel="noopener">http://poj.org/problem?id=3254</a> </strong></p><h1 id="Corn-Fields"><a href="#Corn-Fields" class="headerlink" title="Corn Fields"></a>Corn Fields</h1><p><strong>Time Limit:</strong> 2000MS     <strong>Memory Limit:</strong> 65536K</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Farmer John has purchased a lush new rectangular pasture composed of <em>M</em> by <em>N</em> (1 ≤ <em>M</em> ≤ 12; 1 ≤ <em>N</em> ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant.</p><p>Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant.</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Line 1: Two space-separated integers: <em>M</em> and <em>N</em><br>Lines 2..<em>M</em>+1: Line <em>i</em>+1 describes row <em>i</em> of the pasture with <em>N</em> space-separated integers indicating whether a square is fertile (1 for fertile, 0 for infertile)</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>Line 1: One integer: the number of ways that FJ can choose the squares modulo 100,000,000.</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 1 1</span><br><span class="line">0 1 0</span><br></pre></td></tr></table></figure><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p>Number the squares as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">  4</span><br></pre></td></tr></table></figure><p>There are four ways to plant only on one squares (1, 2, 3, or 4), three ways to plant on two squares (13, 14, or 34), 1 way to plant on three squares (134), and one way to plant on no squares. 4+3+1+1=9.</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>有 M×N 的玉米地，但其中有些是不肥沃的，不能种植。用 1 来代表肥沃，0 代表不肥沃。另外奶牛不喜欢挨着吃玉米，也就是说要间隔着种植，求有几种种植方式，并将计算结果对 100000000 取模。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>状压DP入门题目。题目中要求不能挨着种，也就是行内不允许有相邻的地，行内比较好控制，而行间思考一下其实只需要考虑相邻两行的玉米地是否有冲突。<br>使用一个二进制数表示一行的玉米种植情况<br>状态：某行的玉米地分布情况</p><p>转移方程：<code>dp[i][j] = (dp[i][j] + dp[i - 1][k])%mod</code><br>第 i 行种植方案为 j 的种植方式数为等于其本身加上第 i-1 行种植方案为 k 的种植方式数，j 和 k 方案不冲突，且 j 和 k 方案本身行内不冲突，且种植土地都为肥沃的土地。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_M = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> state[MAX_N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">1</span>][<span class="number">1</span> &lt;&lt; MAX_M];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fit</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (now | flag) == flag;</span><br><span class="line">&#125;<span class="comment">//是否都是肥沃的土地</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span> <span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x &amp; (x / <span class="number">2</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断行内是否冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">not_intersect</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (now &amp; prev) == <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//判断两行间是否冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)&#123;</span><br><span class="line">            <span class="keyword">int</span> flag;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; flag;</span><br><span class="line">            state[i] |= (<span class="number">1</span> &lt;&lt; j) * flag;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ok(i))</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; m); ++j)&#123;<span class="comment">//枚举当前行</span></span><br><span class="line">            <span class="keyword">if</span>(!ok(j) || !fit(j,state[i]))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; m); ++k)&#123;<span class="comment">//枚举下一行</span></span><br><span class="line">                <span class="keyword">if</span>(ok(k) &amp;&amp; fit(k,state[i<span class="number">-1</span>]) &amp;&amp; not_intersect(j,k))&#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][k]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); ++i)&#123;</span><br><span class="line">        ans = (ans + dp[n][i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目链接：&lt;a href=&quot;http://poj.org/problem?id=3254&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://poj.org/problem?id=3254&lt;/a&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
      <category term="题解" scheme="https://blog.pazyx.xyz/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="https://blog.pazyx.xyz/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="动态规划" scheme="https://blog.pazyx.xyz/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="题解" scheme="https://blog.pazyx.xyz/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="POJ" scheme="https://blog.pazyx.xyz/tags/POJ/"/>
    
      <category term="状压DP" scheme="https://blog.pazyx.xyz/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>「记」0x01 可乐</title>
    <link href="https://blog.pazyx.xyz/2018/07/04/weekly_1/"/>
    <id>https://blog.pazyx.xyz/2018/07/04/weekly_1/</id>
    <published>2018-07-04T13:39:47.000Z</published>
    <updated>2018-10-28T16:07:19.889Z</updated>
    
    <content type="html"><![CDATA[<p>考试周终于过去 我想写点什么 想写点自由的东西 因为考试周实在太过压抑 我已经一个月没去厦门放纵了 身体和心理都受到了折磨<br>在为数不多的几门需要大量写字的考试中 我多次提到自由和可乐 因为我渴望自由 我想在一堆答案里写点心里话自由一下<br>事实上我今天想写一写 <strong>可乐</strong> 我本想写的正经一点 因为我要发到我的博客上 一直以来我希望我的博客能够严谨认真 写完一篇检查多次 有什么错误马上打开电脑修改提交<br>今天我觉得既然要谈自由 我就自由一点吧 我也不想写什么标点符号 随便写写 反正这是我的博客 我来决定它的风格 我也不分段落和什么乱七八糟的 markdown 语法了 就按我想的来吧 其中可能有错别字（我已经看到了）我也不想改了 一切都波普</p><p>说到可乐 我已经在很多地方写过很多篇了 我想在这里总结一下 别回来都没了</p><ul><li><p>2017年8月28日 23:23</p><blockquote><p>去楼下超市买罐装可乐 发现罐装的雪碧和芬达都在唯独少了我的可乐 我很难过 之后我在罐装的雪碧芬达面前犹豫了一会儿 又看了看瓶装的可乐 我感觉那些都不是我想要的 你们知道我是个贵族非常讲究 瓶装和罐装的可乐完全是两个味儿 我走出那个超市决定去远方那个超市闯荡一次 之后我探访了两家超市结果它们只有瓶装的 最后我鼓足勇气走进了一家火锅店 问老板有罐装的可乐吗 他犹豫了一下说只有…… 说到这儿我心凉了 心想肯定是只有瓶装的 交谈间老板带着我走到了冰柜前 老板愣了一下说只有绿茶 他估计是在想怎么瓶装的可乐也没了 突然 我看到了冰柜上层的北冰洋 我想去他妈的罐装可乐 真够麻烦的 给我来瓶北冰洋 我喝着我的北冰洋走上了回家的路 感觉味道还可以 只是我感觉今天我有点儿不讲究了 所以说今天我这个贵族落魄了 我们等待明天 明天我带你们看看我的罐装可乐 带你们体验那种自由的味道     </p></blockquote></li><li><p>2017年10月24日 11:25</p><blockquote><p>自由的阳光 自由的可乐 军训让我体验了自由 唯一的遗憾就是为什么中区食堂的党员示范岗窗口的菜最好吃 我想如果我再多吃几天 也许我也能发现它不如人意的一面</p></blockquote></li><li><p>2018年3月16日 知乎问题：为什么有人愿意买 2.5 元 330ml 的易拉罐汽水，而不买 3 元 500ml 的瓶装？回答</p><blockquote><p>太巧了？我就是你说的那种买罐装可乐的人，而且我只买罐装的，更夸张的是我们学校罐装和瓶装都是3块。每次我买瓶装可乐都会剩一半以上后扔掉。<br>我想说啊，罐装的和瓶装的可乐它完全是两个味道。罐装的一般你需要一次喝完，汽很足。而瓶装的，打开放半个小时那口感是完全不能被接受的，只能扔掉。<br>对于我每天在食堂吃饭的情况来说，一罐罐装的可乐刚刚好，而瓶装的500ml显得略多，我还需要把它带回宿舍并且不能马上扔掉，因为那显得我很浪费。那样我就需要把它放上一段时间（一般是几个小时）得到一个足以安慰我内心的理由（它真的没汽了）再把它扔掉。我这个人很懒，不想那么麻烦。<br>还有就是在我喝完罐装可乐并扔掉罐的时候，我会有一种奇妙的感觉，就是我感觉到了自由。因为它不像瓶装可乐每次剩下的那些给我一种束缚感，我不需要为它找一个理由再扔掉。要知道自由在我们这个社会是很稀缺的，我很享受这种感觉，我很需要罐装可乐。<br>注意！我之前说的瓶装都是指塑料瓶装的，玻璃瓶装的那真是好味道，我可以保证它比塑料瓶装的和罐装的都更好喝并且更能让你感觉到那种自由的状态。</p></blockquote></li><li><p>2018年6月27日</p><blockquote><p>我想这可乐可能也没多自由 我一想象到可口可乐中国公司里的党支部开会的场面就浑身难受 这可乐代表不了自由 考完试我一定去买一瓶进口可乐感受一下自由 此刻请让我在外面溜达一会儿 让我吹一吹太平洋的风 今晚就是我的波普时间</p></blockquote></li></ul><p>要说我最喜欢这其中的哪篇 我觉得是第一篇 那篇写的很自由 很有现场感 也很有Andy Warhol的风格 而且它象征着我会写故事了<br>好了 言归正传 可乐为什么能代表自由？ 我也纳闷 我仔细回忆了一下应该是<strong>我瞎编的吧</strong> 高中我看了一些Andy Warhol的书<br>他说啊</p><blockquote><p>What’s great about this country is America started the tradition where the richest consumers buy essentially the same things as the poorest. You can be watching TV and see Coca-Cola, and you can know that the President drinks Coke, Liz Taylor drinks Coke, and just think, you can drink Coke, too. A Coke is a Coke and no amount of money can get you a better Coke than the one the bum on the corner is drinking. All the Cokes are the same and all the Cokes are good.<br>翻译：这个国家的伟大之处在于，美国开始了这样的传统:最富有的消费者买的东西基本上和最穷的人买的一样。你可以看电视，看可口可乐，你可以知道总统喝可乐，莉兹·泰勒喝可乐，想想，你也可以喝可乐。可口可乐就是可乐，再多的钱也买不到比街角的流浪汉喝的更好的可乐。所有的可乐都是一样的，所有的可乐都一样好。</p></blockquote><p><strong>现实 表面 瞬间 感性 快乐 平等 简单 机械 重复 大众</strong> 这是波普精神 可乐全占了 但就是没有自由 我也不知道 这个精神是谁想的 要是我就给它加上自由<br>写到这儿我大概明白了 可乐代表自由也许是因为快乐 我在自由的时刻最快乐 而且喝可乐也许这世上最简单的自由方式了 电影 肖申克的救赎 里他们在监狱房顶喝着啤酒 感受到了难得的自由<br>我想我喝可乐的时候跟他们一样 我感觉这个社会管得实在是太多了 各种网络社交媒体不能评论 不能发不能发的 各种好的网站都需要翻墙 媒体都在宣传正能量 说点其他都不行 我讨厌政治 但现在哪都是政治 可能我写了这一段我的网站就被封禁了 而且它们是合法的 因为我没备案 反正啊 我是托管在国外服务器上的 域名也是在国外买的也没备案 我也有了自己的梯子 封了我也可以自己写自己看<br>我还是希望人民们意识到自己的自由在一点一点被剥夺 实际上我们也无力反抗 如果不能像安迪一样逃出肖申克的话 还是与我一起共饮可乐吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;考试周终于过去 我想写点什么 想写点自由的东西 因为考试周实在太过压抑 我已经一个月没去厦门放纵了 身体和心理都受到了折磨&lt;br&gt;在为数不多的几门需要大量写字的考试中 我多次提到自由和可乐 因为我渴望自由 我想在一堆答案里写点心里话自由一下&lt;br&gt;事实上我今天想写一写 &lt;s
      
    
    </summary>
    
      <category term="泛 - 记" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%B0/"/>
    
    
      <category term="可乐" scheme="https://blog.pazyx.xyz/tags/%E5%8F%AF%E4%B9%90/"/>
    
      <category term="自由" scheme="https://blog.pazyx.xyz/tags/%E8%87%AA%E7%94%B1/"/>
    
      <category term="波普" scheme="https://blog.pazyx.xyz/tags/%E6%B3%A2%E6%99%AE/"/>
    
      <category term="Andy Warhol" scheme="https://blog.pazyx.xyz/tags/Andy-Warhol/"/>
    
      <category term="记" scheme="https://blog.pazyx.xyz/tags/%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>「笔记」Effective C++ 读书笔记（二）</title>
    <link href="https://blog.pazyx.xyz/2018/07/03/effective-cpp02/"/>
    <id>https://blog.pazyx.xyz/2018/07/03/effective-cpp02/</id>
    <published>2018-07-03T09:42:25.000Z</published>
    <updated>2018-07-20T12:30:47.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注意！"><a href="#注意！" class="headerlink" title="注意！"></a>注意！</h1><p>这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）。</p><h1 id="构造-析构-赋值运算"><a href="#构造-析构-赋值运算" class="headerlink" title="构造 / 析构 / 赋值运算"></a>构造 / 析构 / 赋值运算</h1><h2 id="条款05：了解-C-默默编写并调用哪些函数"><a href="#条款05：了解-C-默默编写并调用哪些函数" class="headerlink" title="条款05：了解 C++ 默默编写并调用哪些函数"></a>条款05：了解 C++ 默默编写并调用哪些函数</h2><p>一个 class 如果没有声明任何构造函数和析构函数，编译器会帮你声明以下的函数</p><ul><li>default 构造函数</li><li>copy 构造函数</li><li>copy assignment 操作符</li><li>析构函数<br>所有这些编译器为你生成的函数都是 public 的、<strong>大多数</strong>都是 inline 的（ Effective C++ 写的是都是 inline ），且只在需要时生成。</li></ul><p>当你声明了任何一个构造函数，编译器将不再为你声明 default 构造函数。</p><p>对于两个要做拷贝的函数，它们可能是 bitwise 或者 memberwise。具体的 Effective C++ 只做了简略的解释。想深入了解的可以看《深度探索C++对象模型》，之后我也会写读书笔记或书摘。</p><p>如果类中存在不可重新赋值的成员将报错。</p><p>比如下面的类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">NamedObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NamedObject(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; name, <span class="keyword">const</span> T&amp; value):nameValue(name),objectValue(value)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; nameValue;</span><br><span class="line"><span class="keyword">const</span> T objectValue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>引用类型和 const 修饰的成员不可被重新赋值，如果存在两个 <code>NamedObject&lt;int&gt;</code> 类的对象 a 和 b ，做 <code>a = b</code> 将直接报错。编译器无法为它声明拷贝函数。<br>如果基类的 copy assignment 操作符被声明为 private 也是会导致编译失败。</p><h2 id="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#条款06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2><p>可以将构造函数声明为 private 禁止调用。比如有些类不希望被拷贝，可以将 copy 构造函数和 copy assignment 操作符声明为 private 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Uncopyable()&#123;&#125;</span><br><span class="line">~Uncopyable()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>也可以让不希望被拷贝的类直接继承 Uncopyable 类。Boost 库中也提供了名为 noncopyable 的class 保证被继承的类不被拷贝。</p><h2 id="条款07：为多态基类声明-virtual-析构函数"><a href="#条款07：为多态基类声明-virtual-析构函数" class="headerlink" title="条款07：为多态基类声明 virtual 析构函数"></a>条款07：为多态基类声明 virtual 析构函数</h2><p>基类无虚析构函数，会导致向上造型后被部分销毁导致内存泄露。</p><p>谨慎继承不带虚析构函数的类，如：string、STL 库中的所有容器…</p><p>不是所有的类都需要虚析构函数，vptr 和 vtbl 会占有大量空间，且降低了可移植性（不可传给其他语言）。</p><blockquote><p>许多人的心得时：只有当 class 内含至少一个 virtual 函数 才为它声明 virtual 析构函数。</p></blockquote><h2 id="条款08：别让异常逃离析构函数"><a href="#条款08：别让异常逃离析构函数" class="headerlink" title="条款08：别让异常逃离析构函数"></a>条款08：别让异常逃离析构函数</h2><p>C++ 不能同时处理多个异常，主要原因是被抛出的元素的内存空间是分配在栈区的，抛出异常后会跳出那一层括号，栈区应该被清理。如果你在存在一个异常的情况下去处理另一个异常很可能会覆盖掉之前异常抛出的元素，<strong>导致程序过早结束或出现不明确行为</strong>。<br>如果你的类中析构会抛出异常，那这个类的容器或数组在析构时很可能遇到多个异常，造成严重的后果。</p><p>有时我们类的析构函数必须执行一个可能抛出异常的行为时怎么办？比如关闭各种连接。<br>书中提供了三种方案<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; A.close(); &#125;</span><br><span class="line"><span class="keyword">catch</span>(...)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">&#125; <span class="comment">//调用 abort 结束程序</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; A.close(); &#125;</span><br><span class="line"><span class="keyword">catch</span>(...)&#123;</span><br><span class="line"><span class="comment">//记下运转记录，记下对 close 的调用失败</span></span><br><span class="line">&#125; <span class="comment">//吞下异常</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">db.close();</span><br><span class="line">closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line"><span class="keyword">if</span>(!closed)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123; db.close(); &#125;</span><br><span class="line"><span class="keyword">catch</span>(...)&#123;</span><br><span class="line"><span class="comment">//记下运转记录，记下对 close 的调用失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种就是直接将 close 函数开放给使用者，让使用者在析构前调用。</p><h2 id="条款09：绝不在构造和析构过程中调用-virtual-函数"><a href="#条款09：绝不在构造和析构过程中调用-virtual-函数" class="headerlink" title="条款09：绝不在构造和析构过程中调用 virtual 函数"></a>条款09：绝不在构造和析构过程中调用 virtual 函数</h2><p>在构造函数和析构函数中调用虚成员函数，可能得不到你想要的结果，它实际上会调用基类的那个函数。</p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><h4 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h4><p>构造过程进入基类的构造函数时，派生类的成员还没被初始化，如果调用派生类的虚函数可能会用到派生类部分的成员，所以编译器将构造过程中的对象当做 当前进入的构造函数所属的类的一个对象，当然只能调用与当前构造函数同属一个类的函数了。</p><h4 id="析构过程"><a href="#析构过程" class="headerlink" title="析构过程"></a>析构过程</h4><p>进入析构函数，先销毁掉派生类的成员，在刚进入析构函数时这个对象已经不是完整的一个派生类的对象了，编译器只能把它当做它的基类的一个对象来看待。</p><blockquote><p>在构造和析构期间不要调用 virtual 函数，因为这个类调用从不下降至 drived class (比起当前执行构造函数和析构函数的那层)。</p></blockquote><h2 id="条款10：令-operator-返回一个-reference-to-this"><a href="#条款10：令-operator-返回一个-reference-to-this" class="headerlink" title="条款10：令 operator= 返回一个 reference to *this"></a>条款10：令 operator= 返回一个 <code>reference to *this</code></h2><p>返回 <code>*this</code> 的引用，可以让你的类的对象实现连锁赋值。<br>如：<code>x = y = z = 15;</code></p><h2 id="条款11：在-operator-中处理“自我赋值”"><a href="#条款11：在-operator-中处理“自我赋值”" class="headerlink" title="条款11：在 operator= 中处理“自我赋值”"></a>条款11：在 operator= 中处理“自我赋值”</h2><p>如果类中存在一个指向堆中元素的成员，那就要注意赋值时的自我赋值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">string</span> *s;</span><br><span class="line">A():s(<span class="keyword">new</span> <span class="built_in">string</span>())&#123;&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">s = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果 <code>this</code> 和 <code>&amp;rhs</code> 相等就尴尬了，它会先 delete 自己的 s ，实际上 <code>*this</code> 和 <code>rhs</code> 里的 s 指向的 string 对象都被销毁了。数据丢失而去之后也没办法使用成员 s 了。</p><p>相对安全的版本是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">string</span> *s;</span><br><span class="line">A():s(<span class="keyword">new</span> <span class="built_in">string</span>())&#123;&#125;</span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> s;</span><br><span class="line">s = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>加入认同测试，保证了 “自我赋值” 的安全性，但还不具备 “异常安全性”。<br>如果在 <code>s = new string(*rhs.s);</code> 这一步导致异常，那 s 将指向一块已被删除的 string 。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span>* pOrig = pb;</span><br><span class="line">s = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.s);</span><br><span class="line"><span class="keyword">delete</span> pOrig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样即使抛出异常，赋值失败也不会造成其他副作用，可以将 s 保持原状。</p><p><strong>copy and swap</strong> 技术<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span></span>; <span class="comment">//交换*this 和 rhs 的数据 见条款29</span></span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">A temp(rhs);</span><br><span class="line">swap(temp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>by value</strong> 传值方式的 <strong>copy and swap</strong> 技术<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A&amp; rhs)</span></span>; <span class="comment">//交换*this 和 rhs 的数据 见条款29</span></span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> A rhs)</span><br><span class="line">&#123;</span><br><span class="line">swap(rhs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="条款12：复制对象时勿忘其每个成分"><a href="#条款12：复制对象时勿忘其每个成分" class="headerlink" title="条款12：复制对象时勿忘其每个成分"></a>条款12：复制对象时勿忘其每个成分</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">A()&#123;&#125;</span><br><span class="line">A(A &amp;rhs):a(rhs.a)&#123;&#125;</span><br><span class="line"></span><br><span class="line">A&amp; <span class="keyword">operator</span>= (A &amp;rhs)&#123;</span><br><span class="line">a = rhs.a;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B()&#123;&#125;</span><br><span class="line">B(B &amp;rhs):b(rhs.b)&#123;&#125;</span><br><span class="line"></span><br><span class="line">B&amp; <span class="keyword">operator</span>= (B &amp;rhs)&#123;</span><br><span class="line">b = rhs.b;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>小心这样的代码，B 的两个 <strong>Copying</strong> 函数，都没有拷贝基类的数据( <code>int a</code> )。</p><blockquote><p><strong>Copying</strong> 函数应该确保赋值“对象内的所有成员变量” 及 “所有 base class 成分”。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B()&#123;&#125;</span><br><span class="line">B(B &amp;rhs):b(rhs.b),A(rhs)&#123;&#125; <span class="comment">// + ! </span></span><br><span class="line"></span><br><span class="line">B&amp; <span class="keyword">operator</span>= (B &amp;rhs)&#123;</span><br><span class="line">A::<span class="keyword">operator</span>=(rhs);<span class="comment">// + !</span></span><br><span class="line">b = rhs.b;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>两个 <strong>Copying</strong> 函数一般有相近的代码，但不要在一个 <strong>Copying</strong> 函数内调用另一个 <strong>Copying</strong> 函数。</p><blockquote><p>应该将共同机能放进第三个函数中，并由两个 <strong>Copying</strong> 函数共同调用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注意！&quot;&gt;&lt;a href=&quot;#注意！&quot; class=&quot;headerlink&quot; title=&quot;注意！&quot;&gt;&lt;/a&gt;注意！&lt;/h1&gt;&lt;p&gt;这只是我的读书笔记，帮助我记录。其中可能有一些不严谨的解释或没有做很详细的解释，大家学习还是建议直接看书（虽然书中也有不严谨的解释）
      
    
    </summary>
    
      <category term="泛 - 笔记" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Cpp" scheme="https://blog.pazyx.xyz/tags/Cpp/"/>
    
      <category term="读书" scheme="https://blog.pazyx.xyz/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="笔记" scheme="https://blog.pazyx.xyz/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Effective C++" scheme="https://blog.pazyx.xyz/tags/Effective-C/"/>
    
      <category term="构造函数" scheme="https://blog.pazyx.xyz/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="运算符重载" scheme="https://blog.pazyx.xyz/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="拷贝构造函数" scheme="https://blog.pazyx.xyz/tags/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="缺省构造函数" scheme="https://blog.pazyx.xyz/tags/%E7%BC%BA%E7%9C%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="virtual 函数" scheme="https://blog.pazyx.xyz/tags/virtual-%E5%87%BD%E6%95%B0/"/>
    
      <category term="自我赋值" scheme="https://blog.pazyx.xyz/tags/%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC/"/>
    
      <category term="异常" scheme="https://blog.pazyx.xyz/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Java 与 C++ 细节差异 （一）</title>
    <link href="https://blog.pazyx.xyz/2018/07/01/cpptojava/"/>
    <id>https://blog.pazyx.xyz/2018/07/01/cpptojava/</id>
    <published>2018-07-01T15:08:37.000Z</published>
    <updated>2018-07-04T17:34:10.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>相比 C++，Java提供了三种注释方式分别为</p><ul><li><code>//</code> 单行注释</li><li><code>/* ... */</code> 多行注释 </li><li><code>/** ... */</code> 文档注释<br>前两种与 C++ 相同，最后一种可以自动将注释内容生成文档。供使用者直接查看。</li></ul><hr><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><table><thead><tr><th>Java</th><th>存储空间</th><th>C++</th><th>存储空间</th></tr></thead><tbody><tr><td>int</td><td>4 字节</td><td>int</td><td>至少 4 字节，且大于等于 short</td></tr><tr><td>short</td><td>2 字节</td><td>short</td><td>至少 2 字节</td></tr><tr><td>long</td><td>8 字节</td><td>long</td><td>至少 4 字节，且大于等于 int</td></tr><tr><td>byte</td><td>1 字节</td><td></td><td></td></tr><tr><td></td><td></td><td>long long</td><td>至少 8 字节，且大于等于 long</td></tr></tbody></table><p>Java 提供了 4 种整数类型，与 C++ 相比 Java 的规范更为严格。可以看出 C++ 更在乎效率，而 Java 更在乎可移植性。</p><p>十六进制数和八进制数两种语言均可以使用  0x 和 0 为前缀来表示，而 Java 还提供了前缀 0b 来表示二进制数。</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><table><thead><tr><th>Java</th><th>存储空间</th><th>C++</th><th>存储空间</th></tr></thead><tbody><tr><td>float</td><td>4 字节</td><td>float</td><td>4 字节</td></tr><tr><td>double</td><td>8 字节</td><td>double</td><td>8 字节</td></tr><tr><td></td><td></td><td>long double ( Intel )</td><td>16 字节</td></tr></tbody></table><p>两者都遵循  IEEE-754 标准</p><p>C++ 直接提供了 80 位的扩展精度浮点数，而 Java 没有提供。<br>Java 没有提供的原因还是对可移植性的考虑，值得注意的是如果 JVM 运行在 Intel 的处理器上时，浮点数的中间运算结果默认是采用扩展精度存储的。这是因为截断会使效率大幅降低，但 Java 也提供了截断的可能性，使用 <code>strictfp</code> 关键字标记的方法（函数）必须严格的对中间结果截断，保证在任何处理器环境的结果的一致性。<br>例：<code>public static strictfp void main(String[] args)</code></p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>Java 禁止使用未初始化的<strong>本地变量</strong>，C++ 可以。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>修饰符不同，Java 使用 final 修饰常量，但 const 也是 Java 的保留字。</p><table><thead><tr><th>Java</th><th>C++</th></tr></thead><tbody><tr><td><code>final type</code></td><td><code>const type</code></td></tr></tbody></table><p>常量可以不在定义出初始化，但必须保证在第一次使用前被初始化，且只初始化一次。</p><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Java 没有 C++ 中在栈区分配到数组，你不可以写出这样的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p><p>所有的数组，都需要使用 <code>new</code> 在堆上分配空间。</p><p>Java 提供了两种定义数组的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br></pre></td></tr></table></figure></p><p>如果你没有初始化数组，Java 会帮你做数组的初始化。数字数组将所有元素初始化为 0 ，boolean 数组初始化为 false，对象数组初始化为 null 。</p><p>Java 中 <code>[]</code>运算符被定义为检查数组边界，而且 Java 没有指针运算，不可以通过 <code>a + 1</code> 得到下一个元素。</p><hr><h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><table><thead><tr><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>一个以字母开头的由字母或数字组成的序列，字母包括{‘A’ ~ ‘Z’、’a’ ~ ‘z’、’_’、’$’ 或在某种语言中代表字母的任何 Unicode 字符 }。</td><td>一个由数字，下划线，小写和大写拉丁字母，和大多数 Unicode 字符组成的任意长度的序列。有效的标识符必须以一个非数字字符（拉丁语字母，下划线或 Unicode 非数字字符）开头。</td></tr></tbody></table><p>注：<br>Java 中在某种语言中代表字母的任何 Unicode 字符，比如德国用户可以用 ä 。可以使用 Character 类的 isJavaIdentifierStart 和 isJavaIdentifierPart 方法检测。</p><p>C++ 中大多数 Unicode 字符是指除下表中的字符以外的 Unicode 字符。</p><table><thead><tr><th>代码点</th><th>说明</th></tr></thead><tbody><tr><td>U+0300 - U+036F</td><td>组合用抑音符 - 组合用拉丁文小写字母 X</td></tr><tr><td>U+1DC0 - U+1DFF</td><td>组合用带点抑音符 - 组合用下右箭头尖和向下箭头尖</td></tr><tr><td>U+20D0 - U+20FF</td><td>组合用上左鱼叉 - 组合用上星号</td></tr><tr><td>U+FE20 - U+FE2F</td><td>组合用连字左半 - 组合用西里尔文 Titlo 右半</td></tr></tbody></table><hr><h1 id="重名问题"><a href="#重名问题" class="headerlink" title="重名问题"></a>重名问题</h1><p>在 C++ 中你可以写出这样的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样进入大括号后，外层的整数 a 就被隐藏了，看不到了无法访问了，出大括号就可以继续访问外层的整数 a 了。</p><p>而在 Java 中编译器是不允许你写出这样的代码的。<br>Java 和 C++ 大体上相同，本地变量的生存期是由其所在的大括号决定的。它们两者的不同之处在于 Java 是完全不允许在一个变量的生存期内出现另一个重名的变量，而 C++ 允许在内层定义新的重名变量隐藏外层变量。</p><p>例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure></p><p>这样的代码在两种语言中都是错误的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure><p>这样的代码在两种语言中都是正确的。</p><p>二者唯一的差别就是我在最开始的那个例子，Java 在外层 a 的生存期还没结束前不可以定义新的重名变量，而 C++ 可以。</p><hr><h1 id="String-与-string"><a href="#String-与-string" class="headerlink" title="String 与 string"></a>String 与 string</h1><p>String 和 string 分别为 Java 和 C++ 库里的字符串，虽然只是差一个字母大小写，实际上它们有着巨大的差异。<br>string 更像是 char 的数组，它的每个单位都是可以直接这样 <code>s[index]</code> 访问的，而且可以进行修改。<br>String 就没有那么方便了，Java 没有运算符重载只能通过 <code>s.charAt( index )</code> 来转换成 <code>char</code> 再读。<strong>注意！String 没有提供写操作的方法。String 在 Java 中是一种不可修改的字符串。</strong></p><p>这实际上是效率优化上的不同想法，C++ 中每个 string 的对象都独占一块内存空间，Java 的 String 不可修改就可以将多个相同的字符串变量共享一块内存空间，复制操作效率也变得很高。但这样就要在字符串比较时特别注意，Java 的对象变量都是对象的管理者，且 Java 没有运算符重载，如果你有两个 String 的对象 a 和 b ，<code>a == b</code> 只是在判断它们管理的是不是一块内存空间。Java 相同字符串的共享内存空间的分配方案也不是 100% 的，它只是在合适的情况下共享空间，所以两个内容相同的字符串也不一定指向同一个内存空间。它的比较有时相等有时不相等都是很有可能的，所以不要那么做！<br>比较操作 <code>a.equals(b)</code> 使用 String 的 equals 方法即可。</p><p>那到底怎么修改字符串呢？你可以使用 <code>+</code> 运算符和 <code>substring</code> 方法进行拼接和切割字符串最后再赋值给原字符串。但这会有很大的开销，因为中间结果要生成很多不可改变的 String 对象。可以使用 StringBuilder 或者 StringBuffer。</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh.cppreference.com/w/cpp/language/types" target="_blank" rel="noopener">C++ 基础类型标准</a><br><a href="https://zh.cppreference.com/w/cpp/language/identifiers" target="_blank" rel="noopener">C++ 标识符标准</a><br><a href="https://docs.oracle.com/javase/specs/" target="_blank" rel="noopener">The Java® Language Specification</a><br>Java 核心技术 卷I —— Cay S. Horstmann、Gary Cornell<br>深入理解 Java 虚拟机 —— 周志明</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h1&gt;&lt;p&gt;相比 C++，Java提供了三种注释方式分别为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;//&lt;/code&gt; 单行注释&lt;/li&gt;
&lt;li&gt;&lt;co
      
    
    </summary>
    
      <category term="编程语言 - Java" scheme="https://blog.pazyx.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Java/"/>
    
    
      <category term="Cpp" scheme="https://blog.pazyx.xyz/tags/Cpp/"/>
    
      <category term="浮点数" scheme="https://blog.pazyx.xyz/tags/%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    
      <category term="Java" scheme="https://blog.pazyx.xyz/tags/Java/"/>
    
      <category term="整数" scheme="https://blog.pazyx.xyz/tags/%E6%95%B4%E6%95%B0/"/>
    
      <category term="命名规则" scheme="https://blog.pazyx.xyz/tags/%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
    
      <category term="String" scheme="https://blog.pazyx.xyz/tags/String/"/>
    
      <category term="string" scheme="https://blog.pazyx.xyz/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>basic_ios 如何穿上它的 bool</title>
    <link href="https://blog.pazyx.xyz/2018/06/29/cin-return/"/>
    <id>https://blog.pazyx.xyz/2018/06/29/cin-return/</id>
    <published>2018-06-28T17:19:17.000Z</published>
    <updated>2018-07-04T17:33:36.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么可以-while-cin-gt-gt-n-？"><a href="#为什么可以-while-cin-gt-gt-n-？" class="headerlink" title="为什么可以 while( cin &gt;&gt; n ) ？"></a>为什么可以 while( cin &gt;&gt; n ) ？</h1><p>这个问题困扰了我很久。每次写出那行代码都在为什么没有输入时它会停，为什么可以这样写，每次写时都有些虚。<br>为了保持我的自信，我想象了很多情况来安抚自己。<br>起初我类比 C 语言，想着应该是 <code>cin</code> 这个鬼东西返回了一个 <code>bool</code> 类型的值。之后在学习了类与对象后，发现 <code>cin</code> 不过是个对象不可能返回什么值。我又给出了新的解释：也许 <code>cin &gt;&gt; n</code> 这个表达式是个 <code>bool</code> 类型的值吧。再之后我看运算符重载时，刚刚的解释也凉了。表达式 <code>cin &gt;&gt; n</code> 的值是 <code>&lt;&lt;</code> 的运算符重载函数返回的一个 basic_istream 类的对象而已。</p><p><strong>我的想象力有一些枯竭了 … …</strong></p><p>直到这几天我在看《深度探索C++对象模型》书时，书中的例子中提到了 basic_ios 的类型转换函数，又让我想起了之前的问题。我查阅了大量资料，大致搞清楚了 究竟为什么可以？和 解决方案的演变过程。</p><h2 id="while-的括号里能放什么？"><a href="#while-的括号里能放什么？" class="headerlink" title="while 的括号里能放什么？"></a>while 的括号里能放什么？</h2><blockquote><p>任何能按语境转换为 bool 的表达式，或带花括号或等号初始化器的单个变量声明。<br>每次迭代前求值此表达式，而若它产出 <code>false</code> ，则退出循环。若此为声明，则每次迭代前求值初始化器，且若被声明变量的值转换为 <code>false</code> ，则退出循环。</p></blockquote><h2 id="什么可以转换为-bool？"><a href="#什么可以转换为-bool？" class="headerlink" title="什么可以转换为 bool？"></a>什么可以转换为 bool？</h2><p>对于原始数据类型，适用于C++ 标准中的<strong>布尔转换</strong>规则<br>规则如下：</p><blockquote><p><strong>整数</strong>、浮点、无作用域枚举、<strong>指针和指向成员指针类型的纯右值</strong>能转换成 <code>bool</code> 类型纯右值。<br>值零（对于整数、浮点和无作用域枚举）、<strong>空指针值和空成员指针值</strong>变为 <code>false</code> 。所有其他值变为 <code>true</code> 。<br><code>std::nullptr_t</code> 类型纯右值，包括 <code>nullptr</code> ，能在直接初始化的语境中转换成 <code>bool</code> 类型纯右值。结果值为 <code>false</code> 。(C++11 起)</p></blockquote><p>对于用户定义类型，则需要给出 类型转换函数 或 以目标类型为参数的构造函数。</p><h2 id="究竟为什么可以？"><a href="#究竟为什么可以？" class="headerlink" title="究竟为什么可以？"></a>究竟为什么可以？</h2><p>我直接给出答案：basic_istream 的基类 basic_ios 类有一个 bool( ) 的运算符重载函数，也就是类型转换函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// C++11 </span></span><br><span class="line"><span class="comment">//若流无错误则为 true ，否则为 false 。</span></span><br></pre></td></tr></table></figure></p><p>这样就解决了上述问题，表达式 <code>cin &gt;&gt; n</code> 的值被转换为 <code>bool</code> 类型当然可以放在 while 的括号内没有任何问题。</p><hr><h1 id="演变过程"><a href="#演变过程" class="headerlink" title="演变过程"></a>演变过程</h1><p>上面的只是 C++11 标准库的解决方案。其实更有意思的是 basic_istream 的对象转换到 bool 类型在实现上的一些历史演变过程。</p><h2 id="operator-int-const"><a href="#operator-int-const" class="headerlink" title="operator int() const;"></a>operator int() const;</h2><p>由于 C++ 早期是没有 <code>bool</code> 类型的，iostream 库的构建者 Jerry Schwarz 希望通过为 basic_ios 类编写一个类型转换函数，提供将 basic_ios 类转换为 <code>int</code> 类型的方式，实现 <code>while( cin &gt;&gt; n )</code>。<br>可这样写后他发现一个问题，就是有人可能写出下面这种代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &lt;&lt; intValue; <span class="comment">// 正确的应该为 cin &gt;&gt; Value;</span></span><br></pre></td></tr></table></figure></p><p>由于 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 运算符很容易让程序员用乱，有的人可能会写出上面的错误代码，但当时的编译器没有报错。<br>因为编译器发现 <code>cin</code> 是没有重载 <code>&lt;&lt;</code> ，但 <code>int</code> 是可以做左移 ( <code>&lt;&lt;</code> ) 的，程序将 basic_ios 的对象转换为 <code>int</code> 又进行了左移操作。这算不上错误，但至少将大部分程序员的错误隐藏了，让人难以定位错误。<br>这个错误之后被戏称为“Schwarz Error”，在这之后 Jerry Schwarz 用下面的函数取代了 <code>operator int () const;</code></p><h2 id="operator-void-const"><a href="#operator-void-const" class="headerlink" title="operator void*() const;"></a>operator void*() const;</h2><p>C++ 的标准中 <code>void*</code> 能隐式转换为 <code>bool</code> 类型，Jerry Schwarz 想到了这种方式，<br>并且还为 basic_ios 类重载了 <code>!</code> 运算符，以支持 <code>while( ! ( cin &gt;&gt; n ) )</code>。<br>这个函数一直维持到 C++11 的出现。</p><h2 id="explicit-operator-bool-const"><a href="#explicit-operator-bool-const" class="headerlink" title="explicit operator bool() const;"></a>explicit operator bool() const;</h2><p>之前的 <code>operato void*() const;</code> 其实是有安全风险的。<br>你可以直接给一个 <code>void*</code> 类型的变量赋一个 basic_ios 类的对象，并且没有任何的错误或警告。这是不安全的，这种类型转换应该是显性的才安全。<br>C++11 改变了隐式转换的一些规则，解决了安全 bool 问题。<br>C++11 之前在类型转换运算符重载函数前加上 <code>explicit</code> 关键字，声明它必须显式使用，以强制类型转换的形式去操作。比如：<code>bool b = (bool)cin</code> 才可以使用类型转换函数，而不能做 <code>bool b = cin</code> 这样的操作。<br>而 C++11 标准对目标为 <code>bool</code> 类型的转换，改变了标准。</p><p><strong>具体标准如下：</strong></p><blockquote><p>下列语境中，期待类型 <code>bool</code> ，而若声明 <code>bool t(e)</code>; 为良式则进行隐式转换（即考虑如 <code>explicit T::operator bool() const;</code> 的隐式转换函数）。我们说这种表达式 <code>e</code> 可按语境转换为 <code>bool</code>。</p><ul><li><code>if</code> 、 <code>while</code> 、 <code>for</code> 的控制表达式；</li><li>内建逻辑运算符 <code>!</code> 、 <code>&amp;&amp;</code> 和 <code>||</code> 的运算数；</li><li>条件运算符 <code>?:</code> 的首个运算数；</li><li><code>static_assert</code>  声明中的谓词；(C++11起)</li><li><code>noexcept</code>  指定符中的表达式；</li><li><code>explicit</code>  指定符中的表达式；(C++20 起)</li><li>契约属性 的谓词。(C++20 起)</li></ul></blockquote><p>这样在非上述语境下转换为 <code>bool</code> 类型就需要显式转换，而在控制表达式中可以自动的隐式转换。增强安全性的同时也保证向前兼容。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">隐式转换</a></li><li><a href="https://zh.cppreference.com/w/cpp/io/basic_ios" target="_blank" rel="noopener">std::basic_ios</a></li><li><a href="https://zh.cppreference.com/w/cpp/io/basic_ios/operator_bool" target="_blank" rel="noopener">std::basic_ios::operator bool</a></li><li><a href="https://zh.cppreference.com/w/cpp/language/explicit" target="_blank" rel="noopener">explicit 指定符</a></li><li><a href="https://zh.cppreference.com/w/cpp/language/while" target="_blank" rel="noopener">while 循环</a></li><li><a href="https://zh.cppreference.com/w/cpp/language/if" target="_blank" rel="noopener">if 语句</a></li><li>《深度探索C++对象模型》—— Stanley B. Lippman</li><li>《C++语言的设计与演化》—— Bjarne Stroustrup</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么可以-while-cin-gt-gt-n-？&quot;&gt;&lt;a href=&quot;#为什么可以-while-cin-gt-gt-n-？&quot; class=&quot;headerlink&quot; title=&quot;为什么可以 while( cin &amp;gt;&amp;gt; n ) ？&quot;&gt;&lt;/a&gt;为什么可以
      
    
    </summary>
    
      <category term="编程语言 - Cpp" scheme="https://blog.pazyx.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Cpp/"/>
    
    
      <category term="Cpp" scheme="https://blog.pazyx.xyz/tags/Cpp/"/>
    
      <category term="bool" scheme="https://blog.pazyx.xyz/tags/bool/"/>
    
      <category term="basic_ios" scheme="https://blog.pazyx.xyz/tags/basic-ios/"/>
    
      <category term="运算符重载" scheme="https://blog.pazyx.xyz/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
      <category term="类型转换" scheme="https://blog.pazyx.xyz/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
      <category term="Cpp演化" scheme="https://blog.pazyx.xyz/tags/Cpp%E6%BC%94%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>System.in</title>
    <link href="https://blog.pazyx.xyz/2018/06/16/System-in/"/>
    <id>https://blog.pazyx.xyz/2018/06/16/System-in/</id>
    <published>2018-06-16T12:18:32.000Z</published>
    <updated>2018-07-21T14:19:57.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Scanner-in-new-Scanner-System-in"><a href="#Scanner-in-new-Scanner-System-in" class="headerlink" title=" Scanner in = new Scanner(System.in) "></a><center> Scanner in = new Scanner(System.in) </center></h1><h4 id="2018-6-10"><a href="#2018-6-10" class="headerlink" title=" 2018.6.10 "></a><center> 2018.6.10 </center></h4><p><img src="/2018/06/16/System-in/1.png" alt=""></p><p><img src="/2018/06/16/System-in/2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Scanner-in-new-Scanner-System-in&quot;&gt;&lt;a href=&quot;#Scanner-in-new-Scanner-System-in&quot; class=&quot;headerlink&quot; title=&quot; Scanner in = new Scanner(Sy
      
    
    </summary>
    
      <category term="泛 - 纪念" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E7%BA%AA%E5%BF%B5/"/>
    
    
      <category term="ACM" scheme="https://blog.pazyx.xyz/tags/ACM/"/>
    
      <category term="省赛" scheme="https://blog.pazyx.xyz/tags/%E7%9C%81%E8%B5%9B/"/>
    
      <category term="ACM题目" scheme="https://blog.pazyx.xyz/tags/ACM%E9%A2%98%E7%9B%AE/"/>
    
      <category term="纪念" scheme="https://blog.pazyx.xyz/tags/%E7%BA%AA%E5%BF%B5/"/>
    
      <category term="Java" scheme="https://blog.pazyx.xyz/tags/Java/"/>
    
      <category term="Scanner" scheme="https://blog.pazyx.xyz/tags/Scanner/"/>
    
      <category term="System.in" scheme="https://blog.pazyx.xyz/tags/System-in/"/>
    
  </entry>
  
  <entry>
    <title>GCC LD DD 命令选项</title>
    <link href="https://blog.pazyx.xyz/2018/05/11/gcc-ld-dd-cmd/"/>
    <id>https://blog.pazyx.xyz/2018/05/11/gcc-ld-dd-cmd/</id>
    <published>2018-05-11T15:36:31.000Z</published>
    <updated>2018-07-06T20:08:56.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>此篇仅介绍一些我在 ucore 操作系统的 makefile 文件中遇到的命令选项，作为 lab_1 实验报告的一部分。</p><h1 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h1><ul><li>-c 进行预处理、编译、汇编，生成目标代码文件，不进行链接</li><li>-S 仅进行预处理、编译，生成汇编代码文件</li><li>-E 仅进行预处理</li><li><p>-o file 指定输出文件名</p><p><a href="https://paste.ubuntu.com/p/yJmG6rPmXN/" target="_blank" rel="noopener">GCC 8.1 manuals 摘录</a></p></li><li><p>-I (大写 i ) 指定头文件位置</p></li><li>-L (大写 L ) 指定库文件位置</li><li><p>-l (小写 L) 指定库名字</p><p>-I -L -l 选项的详解分别在 <a href="https://gcc.gnu.org/onlinedocs/gcc-8.1.0/gcc/" target="_blank" rel="noopener">GCC 8.1 manuals</a> 的第 200、201、195 页</p></li><li>-Wall 开启大部分警告，列表如下。一些不常用的警告可加 -Wextra 选项配合 - Wall 全部打开</li></ul><table><thead><tr><th>选项</th></tr></thead><tbody><tr><td><code>-Waddress</code></td></tr><tr><td><code>-Warray-bounds=1 (only with ‘-O2’)</code></td></tr><tr><td><code>-Wbool-compare</code></td></tr><tr><td><code>-Wbool-operation</code></td></tr><tr><td><code>-Wc++11-compat -Wc++14-compat</code></td></tr><tr><td><code>-Wcatch-value (C++ and Objective-C++ only)</code></td></tr><tr><td><code>-Wchar-subscripts</code></td></tr><tr><td><code>-Wcomment</code></td></tr><tr><td><code>-Wduplicate-decl-specifier (C and Objective-C only)</code></td></tr><tr><td><code>-Wenum-compare (in C/ObjC; this is on by default in C++)</code></td></tr><tr><td><code>-Wformat</code></td></tr><tr><td><code>-Wint-in-bool-context</code></td></tr><tr><td><code>-Wimplicit (C and Objective-C only)</code></td></tr><tr><td><code>-Wimplicit-int (C and Objective-C only)</code></td></tr><tr><td><code>-Wimplicit-function-declaration (C and Objective-C only)</code></td></tr><tr><td><code>-Winit-self (only for C++)</code></td></tr><tr><td><code>-Wlogical-not-parentheses</code></td></tr><tr><td><code>-Wmain (only for C/ObjC and unless ‘-ffreestanding’)</code></td></tr><tr><td><code>-Wmaybe-uninitialized</code></td></tr><tr><td><code>-Wmemset-elt-size</code></td></tr><tr><td><code>-Wmemset-transposed-args</code></td></tr><tr><td><code>-Wmisleading-indentation (only for C/C++)</code></td></tr><tr><td><code>-Wmissing-attributes</code></td></tr><tr><td><code>-Wmissing-braces (only for C/ObjC)</code></td></tr><tr><td><code>-Wmultistatement-macros</code></td></tr><tr><td><code>-Wnarrowing (only for C++)</code></td></tr><tr><td><code>-Wnonnull</code></td></tr><tr><td><code>-Wnonnull-compare</code></td></tr><tr><td><code>-Wopenmp-simd</code></td></tr><tr><td><code>-Wparentheses</code></td></tr><tr><td><code>-Wpointer-sign</code></td></tr><tr><td><code>-Wreorder</code></td></tr><tr><td><code>-Wreorder</code></td></tr><tr><td><code>-Wrestrict</code></td></tr><tr><td><code>-Wreturn-type</code></td></tr><tr><td><code>-Wsequence-point</code></td></tr><tr><td><code>-Wsign-compare (only in C++)</code></td></tr><tr><td><code>-Wsizeof-pointer-div</code></td></tr><tr><td><code>-Wsizeof-pointer-memaccess</code></td></tr><tr><td><code>-Wstrict-aliasing</code></td></tr><tr><td><code>-Wstrict-overflow=1</code></td></tr><tr><td><code>-Wswitch</code></td></tr><tr><td><code>-Wtautological-compare</code></td></tr><tr><td><code>-Wtrigraphs</code></td></tr><tr><td><code>-Wuninitialized</code></td></tr><tr><td><code>-Wunknown-pragmas</code></td></tr><tr><td><code>-Wunused-function</code></td></tr><tr><td><code>-Wunused-label</code></td></tr><tr><td><code>-Wunused-value</code></td></tr><tr><td><code>-Wunused-variable</code></td></tr><tr><td><code>-Wvolatile-register-var</code></td></tr></tbody></table><ul><li>-fno-builtin 不承认不以 __builtin_ 开头的内建 ( built-in ) 函数。</li><li>-ggdb 生成用于GDB的调试信息</li><li>-gstabs 使用stabs格式生成调试信息，</li><li>-nostdinc 不搜索头文件的标准系统目录</li><li>-fno-stack-protector 禁用堆栈保护机制</li></ul><h1 id="GNU-linker-ld-命令选项"><a href="#GNU-linker-ld-命令选项" class="headerlink" title="GNU linker ( ld ) 命令选项"></a>GNU linker ( ld ) 命令选项</h1><ul><li>-m emulation 模拟仿真链接器 如：-m elf_i386</li><li>-nostdlib 只用在命令行中显式指定的搜索库目录</li><li>-N 设置代码段和数据段均可读写</li><li>-e 指定入口</li><li>-Ttext 连接时重定向初始地址</li></ul><h1 id="dd-命令参数"><a href="#dd-命令参数" class="headerlink" title="dd 命令参数"></a>dd 命令参数</h1><ul><li><strong>if</strong> 代表输入文件。如果不指定if，默认就会从stdin中读取输入。</li><li><strong>of</strong> 代表输出文件。如果不指定of，默认就会将stdout作为默认输出。</li><li><strong>bs</strong> 代表字节为单位的块大小。</li><li><strong>count</strong> 代表被复制的块数。</li><li><strong>/dev/zero</strong> 是一个字符设备，会不断返回0值字节（\0）</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://gcc.gnu.org/onlinedocs/gcc-8.1.0/gcc/" target="_blank" rel="noopener">GCC 8.1 manuals</a></li><li>ld GNU Development Tools ( man ld )</li><li><a href="http://man.linuxde.net/dd" target="_blank" rel="noopener">Linux dd 命令详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;此篇仅介绍一些我在 ucore 操作系统的 makefile 文件中遇到的命令选项，作为 lab_1 实验报告的一部分。&lt;/p&gt;
&lt;h1 i
      
    
    </summary>
    
      <category term="泛 - 计算机" scheme="https://blog.pazyx.xyz/categories/%E6%B3%9B-%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="Linux" scheme="https://blog.pazyx.xyz/tags/Linux/"/>
    
      <category term="C" scheme="https://blog.pazyx.xyz/tags/C/"/>
    
      <category term="gcc" scheme="https://blog.pazyx.xyz/tags/gcc/"/>
    
      <category term="ld" scheme="https://blog.pazyx.xyz/tags/ld/"/>
    
      <category term="dd" scheme="https://blog.pazyx.xyz/tags/dd/"/>
    
      <category term="操作系统" scheme="https://blog.pazyx.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="linker" scheme="https://blog.pazyx.xyz/tags/linker/"/>
    
  </entry>
  
</feed>
